---
sidebar_position: 1
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# Les classes

## Introduction aux classes

[Learn Intermediate JavaScript | Codecademy](https://www.codecademy.com/courses/learn-intermediate-javascript/lessons/classes/exercises/introduction)

JavaScript est un langage de *programmation orienté objet* - *object-oriented programming* (OOP) que nous pouvons utiliser pour
modéliser des éléments du monde réel. Dans cette leçon, vous apprendrez à faire des classes. Les classes sont un outil que les
développeurs utilisent pour produire rapidement des objets similaires.

Prenons, par exemple, un objet représentant un chien nommé `Halley`. Le `name` de ce chien (une clé) est `"Halley"` (une valeur) et
a un `behavior` ("*comportement*") (une autre clé) de `0` (une autre valeur). Nous créons l'objet `halley` ci-dessous :

```javascript
let halley = {
    _name: 'Halley',
    _behavior: 0,

    get name() {
        return this._name;
    },

    get behavior() {
        return this._behavior;
    },

    incrementBehavior() {
        this._behavior++;
    }
}
```

Maintenant, imaginez que vous possédez une garderie pour chiens et que vous souhaitez créer un catalogue de tous les chiens qui
appartiennent à la garderie. Au lieu d'utiliser la syntaxe ci-dessus pour chaque chien qui rejoint la garderie, nous pouvons créer
une classe `Dog` qui sert de modèle pour créer de nouveaux objets `Dog`. Pour chaque nouveau chien, vous pouvez fournir une valeur
pour son nom.

Comme vous pouvez le voir, les classes sont un excellent moyen de réduire le code en double et le temps de débogage.

Après avoir posé les bases des cours dans les premiers exercices, nous présenterons l'héritage et les méthodes statiques, deux
fonctionnalités qui rendront votre code plus efficace et plus significatif.

:::info instructions
1 - Dans le prochain exercice, vous en apprendrez plus sur les classes. Avant de le faire, prenez un moment pour étudier le cours dans
**main.js**.

Passez un peu de temps à identifier les similitudes et les différences entre la classe `Dog` dans **main.js** et le code que nous
avons utilisé pour créer notre objet `halley` dans les instructions ci-dessus.
:::

```javascript title="main.js"
class Dog {
    constructor(name) {
        this._name = name;
        this._behavior = 0;
    }
    get name() {
        return this._name;
    }
    get behavior() {
        return this._behavior;
    }   
    incrementBehavior() {
        this._behavior ++;
    }
}
```

:::info instructions
2 - Copiez l'instanciation de classe, l'appel de méthode et les instructions `console.log()` ci-dessous dans **main.js**.

```javascript
const halley = new Dog('Halley');
console.log(halley.name); // Affiche la valeur du nom dans la console
console.log(halley.behavior); // Affiche la valeur du comportement dans la console
halley.incrementBehavior(); // Ajoute un au comportement
console.log(halley.name); // Affiche la valeur du nom dans la console
console.log(halley.behavior); // Affiche la valeur du comportement dans la console
```

Qu'attendez-vous de voir lorsque vous exécutez ce code ?
:::

<nav className="docs-nav">
<div className="docs-nav-code">

```javascript title="main.js"
const halley = new Dog('Halley');
console.log(halley.name);
console.log(halley.behavior);
halley.incrementBehavior();
console.log(halley.name);
console.log(halley.behavior);
```

</div>
<div className="docs-nav-html">

```shell title="console"

Halley
0

Halley
1
```

</div>
</nav>

-----

## Constructeur

Dans le dernier exercice, vous avez créé une classe appelée `Dog` et l'avez utilisée pour produire un objet `Dog`.

Bien que vous puissiez voir des similitudes entre la syntaxe des classes et des objets, il existe une méthode importante qui les
distingue. C'est ce qu'on appelle la méthode *constructor*. JavaScript appelle la méthode `constructor()` à chaque fois qu'il crée
une nouvelle *instance* d'une classe.

```javascript
class Dog {
    constructor(name) {
        this.name = name;
        this.behavior = 0;
    }
}
```

- `Dog` est le nom de notre classe. Par convention, nous mettons en majuscule et en CamelCase les noms de classe.
- JavaScript invoquera la méthode `constructor()` chaque fois que nous créons une nouvelle instance de notre classe `Dog`.
- Cette méthode `constructor()` accepte un argument, `name`.
- À l'intérieur de la méthode `constructor()`, nous utilisons le mot-clé `this`. Dans le contexte d'une classe, `this` fait référence
à une instance de cette classe. Dans la classe `Dog`, nous utilisons `this` pour définir la valeur de la propriété `name` de
l'instance Dog sur l'argument `name`.
- Sous `this.name`, nous créons une propriété appelée `behavior`, qui gardera une trace du nombre de fois qu'un chien se comporte mal.
La propriété `behavior` est toujours initialisée à zéro.

Dans l'exercice suivant, vous apprendrez à créer des instances `Dog`.

:::info instructions
1 - Créez une classe vide nommée `Surgeon`.
:::

```javascript
class Surgeon {

}
```

:::info instructions
2 - Dans la classe `Surgeon`, créez une méthode `constructor()` qui accepte deux paramètres : `name` et `department`.
:::

```javascript
class Surgeon {
    constructor(name, department) {

    }
}
```

:::info instructions
3 - Dans le `constructor` `Surgeon()`, créez des propriétés de `name` et de `department` et définissez-les sur la même valeur que
vos paramètres d'entrée.
:::

```javascript
class Surgeon {
    constructor(name, department) {
        this.name = name;
        this.department = department;
    }
}
```

-----

## Instance

Maintenant, nous sommes prêts à créer des instances de classe. Une instance est un objet qui contient les noms de propriété et les
méthodes d'une classe, mais avec des valeurs de propriété uniques. Regardons notre exemple de classe `Dog`.

```javascript
class Dog {
    constructor(name) {
        this.name = name;
        this.comportment = 0;
    }
}

const halley = new Dog('Halley'); // Crée une nouvelle instance de Chien
console.log(halley.nom); // Enregistre la valeur du nom enregistrée dans Halley
// Sortie : 'Halley'
```

Sous notre classe `Dog`, nous utilisons le mot-clé `new` pour créer une instance de notre classe `Dog`. Considérons la ligne de code
étape par étape.

- Nous créons une nouvelle variable nommée `Halley` qui stockera une instance de notre classe `Dog`.
- Nous utilisons le mot-clé `new` pour générer une nouvelle instance de la classe `Dog`. Le mot clé `new` appelle le `constructor()`,
exécute le code qu'il contient, puis renvoie la nouvelle instance.
- Nous passons la chaîne `'Halley'` au constructeur `Dog`, qui définit la propriété `name` sur `'Halley'`.
- Enfin, nous enregistrons la valeur enregistrée dans la clé `name` dans notre objet `Halley`, qui enregistre `'Halley'` dans la
console.

Vous savez maintenant créer des instances. Dans l'exercice suivant, vous apprendrez à ajouter des getters, des setters et des méthodes.

:::info instructions
1 - Créez une instance de la classe `Surgeon` — définissez le `name` sur `'Francisco Romero'` et `department` sur `'Cardiovascular'`.

Enregistrez l'instance dans une variable constante appelée `surgeonRomero`.
:::

```javascript
const surgeonRomero = new Surgeon('Francisco Romero', 'Cardiovascular');
```

:::info instructions
2 - Créez une instance de la classe `Surgeon` — définissez `name` sur `'Ruth Jackson'` et `department` sur `'Orthopedics'`.

Enregistrez l'instance dans une variable constante appelée `surgeonJackson`.
:::

```javascript
const surgeonJackson = new Surgeon('Ruth Jackson', 'Orthopedics');
```

-----

## Méthodes

À ce stade, nous avons une classe `Dog` qui fait tourner des objets avec des propriétés `name` et `behavior`. Ci-dessous, nous
ajouterons des getters et une méthode pour donner vie à notre classe.

La méthode classe et la syntaxe getter sont les mêmes que pour les objets, **sauf que vous ne pouvez pas inclure de virgules entre les
méthodes**.

```javascript
class Dog {
    constructor(name) {
        this._name = name;
        this._behavior = 0;
    }

    get name() {
        return this._name;
    }

    get behavior() {
        return this._behavior;
    }

    incrementBehavior() {
        this._behavior++;
    }
}
```

Dans l'exemple ci-dessus, nous ajoutons des méthodes getter pour `name` et `behavior`. Notez que nous avons également ajouté au début
de nos noms de propriété des traits de soulignement (`_name` et `_behavior`), qui indiquent que ces propriétés ne doivent pas être
accédées directement. Sous les getters, nous ajoutons une méthode nommée `.incrementBehavior()`. Lorsque vous appelez
`.incrementBehavior()` sur une instance Dog, il ajoute `1` à la propriété `_behavior`. Entre chacune de nos méthodes, nous n'avons
*pas* inclus de virgules.

:::info instructions
1 - Dans le constructeur `Surgeon`, ajoutez un trait de soulignement (`_`) au début des propriétés `name` et `department`.

2 - À l'intérieur du `constructor()`, ajoutez une propriété nommée `_remainingVacationDays` et définissez-la sur `20`.

3 - Sous le `constructor()`, créez un getter appelé `name` qui renvoie la valeur enregistrée dans `_name`.
:::

```javascript
class Surgeon {
    constructor(name, department) {
        this._name = name;
        this._department = department;
        this._remainingVacationDays = 20;
    }
    get name() {
        return this._name;
    }
}
```

:::info instructions
4 - Sous le getter `name`, créez un getter appelé `department` qui renvoie la valeur enregistrée dans `_department`.
:::

```javascript
    get department() {
        return this._department;
    }
```

:::info instructions
5 - Sous le getter `department`, créez un getter appelé `restantVacationDays` qui renvoie la valeur enregistrée dans `_remainingVacationDays`.
:::

```javascript
    get remainingVacationDays() {
        return this._remainingVacationDays;
    }
```

:::info instructions
6 - Sous le getter `remainingVacationDays`, créez une méthode appelée `takeVacationDays` qui accepte un argument nommé `daysOff`.

À l'intérieur de la méthode, soustrayez `daysOff` du nombre enregistré dans `_remainingVacationDays`. Définissez `_remainingVacationDays`
sur le résultat.
:::

```javascript
    takeVacationDays(daysOff) {
        this._remainingVacationDays -= daysOff;    
    }
```

:::note
[L'opérateur get - JavaScript | MDN](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Functions/get)
:::

-----

## Appels de méthode

Enfin, utilisons nos nouvelles méthodes pour accéder et manipuler les données des instances `Dog`.

```javascript
class Dog {
    constructor(name) {
        this._name = name;
        this._behavior = 0;
    }

    get name() {
        return this._name;
    }

    get behavior() {
        return this._behavior;
    }

    incrementBehavior() {
        this._behavior++;
    }
}

const halley = new Dog('Halley');
```

Dans l'exemple ci-dessus, nous créons la classe `Dog`, puis créons une instance et l'enregistrons dans une variable nommée `Halley`.

La syntaxe pour appeler des méthodes et des getters sur une instance est la même que pour les appeler sur un objet — ajoutez à
l'instance un point, puis le nom de la propriété ou de la méthode. Pour les méthodes, vous devez également inclure des parenthèses
ouvrantes et fermantes.

Prenons un moment pour créer deux instances `Dog` et appelons notre méthode `.incrementBehavior()` sur l'une d'entre elles.

```javascript
let nikko = new Dog('Nikko'); // Créer un chien nommé Nikko
nikko.incrementBehavior(); // Ajoute 1 au comportement de l'instance nikko
let bradford = new Dog('Bradford'); // Créer le nom de chien Bradford
console.log(nikko.behavior); // Enregistre 1 dans la console
console.log(bradford.behavior); // Enregistre 0 dans la console
```

Dans l'exemple ci-dessus, nous créons deux nouvelles instances `Dog`, `nikko` et `bradford`. Comme nous incrémentons le comportement
de notre instance `nikko`, mais pas `bradford`, l'accès à `nikko.behavior` renvoie `1` et l'accès à `bradford.behavior` renvoie `0`.

:::info instructions
1 - Au bas de **main.js**, utilisez `console.log()` pour afficher la valeur enregistrée dans la propriété `name` de l'objet
`surgeopnRomero`.
:::

```javascript
console.log(surgeonRomero.name)  // Francisco Romero
```

:::info instructions
2 - Appelez `.takeVacationDays()` sur le `surgeonRomero`, avec une entrée de `3`.
:::

```javascript
surgeonRomero.takeVacationDays(3);
```

:::info instructions
3 - Après l'appel à `.takeVacationDays()`, utilisez `console.log()` pour imprimer la valeur enregistrée dans la propriété
`remainingVacationDays` de l'instance de `surgeonRomero`.
:::
```javascript
console.log(surgeonRomero.remainingVacationDays) // 17
```

:::note
[Accesseurs de propriétés - JavaScript | MDN](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Operators/Property_accessors)
:::

-----

## Héritage I

Imaginez que notre garderie pour chiens connaisse un tel succès que nous décidons d'agrandir l'entreprise et d'ouvrir une garderie
pour chatons. Avant l'ouverture de la garderie, nous devons créer une classe `Cat` afin de pouvoir générer rapidement des instances
`Cat`. Nous savons que les propriétés de notre classe `Cat` (`name`, `behavior`) sont similaires aux propriétés de notre classe `Dog`,
cependant, il y aura quelques différences, car bien sûr, les chats ne sont pas des chiens.

Disons que notre classe `Cat` ressemble à ceci :

```javascript
class Cat {
    constructor(name, usesLitter) {
        this._name = name;
        this._usesLitter = usesLitter;
        this._behavior = 0;
    }

    get name() {
        return this._name;
    }

    get usesLitter() {
        return this._usesLitter;
    }

    get behavior() {
        return this._behavior;
    }  
 
    incrementBehavior() {
        this._behavior++;
    }
}
```

Dans l'exemple ci-dessus, nous créons une classe `Cat`. Il partage quelques propriétés (`_name` et `_behavior`) et une méthode
(`.incrementBehavior()`) avec la classe `Dog` des exercices précédents. La classe `Cat` contient également une propriété
supplémentaire (`_usesLitter`), qui contient une valeur booléenne pour indiquer si un chat peut utiliser sa litière.

Lorsque plusieurs classes partagent des propriétés ou des méthodes, elles deviennent candidates *à l'héritage* - un outil que les
développeurs utilisent pour réduire la quantité de code qu'ils doivent écrire.

Avec l'héritage, vous pouvez créer une classe *parent* (également appelée superclasse) avec des propriétés et des méthodes que
plusieurs classes *enfants* (également appelées sous-classes) partagent. Les classes enfants héritent des propriétés et des méthodes
de leur classe parente.

Faisons abstraction des propriétés et méthodes partagées de nos classes `Cat` et `Dog` dans une classe parent appelée `Animal`.

```javascript
class Animal {
    constructor(name) {
        this._name = name;
        this._behavior = 0;
    }

    get name() {
        return this._name;
    }

    get behavior() {
        return this._behavior;
    }

    incrementBehavior() {
        this._behavior++;
    }
}
```
Dans l'exemple ci-dessus, la classe `Animal` contient les propriétés et les méthodes que partagent les classes `Cat` et `Dog` (`name`,
`behavior`, `.incrementBehavior()`).

Le diagramme de droite montre les relations que nous voulons créer entre les classes Animal, Cat et Dog.

![diagram: child classes Dog and Cat inherit from parent class Animal](/Mon_Web_Dev_Wiki/docs/Codecademy/assets/inheritance_diagram.svg)

-----

