---
sidebar_position: 5
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo, YouTube } from 'mdx-embed';

# Allez plus loin

## Triez des informations

[Triez des informations - DÃ©couvrez le fonctionnement des algorithmes - OpenClassrooms](https://openclassrooms.com/fr/courses/4366701-decouvrez-le-fonctionnement-des-algorithmes/4385150-triez-des-informations)

<Vimeo vimeoId="213636393" />

<br />

Nous avons vu que les algorithmes nous permettaient de rÃ©soudre des problÃ¨mes plus ou moins complexes. Un des problÃ¨mes les plus
rÃ©pandus consiste Ã  trier les informations. Cela vous semble facile Ã  faireâ€‰? Et pourtantâ€‰! Il ne nous faut pas seulement trier les
informations, mais Ã©galement trouver la maniÃ¨re la plus efficace de le faire.

Trier une suite de 10 nombres du plus petit au plus grand nâ€™est effectivement pas trÃ¨s long. Mais quâ€™en est-il lorsque nous avons
100000 nombres Ã  trierâ€‰? Que se passe-t-il lorsque vous vous appelez Google et que vous devez trier plusieurs centaines de gigaoctets
dâ€™e-mailsâ€‰?

Les algorithmes de tri sont lâ€™essence mÃªme de lâ€™algorithmique. En effet, nous souhaitons souvent rÃ©organiser des donnÃ©es pour les
manipuler autrement. Il est donc essentiel dâ€™en savoir un peu plus.

DÃ©couvrez tout de suite un des algorithmes de tri les plus connusÂ : le tri Ã  bullesâ€‰!

### Le tri Ã  bulles

Cet algorithme avance dans une liste dâ€™Ã©lÃ©ments. Il compare les donnÃ©es deux Ã  deux et les Ã©change si la premiÃ¨re valeur est plus
Ã©levÃ©e que la seconde. Il fait cela pour toutes les paires dâ€™Ã©lÃ©ments dans une liste puis recommence au dÃ©but jusquâ€™Ã  ce que toutes
les paires soient dans le bon ordre.

<YouTube youTubeId="Cq7SMsQBEUw" />

<br />

Faisons une dÃ©monstration avec des livresâ€‰! Nous avons tous eu un jour ou lâ€™autre Ã  trier notre bibliothÃ¨que, que ce soit par ordre
alphabÃ©tique, par auteur ou par hauteur. Pour cette dÃ©monstration, disons que nous trions les livres par hauteur.

Nous saisissons le premier livre et le comparons au suivant. Sâ€™il est plus grand, nous les Ã©changeons. Sinon, nous les laissons ainsi.

Quand nous avons fini de parcourir tous les livres une premiÃ¨re fois, le plus grand se trouve bien Ã  la fin. Nous pouvons alors
recommencer un tour de boucle pour placer lâ€™Ã©lÃ©ment suivant.

Et ainsi de suite jusquâ€™Ã  ce que la bibliothÃ¨que soit triÃ©eâ€‰!

:::info
Pourquoi ce nom 'tri Ã  bulles'â€‰? Tout simplement parce que la plus grande donnÃ©e remonte peu Ã  peu Ã  la fin de la liste, exactement
comme des bulles de savon.
:::

Comment lâ€™Ã©cririons-nous en pseudo-codeâ€‰?

Nous commenÃ§ons par Ã©crire une fonction qui va parcourir tous les livres, un Ã  un. Vous connaissez dÃ©jÃ  cette structureÂ : il sâ€™agit
dâ€™une boucleâ€‰! Nous allons donc faire 10 tours, puisque nous allons parcourir une liste de 10 livres.

```text
tri_Ã _bulles(Tableau T)
    pour i allant de taille de T - 1 Ã  1
        fais quelque chose
```

Quand nous sommes dans la boucle, nous intervertissons les livresÂ _si_ le second est plus grand que le premier. Nous pouvons donc
utiliser les structures conditionnelles que nous avons dÃ©jÃ  vues.

```text
tri_Ã _bulles(TableauT)
    pour i allant de taille de T - 1 Ã  1
        si T[i + 1] < T[i]
            echanger_(T[i + 1], T[i])
```

Ceci est dÃ©jÃ  trÃ¨s bien, mais ce nâ€™est pas suffisant. Actuellement, chaque item a bougÃ© dâ€™une place, mais nâ€™est pas vraiment remontÃ©
jusquâ€™Ã  la fin. Alors, comment faireâ€‰?

Si nous rÃ©flÃ©chissons bien, il faut faire un nombre de boucles correspondant au nombre dâ€™items restant Ã  trier dans la liste au carrÃ©.

Prenons lâ€™exemple du premier livre. Sâ€™il sâ€™agit du plus grand, notre algorithme devra effectuer 9 tours de boucle afin de le
positionner Ã  la fin. Mais une fois que le livre est en place, il sait quâ€™il nâ€™a pas Ã  aller jusquâ€™Ã  la fin. Il peut donc effectuer 8
tours de boucle, puis 7, puis 6 et ainsi de suite jusquâ€™Ã  1.

En pseudo-code, nous allons le reprÃ©senter ainsiÂ :

```text
tri_Ã _bulles(Tableau T)
    pour i allant de taille de T - 1 Ã  1
        pour j allant de 0 Ã  i - 1
            si T[j+1] < T[j]
                Ã©changer(T[j+1], T[j])
```

En PythonÂ :

```python
def inter(a_list):
    for i in range(0, len(a_list) - 1):
        for j in range(0, len(a_list) - 1):
            if a_list[j + 1] < a_list[j]:
                a_list[j+1], a_list[j] = a_list[j], a_list[j+1]
    return a_list
```

:::info
Il existe dâ€™autres maniÃ¨res dâ€™utiliser le tri Ã  bulles en Python. Je vous en fais la dÃ©monstration dans lâ€™avant-dernier chapitreâ€‰! ;-)
:::

### Autres algorithmes de tri

Le tri Ã  bulles est le plus connu de tous, mais pas le plus efficace. Dâ€™ailleurs, nous-mÃªmes, lorsque nous devons trier des livres,
nous ne comparons pas deux livres et ainsi de suite. Nous utilisons dâ€™autres algorithmes.

Si nous avons une grande bibliothÃ¨que, nous pouvons dÃ©cider de la diviser en plusieurs unitÃ©s plus petites afin de les trier sÃ©parÃ©ment
et ensuite de les fusionner. Ou bien nous nous disonsÂ : je mets les livres les plus grands et les plus petits au dÃ©but, en mÃªme temps.

Bref, nous avons chacun notre stratÃ©gie. Il existe trop dâ€™algorithmes de tri diffÃ©rents pour tous les expliquer ici. Je vous conseille
nÃ©anmoins de regarder cette [liste non exhaustive des diffÃ©rents tris proposÃ©s sur cette page WikipÃ©dia](https://fr.wikipedia.org/wiki/Algorithme_de_tri#Comparaison_des_algorithmes)
et dâ€™en lire quelques dÃ©finitions afin de mieux les comprendre.

-----

## Comprenez la complexitÃ© algorithmique

[Comprenez la complexitÃ© algorithmique - DÃ©couvrez le fonctionnement des algorithmes - OpenClassrooms](https://openclassrooms.com/fr/courses/4366701-decouvrez-le-fonctionnement-des-algorithmes/4420551-comprenez-la-complexite-algorithmique)

<Vimeo vimeoId="213636441" />

<br />

### Un problÃ¨me vraiment complexeâ€‰?

La complexitÃ© algorithmique est un concept trÃ¨s important qui permet de **comparer les algorithmes** afin de trouver celui qui est le
plus efficace.

Avant dâ€™entrer dans le dÃ©tail de son calcul, laissez-moi vousÂ conter une petite histoire.

#### ComplexitÃ© exponentielle

Nous sommes dans le Midi, au cÅ“ur dâ€™une belle forÃªt composÃ©e dâ€™arbustes aromatiques et de pins. Il sâ€™agit dâ€™une douce matinÃ©e dâ€™Ã©tÃ©
Ã©clairÃ©e par un soleil enthousiaste et nous nous promenons sur un chemin serpentant entre les collines. Soudain, un Ã©clat de lumiÃ¨re
attire votre regard entre lesÂ branchages. Vous vous approchez. Quelle nâ€™est pas votre surprise lorsque vous apercevez, entre deux
bruyÃ¨res, un coffre qui semble Ãªtre sorti tout droit dâ€™un bateau pirateâ€‰!

Oh gloire, la fortune serait-elle enfin Ã  votre portÃ©eâ€‰? Vous soulevez le coffre et tombez nez Ã  nez avec un **cadenas Ã  trois chiffres**,
en fonte, bien dÃ©cidÃ© Ã  ne pas vous laisser accÃ©der au trÃ©sor tant escomptÃ©. Quand bien mÃªmeâ€‰! Nous dÃ©cidons de relever le dÃ©fi et de
tester rapidement, une Ã  une, toutes les combinaisons.

PlutÃ´t que de les tester dans le dÃ©sordre, car il serait impossible de se souvenir de toutes les tentatives, nous rÃ©flÃ©chissons Ã 
**diffÃ©rentes stratÃ©gies**. Lâ€™une dâ€™elles consiste Ã  **essayer le nombre le plus petit (000) puis le nombre suivant (001)** et ainsi de
suiteÂ jusquâ€™Ã  atteindre 999. En effet,Â nous calculons que cette stratÃ©gie nous prendra, dans le pire des cas, 30 minutes.

Effectivement, quelques minutes plus tard, le cadenas sâ€™ouvre. Hourraâ€‰! Le code Ã©tait 123. Facileâ€‰! Notre stratÃ©gie Ã©tait efficace et
nous nous fÃ©licitons dâ€™Ãªtre si intelligents.

Nous ouvrons le coffre... pourÂ en dÃ©couvrir un second, plus petit, comportant un **cadenas Ã  4 chiffres**. Tristesse.

Forts de notre premier succÃ¨s, **nous nous basons surÂ le mÃªme algorithme pour trouver le code**. Au bout dâ€™une heure et demie, las,
nous abandonnons lâ€™idÃ©e. Câ€™est le plus raisonnableÂ : tester toutes les combinaisons possibles aurait pris plus de 5 heures.

Nous reprenons notre marche, le petit coffre sous le bras, et partons dans un grand dÃ©batÂ : comment en est-on arrivÃ©s lÃ â€‰? CommentÂ le
temps de calcul peut-il passer de 30 minutes Ã  5 heures en ajoutant un simple chiffreâ€‰? **Le secret, câ€™est la complexitÃ© de notre
algorithme**.

Au risque de ne pas vous surprendre, plus il y a de chiffres dans le code, plus il sera long Ã  trouver. **Mais plus long commentâ€‰?**

Si le code a **3 chiffres**, il faut tester **1000 combinaisons** (eh oui, tous les nombres entre 000 et 999). En revanche, sâ€™il en a
**4**, il faut en tester **10Â 000**. Sâ€™il en avait eu **5**, il aurait fallu en tester **100Â 000**, et ainsi de suite. Nous nous
apercevonsÂ donc que **notre algorithme dâ€™ouverture de coffre dÃ©pend du nombre de chiffres du code**.

:::info
Plus prÃ©cisÃ©ment, le temps mis Ã  lâ€™ouvrir est multipliÃ© par 10 Ã  chaque fois que lâ€™on ajoute un chiffreÂ : 10 pour un code Ã  1 chiffre,
100 (10 x 10) pour un code Ã  2 chiffres, 1Â 000 (10 x 10 x 10) pour un code Ã  trois chiffres, et ainsi de suite.

Si lâ€™on note *n* leÂ nombre de chiffres de notre cadenas, le temps de calcul est donc 10<sup>n</sup>.
:::

On dit alors que **la complexitÃ© est exponentielle.** TrÃ¨s vite, nous nous sommes rendu compte que notre algorithme Ã©tait impossible Ã 
rÃ©aliser, car il devenait trop long.

#### ComplexitÃ© linÃ©aire

AprÃ¨s avoir dissertÃ© sur ce sujet, nous avons soudain une idÃ©eÂ : et si nous arrÃªtions de calculer et faisions appel Ã  Bill, notre
cousin, celui qui trempe dans des affaires louchesâ€‰? Il nous a racontÃ© un jourÂ quâ€™il savait "_Ã©couter les cadenas_". Sa technique est
simpleÂ : **il tourne la molette du premier chiffre jusquâ€™Ã  entendre un "_clic_"**. Il sait alors que le chiffre est bon et passe au
suivant. Il peut donc trouver les bons chiffres un par un, sans avoir Ã  se soucier des autres.

Ã‰videmment, le jour oÃ¹ il vous a exposÃ© sa thÃ©orie vous avez bien ri. Ã€ prÃ©sent, vous Ãªtes dubitatifÂ : vous avez passÃ© deux heures Ã 
essayer dâ€™ouvrir des coffres de pirates, alors bon, pourquoi ne pas tenterâ€‰?

Au bout de deux minutes, le cadenas Ã  4 chiffres est ouvert. Youpiâ€‰! Le code Ã©tait 7339. ET Lâ€™ON A UTILISÃ‰ UNE TECHNIQUE DE GANGSTERâ€‰!!
Nous hurlons si fort que mÃªme les cigales se taisent.

Ã€ prÃ©sent, nous ouvrons le coffre et en dÃ©couvrons le contenu. IlÂ est Ã  la hauteur de nos effortsÂ !

:::note ?
_Mais comment peut-on aller si vite, alors queÂ nous avons exactement le mÃªme nombre de chiffres sur le cadenasâ€‰?_
:::

Câ€™est trÃ¨s simpleâ€‰! Afin de trouver le premier chiffre du code, Bill tente 10 combinaisons. Quand il lâ€™a trouvÃ©, il passe au suivant
et teste de nouveau 10 combinaisons. Et ainsi de suite pour chaque chiffreâ€‰!

Il nâ€™aura donc Ã  tester que **40Â combinaisons** (10 + 10 + 10 + 10, soit 10 x 4) pour ce cadenas Ã  quatre chiffres (ce qui est mieux
que les 10Â 000 combinaisons que nous nous apprÃªtions Ã  essayerâ€¦).

Si lâ€™on y regarde de plus prÃ¨s, Bill teste **10 nouvelles combinaisons pour chaque nouveau chiffre du cadenas**. Autrement dit, si _n_
est le nombre de chiffres, il teste 10 x _n_ combinaisons. Vous lâ€™avez dans le mille, la "complexitÃ©" de son algorithme Ã©tait bien
meilleure que la nÃ´tre.

Nous appelons cela une **complexitÃ© linÃ©aire**. Pourquoiâ€‰? Car elle augmente **proportionnellement** au nombre de chiffres.

#### ComplexitÃ© en temps constant

Tout contents, nous allons rendre visite Ã  Bill pour lui montrer le cadenas (nous avons bien pris soin de cacher le contenu du coffre...
on ne sait jamaisâ€‰!) et crÃ¢ner un peu. Pour sÃ»r, il sera impressionnÃ©â€‰!

Bill vous adresse un regard circonspect. _"Vous voulez vous amuserâ€‰? VoilÃ  de quoi faireâ€‰!",_ vous dit-il, sortant dâ€™unÂ placard un
cadenas Ã  **500 chiffres** qui manque de faire Ã©crouler la table de la salle Ã  manger. _"Il faut tester **5000 combinaisons**, ce qui
prendra environ 3 heures. Enfin... Si vous Ãªtes rapides."_

Mince,Â nous nous retrouvons dans le mÃªme problÃ¨me que tout Ã  lâ€™heure. Aussi efficace que soit sa technique,Â le nombre de chiffres du
cadenas est trop important. Autrement dit, **la taille des donnÃ©es du problÃ¨me excÃ¨de la capacitÃ© de son algorithme**.

Câ€™est lÃ  que passe Jack, votre neveu. Il rigole, **prend une pierre et tape sur le cadenas**. Pafâ€‰! Ce dernier sâ€™ouvre dâ€™un coup sec.
Effectivement... Cela paraÃ®t si simple, maintenant que lâ€™on y penseâ€¦

Si lâ€™on sâ€™y attarde de plus prÃ¨s, son algorithme est sacrÃ©ment efficaceâ€‰! **Quel que soit le nombre de chiffres, il prendÂ toujours le
mÃªme temps**. BalÃ¨zeâ€‰!

Nous parlons alorsÂ de **complexitÃ© en temps constant**.

:::info
En rÃ©sumÃ©, ces coffres nous ont permis de dÃ©couvrirÂ trois formes de complexitÃ©s diffÃ©rentesÂ :
- ComplexitÃ© en temps constant (merci Jackâ€‰!)Â : notÃ©e O(1)
- ComplexitÃ© linÃ©aire (merci Billâ€‰!)Â : notÃ©e O(n)
- ComplexitÃ© exponentielle (merci notre cerveauâ€‰!)Â : notÃ© O(10<sup>n</sup>)
:::

### Le temps et lâ€™espace

#### La complexitÃ© temporelle

Si nous comparons nos diffÃ©rents algorithmes, nous nous rendons compte que nous avons surtout pris en compte le facteur **temps**Â :
notre premiÃ¨re solution nous a pris 30 minutes quand celle de Jack ne demande quâ€™une seconde (bon, deux si le cadenas est vraiment
rÃ©calcitrant).

Il en sera de mÃªme pour chaque algorithme, que ce soit le tri dâ€™une liste, la dÃ©composition en facteur premier ou encore la recherche
du cours le plus suivi sur OpenClassrooms. Nous parlons alors de **complexitÃ© temporelle**.

Quel est lâ€™intÃ©rÃªt, me direz-vousâ€‰? Cela nous permet de savoir Ã  lâ€™avance si un algorithme ne se terminera jamais. Bien pratiqueâ€‰!

:::warning X
Si nous avionsÂ utilisÃ© notre algorithme naÃ¯f pour ouvrir le cadenas Ã  500 chiffres, un milliard dâ€™annÃ©es ne nous auraient pas suffi Ã 
trouver la bonne combinaison. Inutile de dire que nous serions morts, rÃ©incarnÃ©s et re-morts avant de pouvoir profiter duÂ contenu
derriÃ¨re le cadenas.
:::

Internet nous offre une autre application trÃ¨s importante de ce concept. Imaginons un site deÂ restauration Ã  emporter. Que se passe-t-il
lorsque vous cherchez tous les restaurants asiatiques Ã  1Â km de chez vous, ouverts jusquâ€™Ã  23 heures et qui livrent Ã  domicileâ€‰?
Lâ€™algorithme va tout faire pour trouver le rÃ©sultat de votre recherche. MalgrÃ© cela, vous nâ€™avez pas envie dâ€™attendre 3 heures. Vous
souhaitez que le site affiche la page de rÃ©sultats en une seconde ou deux, pas plus. Il est donc primordial de trouver lâ€™algorithme le
plus efficace qui soit.

#### La complexitÃ© spatiale

Le dernier point Ã  connaÃ®tre concerne le stockage des donnÃ©es. Lorsque nous rÃ©alisons un algorithme en informatique, les informations
sont stockÃ©es sur la mÃ©moire de lâ€™ordinateur. Or, vous lâ€™aurez devinÃ©, cette mÃ©moire nâ€™est pas infinie. Si nous ne faisons pas
attention, un algorithme peut vite occuper tout lâ€™espace libre dâ€™un ordinateur et le faire planter.

On parle ici de **complexitÃ© spatiale** (en espace). Les notations sont exactement les mÃªmes que pour la complexitÃ© temporelle.

### Ã‰pilogue

Alors que nous nous promenons de nouveau dans la forÃªt, je me tourne vers vous et vous demandeÂ : _"Dâ€™ailleurs, si Jack nâ€™Ã©tait pas
entrÃ© et que lâ€™on avait essayÃ© toutes les combinaisons sur le cadenas Ã  500 chiffres, combien de temps cela nous aurait-il prisâ€‰?"_
Avez-vous une idÃ©eâ€‰?

:::note ?
Vous souhaitez en savoir plus sur lâ€™ouverture des cadenasâ€‰? Ulysse, avec qui jâ€™ai coÃ©crit ce chapitre, vous offre ce [lien bonus](https://www.youtube.com/watch?v=p2RY08QKNtw).
:::

-----

## Voyez le monde autrement avec la rÃ©cursivitÃ©

[Voyez le monde autrement avec la rÃ©cursivitÃ© - DÃ©couvrez le fonctionnement des algorithmes - OpenClassrooms](https://openclassrooms.com/fr/courses/4366701-decouvrez-le-fonctionnement-des-algorithmes/4385343-voyez-le-monde-autrement-avec-la-recursivite)

<Vimeo vimeoId="213636505" />

<br />

Dans ce chapitre, nous allons explorer un nouveau mode de calculÂ : la rÃ©cursivitÃ©.

En programmation, nous avons vu que nous pouvions utiliser des boucles pour rÃ©pÃ©ter une opÃ©ration. Nous les appelons des boucles
_itÃ©ratives_. Laissez-moi vous prÃ©senter un nouveau conceptÂ : la rÃ©cursivitÃ©.

Il sâ€™agit dâ€™un concept un peu spÃ©cial. Avez-vous dÃ©jÃ  rÃªvÃ© que vous rÃªviezâ€‰? Vous y Ãªtesâ€‰! Nous allons parler de concepts qui
sâ€™appellent eux-mÃªmes. Câ€™est partiâ€‰!

### PrÃ©sentation

La rÃ©cursivitÃ© est un concept qui fait rÃ©fÃ©rence Ã  lui-mÃªme dans son fonctionnement. Cela se retrouve dans tous les champs artistiquesÂ :
littÃ©rature (mise en abyme), peinture, photographie...

![Jan Van Eyck, Les Epoux Arnolfini](https://user.oc-static.com/upload/2017/04/06/14914881234382_jan_van_eyck.jpeg)

Jan Van Eyck, Les Ã‰poux Arnolfini

![Mirroirs](https://user.oc-static.com/upload/2017/04/06/14914882140622_mirrors.jpeg)

Miroirs

Nous utilisons dâ€™ailleurs tous les jours la rÃ©cursivitÃ© lorsque nous dÃ©finissons des motsâ€‰! En effet, nous utilisons des mots pour en
dÃ©finir dâ€™autres, eux-mÃªmes Ã©tant dÃ©finis par dâ€™autres motsâ€‰!

Pour les fans de Wall-E, câ€™est Ã©galement un procÃ©dÃ© utilisÃ© par le Capitaine de lâ€™Axiomâ€‰!

<YouTube youTubeId="OWugQ4Rla9k" />

<br />

### En programmation

En programmation, il sâ€™agit dâ€™une fonction qui fait rÃ©fÃ©rence Ã  elle-mÃªme. Deux fonctions peuvent sâ€™appeler lâ€™une lâ€™autre, on parle
alors de rÃ©cursivitÃ© croisÃ©e.

Une fois nâ€™est pas coutume, utilisons un exemple du monde des mathÃ©matiquesÂ : les factorielles. Une factorielle dâ€™un entier naturel n
est le produit des nombres entiers strictement positifs infÃ©rieurs ou Ã©gaux Ã  n.

Elle est notÃ©eÂ `n!`Â et se calcule ainsiÂ : n! = (n-1)! * n.

ExempleÂ : la factorielle 10!

1 Ã— 2 Ã— 3 Ã— 4 Ã— 5 Ã— 6 Ã— 7 Ã— 8 Ã— 9 Ã— 10 = 3Â 628Â 800

Comment la programmerâ€‰?

RÃ©alisons un premier essai en PythonÂ :

```python
def factorielle_recursive(n):
    return n*factorielle_recursive(n-1)
```

DÃ©roulez cet algorithme dans votre tÃªteÂ : vous vous apercevrez quâ€™il ne sâ€™arrÃªte jamais et quâ€™il tourne Ã  lâ€™infiniâ€‰! En effet, si on
lance la fonction avecÂ `n=3`,Â `factorielle_recursive(n)`Â sera appelÃ©e avec n=3, puis n=2, puis n=1, puis n=0, puis n=-1, etc.

Un algorithme qui ne sâ€™arrÃªte jamais, câ€™est un problÃ¨me, vous vous en doutez bienâ€‰!

La solution est donc de spÃ©cifier une _condition dâ€™arrÃªt_, qui dÃ©pendra toujours de notre problÃ¨me. Dans notre cas,Â `3!= 3*2*1`. Vous
remarquez que les diffÃ©rents facteurs (3, 2 et 1) ne sont jamais nÃ©gatifs ni mÃªme Ã©gaux Ã  0. Câ€™est prÃ©cisÃ©ment cette condition qui nous
servira de condition dâ€™arrÃªtÂ : "le facteur ne doit jamais Ãªtre ni infÃ©rieur ni Ã©gal Ã  0".

Ainsi, nous ajoutons une instruction conditionnelleÂ :

```python
def factorielle_recursive(n):
    if n <= 1:
        return 1
    else:
        return n*factorielle_recursive(n-1)
```

Un appel rÃ©cursif doit obligatoirement Ãªtre dans une instruction conditionnelle.

:::info
Lâ€™appel dâ€™une fonction Ã  lâ€™intÃ©rieur dâ€™elle-mÃªme est nommÃ© _appel rÃ©cursif_.
:::

Nous aurions Ã©galement pu implÃ©menter la fonction factorielle de maniÃ¨re itÃ©rativeÂ :

```python
def factorielle_iterative(n):
    x = 1
        for i in range(2, n+1):
            x *= i
        return x
```

### Suite de Fibonacci

Avez-vous dÃ©jÃ  passÃ© un entretien dâ€™embauche technique pour travailler en tant que dÃ©veloppeurÂ·se, par exempleâ€‰? Si oui, la suite de
Fibonacci vous parlera certainementâ€‰! Il sâ€™agit dâ€™un des problÃ¨mes les plus couramment posÃ©s en entretien.

La suite de Fibonacci est une liste de nombres entiers. Elle commence gÃ©nÃ©ralement par les nombres 0 et 1 (parfois 1 et 1). On appelle
un nombre de cette liste un terme. Chaque terme est la somme des deux termes qui le prÃ©cÃ¨dent.

Par exemple, si la suite de Fibonacci dÃ©bute ainsiÂ : 0, 1, 1, 2, 3, 5, 8, 13, 21, etc., vous voyez que 0 + 1 donne 1, que 1 + 2 donne 3,
que 3 + 5 donne 8, et ainsi de suite.

Il existe plusieurs maniÃ¨res de rÃ©soudre le problÃ¨me liÃ© Ã  la suite de Fibonacci. Prenez quelques minutes pour rÃ©flÃ©chir aux diffÃ©rents
algorithmes que vous pourriez inventer.

Dans ce chapitre, nous allons utiliser une mÃ©thode rÃ©cursive et une mÃ©thode itÃ©rative afin que vous puissiez comparer les deux
possibilitÃ©sâ€‰!

### Algorithme rÃ©cursif naÃ¯f

Un algorithme naÃ¯f dÃ©signe un algorithme "simple", trÃ¨s proche de notre pensÃ©e quotidienne. ConcrÃ¨tement, il sâ€™agit de la premiÃ¨re
maniÃ¨re qui vous vient Ã  lâ€™esprit de rÃ©soudre un problÃ¨me.

Dans notre cas, nous pouvons direÂ :

```text
fonction fibonacci(n):
    si n <= 1
        renvoie 1
    sinon
        renvoie fibonacci(n-1) + fibonacci(n-2)

fibonacci(10)
# renverra 89
```

En PythonÂ :

```python
def fibo(n):
    if n <= 1:
        return 1
    else:
        return fibo(n-1) + fibo(n-2)
```

Le problÃ¨me dans ce cas est que nous consommons beaucoup de mÃ©moire. En effet, le calcul est exponentielÂ : il demande deux calculs
diffÃ©rents pour se calculer lui-mÃªme.

Quand nous calculons la valeur dâ€™un nombre, nous rÃ©alisons les trois opÃ©rations suivantesÂ :
- calcule fibonacci(n-1) [qui lui-mÃªme va calculer fibonacci(n-1) et ainsi de suite jusquâ€™Ã  arriver au chiffre 1] et garde la valeur
en mÃ©moireâ€‰;
- calcule fibonacci(n-2) [fais-en de mÃªme Ã  chaque fois jusquâ€™Ã  arriver Ã  1] et garde la valeur en mÃ©moireâ€‰;
- enfin, ajoute les deux prÃ©cÃ©dentes valeurs.

Nous voyons par consÃ©quent que ce calcul est exponentielÂ : chaque nouveau nombre demande deux fois plus de mÃ©moire que son prÃ©cÃ©dent.
Sa complexitÃ© est de O(2<sup>n</sup>).

Peut-on trouver une maniÃ¨re moins consommatrice de le calculerâ€‰?

### Algorithme linÃ©aire

Et si vous calculiez deux valeurs consÃ©cutives Ã  la suiteâ€‰? Cela serait mieux, nonâ€‰?

```python
def fibo(n):
    a,b = 0,1
    for i in range(1, n+1):
        c = a + b
        print(b)
        a = b
        b = c
```

Ã€ prÃ©sent, chaque nouveau nombre nâ€™a plus besoin de deux niveaux dâ€™opÃ©ration pour le gÃ©nÃ©rer, mais dâ€™un seul. Il est donc linÃ©aire et
sa complexitÃ© est de O(n).

Nous voyons ici que, dans bien des cas, nous prÃ©fÃ©rerons la version itÃ©rative, car elle est moins consommatrice en mÃ©moire.

### Les piles dâ€™appels

Lâ€™ordinateur doit retenir le rÃ©sultat de tous les calculs rÃ©cursifs avant de finir sa boucle. Il utilise alors ce que nous appelons une
"pile dâ€™appels" (en anglais, _stack_). Celle-ci est gÃ©rÃ©e automatiquement par le systÃ¨me.

Dans le cas dâ€™un appel rÃ©cursif, câ€™est exactement ce qui se passeâ€‰! Lorsque nous calculons une factorielle, nous devons exÃ©cuter n(-1)!
puis n(-2)! puis n(-3)! jusquâ€™Ã  arriver au nombre que nous souhaitons calculer. Lâ€™ordinateur va donc empiler les rÃ©sultats de n(-1)!,
puis de n(-2)!, de n(-3)! etc.

| valeur de n | rÃ©sultat dans la pile |
|-------------|-----------------------|
| n(-9) | 1 |
| n(-8) | 2 |
| n(-7) | 3 |
| n(-6) | 4 |
| n(-5) | 5 |
| n(-4) | 6 |
| n(-3) | 7 |
| n(-2) | 8 |
| n(-1) | 9 |
| n | 10 |

Lorsque la derniÃ¨re fonction rÃ©cursive est appelÃ©e, lâ€™ordinateur "dÃ©pile". Autrement dit, il va chercher dans la pile le dernier Ã©lÃ©ment
enregistrÃ© et ainsi de suite jusquâ€™Ã  arriver en bas de la pile. Bien pratiqueâ€‰!

### En rÃ©sumÃ©Â : comment programmer une fonction rÃ©cursiveâ€‰?

1/ DÃ©composer le problÃ¨me en un ou plusieurs sous-problÃ¨mes du mÃªme type. On rÃ©sout les sous-problÃ¨mes par des appels rÃ©cursifs.

2/ Les sous-problÃ¨mes doivent Ãªtre de taille plus petite que le problÃ¨me initial.

3/ Enfin, la dÃ©composition doit en fin de compte conduire Ã  un Ã©lÃ©mentaire qui, lui, nâ€™est pas dÃ©composÃ© en sous-problÃ¨mes (câ€™est la
condition dâ€™arrÃªt).

Structure dâ€™une fonction rÃ©cursiveÂ :

```text
mafonction(param1, param2):
    dÃ©but
        si condition faire
            retourner calcul
        sinon faire
            mafonction(param1, param2)
            retourner quelque-chose
        fin condition faire
    fin
fin ma fonction
```

-----

## Codez l'algorithme en Python

[Codez l'algorithme en Python - DÃ©couvrez le fonctionnement des algorithmes - OpenClassrooms](https://openclassrooms.com/fr/courses/4366701-decouvrez-le-fonctionnement-des-algorithmes/4385470-codez-lalgorithme-en-python)

:::info
Ce chapitre nÃ©cessite lâ€™apprentissage de Python, un langage de programmation trÃ¨s utilisÃ© dans la sphÃ¨re scientifique. Vous voulez
apprendreâ€‰? Cela tombe bienÂ : jâ€™ai justement Ã©crit [un cours Ã´ combien passionnant](https://openclassrooms.com/courses/demarrez-votre-projet-avec-python)
qui vous permettra de commencer en douceur.
:::

:::caution !
La version textuelle de ce chapitre diffÃ¨re **lÃ©gÃ¨rement** de la vidÃ©o, car jâ€™ai amÃ©liorÃ© le code Ã  la suite des retours avisÃ©s de
plusieurs lecteurs.
:::

<Vimeo vimeoId="213636575" />

<br />

Pour rappel, voici les rÃ¨gles de notre programmeÂ :
- Chaque candidat a une mention entre "Excellent" et "Ã€ rejeter".
- La mention majoritaire de chaque candidat est calculÃ©e sur une mÃ©diane et non sur une moyenne. 50% au moins des votants trouvent
cette mention valable.
- En cas dâ€™Ã©galitÃ© de mentions majoritairesÂ : celle ou celui ayant le pourcentage de mentions supÃ©rieures Ã  la mention majoritaire le
plus important est le mieux classÃ©.

Et voici les mentionsÂ :
- ExcellentÂ [0]
- TrÃ¨s bienÂ [1]
- Bien [2]
- Assez Bien [3]
- Passable [4]
- InsuffisantÂ [5]
- Ã€Â rejeterÂ [6]

Vous souhaitez coder en mÃªme temps que moiâ€‰? Youpi, vous avez entiÃ¨rement raisonâ€‰! TÃ©lÃ©chargez [ce code pour commencer](https://github.com/celine-m-s/majoritary-judgment/blob/starter/program.py).
Il vous permettra de crÃ©er alÃ©atoirement 100000 votes.

Le fichier de dÃ©part inclut un dictionnaire et un tableau qui vous seront bien utiles. Le premier,Â `CANDIDATES`, contient le nom de
chaque candidat associÃ© Ã  sa clÃ©. Le second,Â `MENTIONS`, contient la liste de toutes les mentions dans un format agrÃ©able Ã  lire.

```python
CANDIDATES = {
    "hermione": "Hermione Granger",
    "balou": "Balou",
    "chuck-norris": "Chuck Norris",
    "elsa": "Elsa",
    "gandalf": "Gandalf",
    "beyonce": "BeyoncÃ©"
}

MENTIONS = [
    "Excellent",
    "TrÃ¨s bien",
    "Bien",
    "Assez Bien",
    "Passable",
    "Insuffisant",
    "A rejeter"
]
```

Nous y reviendrons plus tard.

### Format de donnÃ©es en entrÃ©e

Quelle structure de donnÃ©es choisir pour quâ€™elle soit le plus facilement interprÃ©tableâ€‰? CommenÃ§ons par nous questionner sur les
opÃ©rations que nous allons effectuer. Nous allons lire les donnÃ©es, les trier et trouver lâ€™Ã©lÃ©ment qui se situe Ã  la moitiÃ©.

Regardons sur la [Big O Cheat Sheet](http://bigocheatsheet.com/) ce qui nous est conseillÃ©. Il semblerait que ce soient la table de
hachage (Hash table) et les tableaux (Array) qui lâ€™emportent en ce qui concerne lâ€™accÃ¨s et la recherche. Vous souvenez-vous pourquoiâ€‰?
Un tableau a un index qui le rend plus facile Ã  parcourir pour en extraire des donnÃ©es. Quant Ã  la table de hachage, vous retrouvez
des donnÃ©es via des clÃ©s. Le tableau est moins flexible, mais ce nâ€™est pas vraiment notre souci dans le cas prÃ©sent, puisque nous ne
le modifierons pas.

Je vous propose de crÃ©er un tableau pour regrouper tous nos votes.

Chaque vote sera reprÃ©sentÃ© par une table de hachage dont les clÃ©s seront les diffÃ©rents candidats et leur valeur la mention sous
forme de numÃ©ro. Par exempleÂ :

```python
{ "Hermione": 6 }
```

Voici un extrait de nos donnÃ©es en entrÃ©eÂ :

```python
[
    {"hermione": 1, "balou": 2, "chuck-norris": 3, "elsa": 4, "gandalf": 5, "beyonce": 6},
    {"hermione": 2, "balou": 3, "chuck-norris": 4, "elsa": 5, "gandalf": 6, "beyonce": 0}
]
```

### Format de donnÃ©es en sortie

Notre programme sera lancÃ© en ligne de commandes et devra imprimer, dans notre terminal, une liste affichant ainsiÂ :

```sh
Gagnant : Hermione avec 70% de mentions Bien
Suivants :
- Balou avec 50% de mentions bien
- Chuck Norris avec 50% de mentions assez bien
- Elsa avec 70% de mentions passable
- Gandalf avec 60% de mentions passable
- BeyoncÃ© avec 50% de mentions Ã  rejeter
```

Ceci nâ€™est quâ€™un exemple, car je pense que les rÃ©sultats seront bien diffÃ©rentsâ€‰!

### Algorithme

#### CrÃ©er un tableau intermÃ©diaire

Câ€™est partiâ€‰!

Nous avons vu que notre tableau intermÃ©diaire ressemblerait Ã  ceciÂ :

| | Balou | Hermione | Chuck Norris | Elsa | Gandalf | Beyonce |
|-|-------|----------|--------------|------|---------|---------|
| 6 -Â Ã€ rejeter | | | | | | |
| 5 -Â Insuffisant | | | | | | |
| 4 -Â Passable | | | | | | |
| 3 - Assez bien | | | | | | |
| 2 -Â Bien | | | | | | |
| 1 -Â TrÃ¨s bien | | | | | | |
| 0 -Â Excellent | | | | | | |

Comment le crÃ©er en Pythonâ€‰? En crÃ©ant un tableau Ã  lâ€™intÃ©rieur dâ€™un hash. Comme ceciÂ :

```python
candidates = {
    'hermione': [0, 0, 0, 0, 0, 0, 0],
    'balou': [0, 0, 0, 0, 0, 0, 0],
    'chuck-norris': [0, 0, 0, 0, 0, 0, 0],
    'elsa': [0, 0, 0, 0, 0, 0, 0],
    'gandalf': [0, 0, 0, 0, 0, 0, 0],
    'beyonce': [0, 0, 0, 0, 0, 0, 0]
}
```

:::info
Chaque nombre dans le tableau est le nombre de votes pour chaque mentionâ€‰! Le nombre Ã  lâ€™indexÂ 0 sera le nombre total de mentionsÂ 0
(Excellent, celui Ã  lâ€™indexÂ 1 le nombre total de mentions 5 (Insuffisant), etc.
:::

CrÃ©ons une fonction qui prendra en entrÃ©e une liste de votes et renverra, en sortie, un dictionnaire contenant le rÃ©sultatÂ des
candidatsÂ :

```python
def results_hash(votes):
    candidates_results = {
        candidate: [0]*len(MENTIONS)
        for candidate in CANDIDATES.keys()
    }
    for vote in votes:
        for candidate, mention in vote.items():
            candidates_results[candidate][mention] += 1
    return candidates_results
```

Et ajoutons dans la fonction `main`Â son exÃ©cutionÂ :

```python
def main():
    votes = create_votes()
    results = results_hash(votes)
```

DÃ©composons-leÂ :

```python
candidates_results = {
    candidate: [0]*len(MENTIONS)
    for candidate in CANDIDATES.keys()
}
```

Je commence par crÃ©er un premier tableau dont toutes les valeurs sont Ã  zÃ©ro. Câ€™est normalÂ : pour lâ€™instant, chaque candidat a zÃ©ro
voteâ€‰! Exactement de la mÃªme maniÃ¨re que nous lâ€™avons fait Ã  la main prÃ©cÃ©demmentâ€‰!

Cette fonction crÃ©e le dictionnaire suivantÂ :

```python
{
    "hermione": [0, 0, 0, 0, 0, 0, 0],
    "balou": [0, 0, 0, 0, 0, 0, 0],
    "chuck-norris": [0, 0, 0, 0, 0, 0, 0],
    "elsa": [0, 0, 0, 0, 0, 0, 0],
    "gandalf": [0, 0, 0, 0, 0, 0, 0],
    "beyonce": [0, 0, 0, 0, 0, 0, 0]
}
```

Puis, je vais parcourir chaque vote et ajouter 1 quand un candidat recevra une mentionÂ :

```python
for vote in votes:
    for candidate, mention in vote.items():
        candidates_results[candidate][mention] += 1
return candidates_results
```

Cela va gÃ©nÃ©rer un dictionnaire similaire Ã  celui-ciÂ :

```python
{
    'hermione': [0, 0, 0, 25333, 24796, 24871, 25000],
    'balou': [14404, 14311, 14305, 14250, 14195, 14231, 14304],
    'chuck-norris': [33320, 33436, 33244, 0, 0, 0, 0],
    'elsa': [0, 49969, 50031, 0, 0, 0, 0],
    'gandalf': [0, 0, 0, 25023, 25033, 25039, 24905],
    'beyonce': [0, 0, 19926, 20099, 19835, 20214, 19926]
}
```

Nous allons maintenant calculer la mention mÃ©dianeâ€‰!

### Calculer la mention mÃ©diane de chaque candidat

Commencez par regarder cette vidÃ©oÂ :

<YouTube youTubeId="uIx2xvdwIIo" />

<br />

Nous atteignons la mÃ©diane lorsque 50% des votes pour un candidat sont reprÃ©sentÃ©s. Prenons un exemple.

ConsidÃ©rons les rÃ©sultats dâ€™HermioneÂ : [0, 0, 0, 25333, 24796, 24871, 25000]

Nous allons calculer les rÃ©sultats cumulÃ©s afin dâ€™atteindre 50Â 000 votes (100Â 000 / 2).
- Mention 0Â : 0 + 0 = 0 => atteint-on 50Â 000â€‰? Non. Alors on continue avec la mention suivante.
- Mention 1Â : 0 + 0 = 0 => atteint-on 50Â 000â€‰? Non. Alors on continue avec la mention suivante.
- Mention 2Â : 0 + 0 = 0 => atteint-on 50Â 000â€‰? Non. Alors on continue avec la mention suivante.
- Mention 3Â : 0 + 25333 = 25333 => atteint-on 50Â 000â€‰? Non. Alors on continue avec la mention suivante.
- Mention 4Â : 25333 + 24796 = 50129 => atteint-on 50Â 000â€‰? Ouiâ€‰! La boucle sâ€™arrÃªte.

La mention mÃ©diane dâ€™Hermione sera "Passable", car au moins 50Â % des votants lui ont accordÃ© cette mention ou une supÃ©rieure.

CommenÃ§ons par coder cette premiÃ¨re boucleÂ :

```pyrhon
def majoritary_mentions_hash(candidates_results):
    cumulated_votes = 0
    for mention, vote_count in enumerate(candidates_results["hermione"]):
        cumulated_votes += vote_count
        if MEDIAN < cumulated_votes:
                # add a key in a dictionary
            break
    print(cumulated_votes)
```

Et ajoutons son exÃ©cution dans la fonction `main()`.

```python
def main():
    votes = create_votes()
    results = results_hash(votes)
    majoritary_mentions = majoritary_mentions_hash(results)
```

RÃ©sultatÂ :

```sh
50129
```

Ajoutons maintenant un dictionnaire dans lequel nous garderons la mention et les votes cumulÃ©s, sous cette formeÂ :

```python
{'hermione': {'mention': 4, 'score': 50129}}
```

```python
def majoritary_mentions_hash(candidates_results):
    r = {}
    cumulated_votes = 0
    for mention, vote_count in enumerate(candidates_results["hermione"]):
        cumulated_votes += vote_count
        if MEDIAN < cumulated_votes:
            r["hermione"] = {
                "mention": mention,
                "score": cumulated_votes
            }
            break
    print(r)
```

Ajoutons dÃ©sormais une boucle pour rÃ©aliser cette opÃ©ration pour tous nos candidatsÂ :

```python
def majoritary_mentions_hash(candidates_results):
    r = {}
    for candidate, candidate_result in candidates_results.items():
        cumulated_votes = 0
        for mention, vote_count in enumerate(candidate_result):
            cumulated_votes += vote_count
            if MEDIAN < cumulated_votes:
                r[candidate] = {
                    "mention": mention,
                    "score": cumulated_votes
                }
                break
    print(r)
```

RÃ©sultatÂ :

```sh
{
    'hermione': {'mention': 4, 'score': 50129},
    'balou': {'mention': 3, 'score': 57270},
    'chuck-norris': {'mention': 1, 'score': 66756},
    'elsa': {'mention': 2, 'score': 100000},
    'gandalf': {'mention': 4, 'score': 50056},
    'beyonce': {'mention': 4, 'score': 59860}
}
```

Enfin, remplaÃ§ons notreÂ `print`Â final (uniquement utilisÃ© Ã  des fins de dÃ©bug) par un returnÂ :

```python
def majoritary_mentions_hash(candidates_results):
    r = {}
    for candidate, candidate_result in candidates_results.items():
        cumulated_votes = 0
        for mention, vote_count in enumerate(candidate_result):
            cumulated_votes += vote_count
            if MEDIAN < cumulated_votes:
                r[candidate] = {
                    "mention": mention,
                    "score": cumulated_votes
                }
                break
    return r
```

### Trier les candidats par mention

Bien. Maintenant que nous savons comment trouver la mention mÃ©diane dâ€™un candidat, je vous propose de les trier par mentionâ€‰! Celui
ayant la meilleure mention devra arriver en haut de la liste et celui ayant la mention la plus basse (Ã€ rejeter) en bas.

Cela tombe bien, nous avons justement dÃ©jÃ  vu un algorithme de triÂ : le tri par bullesâ€‰!

:::info
La librairie standard de Python inclut des mÃ©thodes de tri, mais lâ€™objectif de ce cours Ã©tant de mieux comprendre les algorithmes,
autant les essayerâ€‰!
:::

Notre fonction prend en paramÃ¨tre un dictionnaire. Or, le tri par bulles nâ€™est possible que sur un tableau, car vous avez besoin des
index pour rÃ©ordonner les items. La premiÃ¨re Ã©tape va donc Ãªtre de recrÃ©er un tableau comprenant les informations suivantesÂ : le nom
du candidat (cela nous sera utile, plus tard, pour retrouver ses rÃ©sultats) et sa mention.

```python
def sort_candidates_by(mention):
    unsorted = [(key, (mention["mention"], mention["score"])) for key, mention in mentions.items()]
```

Ã€ prÃ©sent, nous allons utiliser la forme du tri Ã  bulles que nous avons vue prÃ©cÃ©demment. Attention, dÃ©tail importantÂ : vous comparez
les valeurs des _mentions_ et non de lâ€™Ã©lÃ©ment en lui-mÃªmeâ€‰!

```python
def sort_candidates_by(mentions):
    ## bubble sort here we go!
    unsorted = [(key, (mention["mention"], mention["score"])) for key, mention in mentions.items()]
    swapped = True
    while swapped:
        swapped = False
        for j in range(0, len(unsorted) - 1):
        ## but we need REVERSE bubble sort ;-)
        # (note that here we compare tuples, which is pretty neat)
        if unsorted[j + 1][1] < unsorted[j][1]:
            unsorted[j+1], unsorted[j] = unsorted[j], unsorted[j+1]
            swapped = True
```

Et ajoutons un bout de code dans la fonction `main()`Â pour lâ€™exÃ©cuterÂ :

```python
def main():
    votes = create_votes()
    results = results_hash(votes)
    majoritary_mentions = majoritary_mentions_hash(results)
    sorted_candidates = sort_candidates_by(majoritary_mentions)
```

Cela fonctionne, sauf que la mention la plus haute se trouve ainsi Ã  la fin de la liste, or nous voulions quâ€™elle apparaisse au dÃ©butâ€‰!
Changeons la comparaison en ligneÂ 3 : nous dirons que, si lâ€™Ã©lÃ©ment suivant est plus grand, il doit Ãªtre intervertiâ€‰!

```python
def sort_candidates_by(mentions):
    unsorted = [(key, (mention["mention"], mention["score"])) for key, mention in mentions.items()]
    swapped = True
    while swapped:
        swapped = False
        for j in range(0, len(unsorted) - 1):
            if unsorted[j + 1][1] > unsorted[j][1]:
                unsorted[j+1], unsorted[j] = unsorted[j], unsorted[j+1]
                swapped = True
    print(unsorted)
```

Voici le rÃ©sultat :

```sh
[
    ('hermione', (0, 50044)),
    ('beyonce', (1, 66748)),
    ('balou', (3, 66575)),
    ('elsa', (4, 100000)),
    ('chuck-norris', (5, 66648)),
    ('gandalf', (6, 100000))
]
```

Nos candidats sont bien classÃ©sâ€‰!

Ajoutons un petit peu de code pour renvoyer un tableau tout joli tout beauÂ :

```python
def sort_candidates_by(mentions):
    ## bubble sort here we go!
    unsorted = [(key, (mention["mention"], mention["score"])) for key, mention in mentions.items()]
    swapped = True
    while swapped:
        swapped = False
        for j in range(0, len(unsorted) - 1):
            ## but we need REVERSE bubble sort ;-)
            # (note that here we compare tuples, which is pretty neat)
            if unsorted[j + 1][1] > unsorted[j][1]:
                unsorted[j+1], unsorted[j] = unsorted[j], unsorted[j+1]
                swapped = True
    print(unsorted)

    return [
        {
            "name": candidate[0],
            "mention": candidate[1][0],
            "score": candidate[1][1],
        }
        for candidate in unsorted
    ]
```

### Afficher les rÃ©sultats dans la console

CrÃ©ons une nouvelle fonction qui tranformera nos rÃ©sultats en plusieurs chaÃ®nes de caractÃ¨res agrÃ©ables Ã  lire.

Utilisons le dictionnaire `CANDIDATES`Â afin de retrouver le nom du candidat grÃ¢ce Ã  sa clÃ©. Quant Ã  chaque mention, il est assez
simple dâ€™afficher son nom "humain" grÃ¢ce Ã  son index.

```python
def print_results(results):
    for i, result in enumerate(results):
        name = CANDIDATES[result["name"]]
        mention = MENTIONS[result["mention"]]
        score = result["score"] * 100. / VOTES
        print("- {} avec {:.2f}% de mentions {}".format(
            name, score, mention
        ))
```

Puisque je souhaite mettre Ã  lâ€™honneur notre vainqueur, jâ€™ajoute une structure conditionnelle pour crÃ©er une chaÃ®ne de caractÃ¨res
diffÃ©renteÂ :

```python
def print_results(results):
    for i, result in enumerate(results):
        name = CANDIDATES[result["name"]]
        mention = MENTIONS[result["mention"]]
        score = result["score"] * 100. / VOTES
            if i == 0:
                print("Gagnant: {} avec {:.2f}% de mentions {}".format(
                    name, score, mention
                ))
                continue
            else:
                print("- {} avec {:.2f}% de mentions {}".format(
                    name, score, mention
                ))
```

Enfin, mettons Ã  jour notre fonction `main` pour quâ€™elle exÃ©cute cette derniÃ¨re fonctionÂ :

```python
def main():
    votes = create_votes()
    results = results_hash(votes)
    majoritary_mentions = majoritary_mentions_hash(results)
    sorted_candidates = sort_candidates_by(majoritary_mentions)
    print_results(sorted_candidates)
```

:::note ?
Alors, qui gagne lâ€™Ã©lectionâ€‰?
:::

Bonne questionâ€‰! Chez moi, câ€™est Hermione (youpiâ€‰!), mais chez vous, le rÃ©sultat est certainement diffÃ©rentâ€‰!

![](https://user.oc-static.com/upload/2017/06/15/14975342038124_Capture%20d%E2%80%99e%CC%81cran%202017-06-15%20a%CC%80%2015.44.29.png)

:::info
Retrouvez le code de ce chapitre dans son intÃ©gralitÃ© dans ce dÃ©pÃ´t GithubÂ : [algorithme de jugement majoritaire](https://github.com/celine-m-s/majoritary-judgment/blob/master/program.py).
:::

-----

## Plongez dans le monde des algorithmes

[Plongez dans le monde des algorithmes - DÃ©couvrez le fonctionnement des algorithmes - OpenClassrooms](https://openclassrooms.com/fr/courses/4366701-decouvrez-le-fonctionnement-des-algorithmes/4385496-plongez-dans-le-monde-des-algorithmes)

<Vimeo vimeoId="213636724" />

<br />

BRAVOâ€‰! Vous Ãªtes parvenuÂ·e Ã  la fin de ce cours et vous pouvez Ãªtre fiÃ¨rÂ·e de vousâ€‰!

NÃ©anmoins, votre apprentissage ne sâ€™arrÃªte pas lÃ . Regardez impÃ©rativement cette confÃ©rence dâ€™exception du CollÃ¨ge de France et mise
Ã  disposition gratuitementÂ : [Lâ€™informatique du temps et des Ã©vÃ©nements, GÃ©rard Berry](http://www.college-de-france.fr/site/gerard-berry/inaugural-lecture-2013-03-28-18h00.htm).
Vous pourrez par la suite, si vous le souhaitez, suivre lâ€™intÃ©gralitÃ© du cours sur les algorithmes.

### MathÃ©matiques

Pour aller plus loin, il est important de se remettre un peu aux mathsâ€‰! Logarithmes, factorielles, fonctions _a minima_. Vous pouvez
faire ou refaire le programme de premiÃ¨reÂ et de terminale scientifique. Je vous conseille les excellents cours de Kartable et notamment
celui sur [la fonction exponentielle](https://www.kartable.fr/terminale-s/mathematiques/specifique/chapitres-180/la-fonction-exponentielle-10/cours/la-fonction-exponentielle/4325).
- [Programme de premiÃ¨re S](https://www.kartable.fr/premiere-s/mathematiques/specifique/chapitres-177)
- [Programme de terminale S](https://www.kartable.fr/terminale-s/mathematiques/specifique/chapitres-180)

La Khan Academy contient Ã©galement de nombreux [cours sur les mathÃ©matiques](https://fr.khanacademy.org/math)Â et FUN a sorti un cours
intitulÃ© [Socle en MathÃ©matiques](https://www.fun-mooc.fr/courses/itii/119002/session01/about). Choisissez simplement celuiÂ dont la
pÃ©dagogie vous attire le plusâ€‰!

### Algorithmique

[Cours en algorithmique de lâ€™ENS Lyon par Yves Robert](http://graal.ens-lyon.fr/~yrobert/algo/poly-algo.ps)

Cours dÃ©livrÃ© chez TÃ©lÃ©com Bretagne par Vincent Gripon et Bastien Pasdeloup :Â [Coder une intelligence artificielle - Pyrat](http://formations.telecom-bretagne.eu/pyrat/?page_id=37)

Livre :Â [Initiation Ã  lâ€™algorithmique et Ã  la programmation en C](http://www.dunod.com/informatique-multimedia/developpement/cc/ouvrages-denseignement/initiation-lalgorithmique-et-la-programmation-en-c)

### Sâ€™entraÃ®ner

Lâ€™algorithmique Ã©tant avant tout la recherche de la solution la plus efficace Ã  un problÃ¨me donnÃ©, il est bon de sâ€™entraÃ®ner Ã 
rÃ©soudre des challenges rÃ©guliÃ¨rement. Je vous recommande pour cela les plateformes suivantesÂ :
- [Coding Games](https://www.codingame.com/)Â ğŸ‡¬ğŸ‡§ : apprenez Ã  rÃ©soudre des algorithmes en jouant.
- [France IoI](http://www.france-ioi.org/)Â : site dâ€™entraÃ®nement Ã  la programmation.
- [HackerRank](https://www.hackerrank.com/)Â ğŸ‡¬ğŸ‡§ : progressez en rÃ©solvant des challenges et en lisant les solutions.
- Livre [Cracking the coding interview](http://www.crackingthecodinginterview.com/)Â ğŸ‡¬ğŸ‡§
- [Exemple dâ€™un entretien chez Google](https://www.youtube.com/watch?v=XKu_SEDAykw)Â ğŸ‡¬ğŸ‡§

-----

## Quiz : Vers l'infini et au-delÃ  !

[Vers l'infini et au-delÃ  ! - OpenClassrooms](https://openclassrooms.com/fr/courses/4366701-decouvrez-le-fonctionnement-des-algorithmes/exercises/1621)

#### CompÃ©tences Ã©valuÃ©es

<i class="bi bi-check2-circle"></i> CrÃ©er des fonctions rÃ©cursives<br />

<i class="bi bi-check2-circle"></i> Calculer la complexitÃ© d'un algorithme

-----

#### Question 1 : Le tri Ã  bulles est un algorithme qui compare les donnÃ©es par paires et les intervertit au besoin.

<i class="bi bi-record-circle"></i> Vrai<br />
<i class="bi bi-circle"></i> Faux<br />
<br />

-----

#### Question 2 : Le tri Ã  bulles est un des algorithmes les plus efficaces qui soit, notammentÂ dans le cas d'une masse importante de donnÃ©es.

<i class="bi bi-circle"></i> Vrai<br />
<i class="bi bi-record-circle"></i> Faux<br />
<br />

-----

#### Question 3 : La complexitÃ© algorithmique est un outil qui sert Ã  :

<i class="bi bi-circle"></i> dÃ©terminer si un algorithme est compliquÃ© Ã  comprendre.<br />
<i class="bi bi-record-circle"></i> comparer les algorithmes entre eux pour dÃ©terminer celui qui est le plus efficace.<br />
<br />

-----

#### Question 4 : La complexitÃ© algorithmique se reprÃ©sente grÃ¢ce Ã  la notation de Landau (_O(n)_).

<i class="bi bi-record-circle"></i> Vrai<br />
<i class="bi bi-circle"></i> Faux<br />
<br />

-----

#### Question 5 : La complexitÃ© en temps est :

<i class="bi bi-record-circle"></i> un ordre de grandeur qui sert Ã  estimer le temps nÃ©cessaire au fonctionnement d'un algorithme.<br />
<i class="bi bi-circle"></i> le calculÂ du tempsÂ nÃ©cessaire au fonctionnement d'un algorithme. Elle s'exprime en secondes et est extrÃªmement prÃ©cise.<br />
<br />

-----

#### Question 6 : La complexitÃ© en mÃ©moire est :

<i class="bi bi-circle"></i> le calcul deÂ la mÃ©moire nÃ©cessaire au fonctionnement d'un algorithme. Elle est trÃ¨s prÃ©cise et s'exprime en octets.<br />
<i class="bi bi-record-circle"></i> unÂ ordre de grandeur de la mÃ©moire nÃ©cessaire au fonctionnement d'un algorithme.<br />
<br />

-----

#### Question 7 : Une fonction qui s'appelle elle-mÃªme est :

<i class="bi bi-circle"></i> une fonction schizophrÃ¨ne<br />
<i class="bi bi-record-circle"></i> une fonction rÃ©cursive<br />
<i class="bi bi-circle"></i> une fonction inutile<br />
<br />

-----

#### Question 8 : Trouvez la fonction rÃ©cursive :

<i class="bi bi-circle"></i>

```python
def fibo(n):
    a,b = 0,1
    for i in range(1, n+1):
        c = a + b
        print(b)
        a = b
        b = c
```

<i class="bi bi-record-circle"></i>

```python
def fibo(n):
    if n <= 1:
        return 1
    else:
        return fibo(n-1) + fibo(n-2)
```

-----

#### Question 9 : Utiliser une fonction rÃ©cursiveÂ ne pose aucune problÃ©matique en termes de mÃ©moire.

<i class="bi bi-circle"></i> Vrai<br />
<i class="bi bi-record-circle"></i> Faux<br />
<br />

-----

#### Question 10 : Un algorithme naÃ¯f est :

<i class="bi bi-circle"></i> un algorithme un peu simplet.<br />
<i class="bi bi-record-circle"></i> le premier algorithme qui vient Ã  l'esprit quand nous cherchons une solution Ã  un problÃ¨me.<br />
<i class="bi bi-circle"></i> un algorithme trÃ¨s poussÃ©Â qui est le fruit de plusieurs annÃ©es de recherchesÂ Ã  la NASA.<br />

