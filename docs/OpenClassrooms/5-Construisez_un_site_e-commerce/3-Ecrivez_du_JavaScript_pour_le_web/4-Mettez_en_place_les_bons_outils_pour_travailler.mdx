---
id: 4-Mettez_en_place_les_bons_outils_pour_travailler
title: Mettez en place les bons outils pour travailler
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo, CodePen } from 'mdx-embed';

# Mettez en place les bons outils pour travailler

## Optimisez votre code

[Optimisez votre code - Ã‰crivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5577726-optimisez-votre-code)

<Vimeo vimeoId="539128194" />

<br />

Maintenant que vous savez dÃ©velopper une application web, nous allons voir comment l'**optimiser** !

### Linter, minifier, bundler, transpiler

:::note ?
_Qu'est-ce que c'est que ces mots barbares ?!_ ğŸ¤”
:::

Ces mots "barbares" venus de l'anglais nous seront en fait trÃ¨s utiles ! Voyons ensemble ce que reprÃ©sente chacun d'entre eux.

#### Linter

LeÂ _linter_ est un programme qui va **analyser** notre code et **dÃ©tecter** les erreurs de syntaxe, les variables non utilisÃ©es, les variables
qui n'existent pas, la mauvaise organisation du code, le non-respect des bonnes pratiques d'Ã©criture de code...

Le JavaScript Ã©tant un langage **non compilÃ©**, vous ne verrez les erreurs de syntaxe de votre code que lors de l'exÃ©cution du code concernÃ©.
C'est-Ã -dire que si une de vos fonctions utilise une variable qui n'est pas dÃ©finie, vous ne le saurez que lorsque votre fonction sera exÃ©cutÃ©e.
Autant dire que pour certaines fonctions peu utilisÃ©es, vous pouvez trÃ¨s facilement laisser des erreurs "d'inattention" passer en production. ğŸ˜«

UnÂ linter pourra donc vous aider Ã  **rÃ©gler cesÂ erreurs** avant que vos utilisateurs n'en subissent les consÃ©quences (les tests sont aussi un
trÃ¨s bon moyen complÃ©mentaire au linter pour Ã©viter les erreurs, mais ce n'est pas l'objet de ce cours). Il pourra aussi vous aider Ã 
**optimiser** un peu votre code et vous sera d'une grande aide pour dÃ©finir des **bonnes pratiques d'Ã©criture** de code lorsque vous
travaillerez en Ã©quipe !

> Voici quelques exemples de linters : [JSLint](https://www.jslint.com/), [ESLint](https://eslint.org/).

#### Minifier

Rappelez-vous, votre code JavaScript est **chargÃ©** par votre navigateur. Cela signifie que votre navigateur va demander Ã  votre serveur votre
code JavaScript afin de l'exÃ©cuter. Il est alors Ã©vident que moins votre code sera lourd (en termes de taille de fichier), plus votre navigateur
pourra le rÃ©cupÃ©rer et le charger rapidement.

UnÂ _minifier_ est donc un programme responsable de laÂ _minification_ de votre code. C'est-Ã -dire qu'il va essayer de rendre votre **code le
plus lÃ©ger possible** en retirant les espaces et retours Ã  la ligne inutiles, en renommant vos variables avec des noms plus courts, en
supprimant le code non utilisÃ©, en supprimant les commentaires, en optimisant certains bouts de code pour les rÃ©Ã©crire avec une syntaxe plus
lÃ©gÃ¨re, etc.

:::info
MalgrÃ© les bonnes connexions Internet qui se dÃ©veloppent de plus en plus, la minification du code n'est pas quelque chose Ã  nÃ©gliger, car si
vous avez un site web avec beaucoup de trafic, c'est autant de requÃªtes qui sont faites pour rÃ©cupÃ©rer votre code. Chaque octet compte afin
d'allÃ©ger la charge des serveurs et de donner Ã  vos utilisateurs une rÃ©ponse la plus rapide possible !
:::

> Voici quelques exemples de minifiersÂ : [node-minify](https://github.com/srod/node-minify), [UglifyJS](https://github.com/mishoo/UglifyJS2#readme).

#### Bundler

De la mÃªme maniÃ¨re qu'il est important d'avoir un code le plus lÃ©ger possible, il est aussi important de **rÃ©duire au maximum le nombre de
fichiers** qui composent votre code !

C'est donc le rÃ´le du _bundler_. Il va se charger de **_packager_** votre code pour qu'il tienne dans un seul fichier. Ainsi, vous continuez Ã 
coder dans plusieurs fichiers pour plus de clartÃ© dans votre code, mais le navigateur nâ€™aura besoin de charger dâ€™un seul fichier lorsquâ€™un
visiteur ira sur votre site.

> VoiciÂ un exemple de bundler : [Webpack](https://webpack.js.org/).

#### Transpiler

Vous devez vous en douter, le langage JavaScript **Ã©volue**. Ã€ l'heure actuelle, nous en sommes Ã  la version _ECMAScript 2018Â _ (ES9), mais
dÃ©jÃ  la versionÂ _ECMAScript 2015_ (ES6) n'estÂ plusÂ supportÃ©e dans son intÃ©gralitÃ© tous les navigateurs. Et c'est bien dommage, car les
nouvelles versions peuvent offrir des choses intÃ©ressantes (`async`Â / `await` par exemple).

:::info
Depuis la publication de cette mise Ã  jour, JavaScript a sorti la versionÂ _ECMAScript 2021 (ES12)._ Ã€ priori la version _ECMAScript 2018 (ES9)_
reste supportÃ©e par la plupart des navigateurs.
:::

Mais alors comment coder avec la derniÃ¨re version de JavaScript tout en Ã©tant **compatible** avec tous les navigateurs ? Avec unÂ _transpiler_ !

> Voici un exemple de transpiler : [Babel](https://babeljs.io/).

### En rÃ©sumÃ©

Dans ce chapitre, vous avez appris :
- Qu'unÂ linter va vous permettre de trouver des erreurs dans votre code et de mettre en place des conventions de code ;
- Qu'un minifier va vous permettre de rÃ©duire la taille de votre code pour que les navigateurs le chargent plus vite ;
- Qu'un bundler va regrouper tous vos fichiers en un seul afin que le navigateur soit plus rapide Ã  charger votre code ;
- Qu'un transpiler va vous permettre dâ€™utiliser les nouvelles fonctionnalitÃ©s du langage JavaScript tout en restant compatible avec tous les
navigateurs.

_Vous savez maintenant quels outils nous allons avoir besoin. Il est temps de voir comment les ajouter Ã  votre projet._

-----

[GÃ©rez vos dÃ©pendances - Ã‰crivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5577746-gerez-vos-dependances)

## GÃ©rez vos dÃ©pendances

<Vimeo vimeoId="539128226" />

<br />

:::note ?
C'est bien beau d'avoir tous ces outils disponibles pour optimiser son dÃ©veloppement, mais comment en profiter ?
:::

Avec NPM !

### DÃ©couvrez NPM

:::info
NPM est un **gestionnaire de paquets** (_package manager_ en anglais). C'est un programme qui vous permet d'installer trÃ¨s facilement des
_modules_ pour le JavaScript, et cela comprend les outils dont nous avons parlÃ© dans les chapitres prÃ©cÃ©dents.
:::

:::note ?
Qu'est-ce qu'un module ?
:::

Un _module_ est un bout de code Ã©crit par quelqu'un (peut-Ãªtre bientÃ´t par vous !) et qui rÃ©sout une problÃ©matique commune Ã  beaucoup de
dÃ©veloppeurs : comme un parser XML, un gÃ©nÃ©rateur d'_uuid_ (des identifiants uniques), un router, un framework de rendu _HTML_, etc.

Afin qu'ils puissent Ãªtre utilisÃ©s par tout le monde, ces modules sont publiÃ©s dans un gestionnaire de paquets, en l'occurrence ici, NPM.
Voyons comment cela fonctionne...

#### Installez NPM

NPM est compris dans _Node.js_, qui est un programme permettant d'Ã©crire des applications en JavaScript. Il suffit donc de se rendre sur
[la page de tÃ©lÃ©chargement de Node.js](https://nodejs.org/en/) et d'installer Node.js afin de profiter de NPM.

:::info
Installez Node.js et voyons comment exÃ©cuter des commandes de NPM depuis votre terminal !
:::

### Initialisez votre projet

NPM nÃ©cessite un fichier nommÃ© `package.json`Â afin d'avoir des informations sur votre projet : son nom, sa version, lesÂ modules Ã  installer,
etc.

Vous pouvez le crÃ©er manuellement ou bien utiliser la commande suivante pour le crÃ©er plus facilement :

```shell
npm init
```

### Installez unÂ module

Pour installer un nouveauÂ module c'est trÃ¨s simple, il suffit de faire :

```shell
npm install <module_name> --save-dev
```

`--save-dev`Â signifie que l'on souhaite que NPM sauvegarde cette dÃ©pendance dans le fichier `package.json`Â en tant que dÃ©pendance de
dÃ©veloppement. Il existe aussi `--save`Â qui ajoute la dÃ©pendance en tant que dÃ©pendance de production.

Lorsque vous clonez votre projet pour la premiÃ¨re fois depuis un repository git, vous pourrez exÃ©cuter :

```shell
npm install
```

Cette commande va installer toutes les dÃ©pendances de votre projet qui ont Ã©tÃ© ajoutÃ©es dans le fichier `package.json`. Ce fichier est trÃ¨s
utile pour mÃ©moriser et installer tous lesÂ modules dont dÃ©pend votre projet !

### En rÃ©sumÃ©

Dans ce chapitre, vous avez appris :
- Quâ€™un module vous permet de sÃ©parer votre code dans dâ€™autres fichiers afin de pouvoir le rÃ©utiliser plus facilement ;
- Que vous allez pouvoir intÃ©grer des dÃ©pendances Ã  votre projet avec NPM ;
- Comment installer NPM ;
- Comment installer des dÃ©pendances avec NPM.

_Maintenant que vous comprenez mieux comment on peut gÃ©rer nos dÃ©pendances, passons Ã  la pratique pour optimiser notre code !_

-----

## Compilez et exÃ©cutez votre code

[Compilez et exÃ©cutez votre code - Ã‰crivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5577766-compilez-et-executez-votre-code)

<Vimeo vimeoId="539128249" />

<br />

Comme nous l'avons vu plus tÃ´t,Â _Webpack_ est unÂ **bundler**, il va vous permettre de compiler votre code et de tout packager en un seul fichier,
mais Ã§a ne s'arrÃªte pas lÃ  !

Webpack peut aussi **gÃ©rer vos ressources** (images, styles css, etc.) avec ce qu'on appelle desÂ _loaders,_ et il va vous permettre de gÃ©rer
diffÃ©rentes phases que nous avons vues lors de l'optimisation :Â bundler, minifier et transpiler.

### PrÃ©paration du terrain

Une fois que vous avez exÃ©cutÃ© `npm init` dans votre rÃ©pertoire pour initialiser votre projet avec NPM, nous pouvons mettre en place les outils.

#### Installation de Webpack

Pour installer Webpack, il suffit d'exÃ©cuter cette commande :

```shell
npm install webpack webpack-cli --save-dev
```

#### Projet de base

Pour ce chapitre, nous allons partir sur une base de code trÃ¨s simple. Voici les fichiersÂ dont nous allons avoir besoin :

```shell
project
|- package.json
|- index.html
|- src
    |- index.js
    |- query.js
```

Voici le contenu des diffÃ©rents fichiers :

**package.json**

```json
{
    "name": "my-project",
    "version": "1.0.0",
    "description": "",
    "private": true,
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "",
    "license": "ISC",
    "devDependencies": {
        "webpack": "^4.21.0",
        "webpack-cli": "^3.1.2"
    },
        "dependencies": {
    }
}
```

**index.html**

```html
<!doctype html>
<html>
<head>
    <title>My project</title>
</head>
<body>
    <script src="./dist/app.bundle.js"></script>
</body>
</html>
```

**src/index.js**

```javascript
import retrieveContent from './query.js';

async function showContent() {
    try {
        const content = await retrieveContent();

        let elt = document.createElement('div');
        elt.innerHTML = content.join('<br />');

        document.getElementsByTagName('body')[0].appendChild(elt);
    } catch (e) {
        console.log('Error', e);
    }
}

showContent();
```

**src/query.js**

```javascript
export default async function retrieveContent() {
    const url = "https://baconipsum.com/api/?type=all-meat&paras=2&start-with-lorem=1";

    const response = await fetch(url);
    return response.json();
}
```

:::info
Vous noterez quâ€™on a, ici, utilisÃ© _`fetch()`_ avec _`await`_, car comme on lâ€™a vu, lorsquâ€™il y a des _Promise_ on peut utiliser _`async`Â /
`await`_ ![;)](https://openclassrooms.com/bundles/common/images/smiley/clin.png)
:::

### Compilation duÂ projet avec Webpack

Maintenant que nous avons une base de code, voyons commentÂ compiler notre projet.

Nous allons crÃ©er un fichier `webpack.config.js`Â Ã  la **racine** du projet. C'est le fichier qui servira de configuration Ã  Webpack pour savoir
comment il doit compiler notre projet.

**webpack.config.js**

```javascript
const path = require('path');

module.exports = {
    mode: "production",
    entry: {
        app: "./src/index.js"
    },
    output: {
        filename: "[name].bundle.js",
        path: path.resolve(__dirname, "dist")
    }
};
```

Ce fichier nous indique principalement que Webpack va se servir de notreÂ `./src/index.js`Â comme **point d'entrÃ©e** de notre application et
bundler notre code dans un fichier final : `./dist/app.bundle.js`Â (`[name]`Â Ã©tant une **variable** qui sera remplacÃ©e ici par `app`, car c'est
le nom que l'on a indiquÃ© pour notre fichier `index.js`).

Avec notre fichier de configuration prÃªt, il ne nous reste plus qu'Ã  **exÃ©cuter** Webpack. Pour cela, nous allons utiliser une des
fonctionnalitÃ©s de NPM : les commandes.

Nous allons modifier le fichier `package.json`Â pour ajouter dans les `"scripts": {....}`Â la ligne suivante :

```json
"scripts": {
    "test": "...",
    "build": "webpack"
}
```

Tout ce qui se trouve dans `scripts`Â peut Ãªtre exÃ©cutÃ© avec la commande `npm run <script_name>`. Ainsi, nous pouvons exÃ©cuter `npm run build`
quiÂ va exÃ©cuter la commande `webpack`.

Pourquoi ne pas exÃ©cuter directement la commande `webpack`, me direz-vous ? Eh bien, parce qu'en rÃ©alitÃ© cette application se trouve dans le
dossier `./node_modules/.bin/webpack`. Or, l'avantage de NPM est qu'il va **automatiquement** chercher dans ce dossier pour exÃ©cuter des
commandes, ainsi on s'Ã©pargne le chemin entier (oui, le dÃ©veloppeur est bien unÂ fainÃ©antÂ ğŸ˜Š).

Nous pouvons donc compiler un projet avec :

```shell
npm run build
```

Si tout se passe bien, un fichier `app.bundle.js` devrait Ãªtre gÃ©nÃ©rÃ© dans le dossier `dist/`. Notre projet a bien Ã©tÃ© packagÃ© en **un seul
fichier**, alors que nous en avions 2 Ã  l'origine (`index.js`Â et `query.js`). Alors, par quelle magie est-ce que Webpack a su oÃ¹ aller chercher
tous nos fichiers Ã  partir de notre fichier `index.js`Â ?

GrÃ¢ce aux `import`Â et `export`. Ces 2 mots clÃ©s permettent respectivement d'importer un autre fichier (qui est appelÃ© un _module_) et d'exporter
des choses (fonctions, variables...).

Nous pouvons, en effet, voir que dans notre fichier `index.js`, nous avons importÃ© le module `query.js`Â sous le nomÂ `retrieveContent`. Et dans
notre fichier `query.js`, nous pouvons voir que nous avonsÂ exportÃ© la fonction `retrieveContent`Â (ce qui la rend disponible Ã  l'import). Ainsi,
quand Webpack analyse votre code, il retrouve toutes ces dÃ©pendances et se crÃ©e un graph en interne afin d'Ãªtre capable de tout remettre dans
l'ordre dans un seul fichier.

Mais ce n'est pas encore suffisant. En effet,Â nous utilisons `async`Â et `await`Â qui sont apparus dans une version rÃ©cente de JavaScript que
tous les navigateursÂ ne supportent pas encore. Ainsi, en fonction du navigateur, le code affichera une erreur. De quoi avons-nous besoin alors ?
D'un transpiler afin de rendre notre code JavaScript compatible avec les navigateurs les moins rÃ©cents !

### Transpiler avec Babel

Afin d'utiliser Babel, nous allons devoir l'installer. Mais nous aurons aussi besoin d'installer leÂ **loader** Babel qui permet de l'intÃ©grer Ã 
Webpack. Il est en effet possible d'Ã©tendre les capacitÃ©s de Webpack avec des [plugins](https://webpack.js.org/plugins/) et des [loaders](https://webpack.js.org/loaders/#transpiling).

```shell
npm install --save-dev babel-loader @babel/core @babel/preset-env babel-polyfill
```

Il va falloirÂ ajouter Babel Ã  la configuration de Webpack. Pour cela, il faut y ajouter ce qu'on appelle des `rules`. Les `rules`Â sont des
rÃ¨gles de Webpack indiquant les loaders Ã  utiliser pour les types de fichiers que l'on souhaite. Cela veut dire que dÃ¨s que l'on va importer un
module dans notre code, Webpack va regarder dans la liste des `rules`Â s'il y en a une qui correspond Ã  ce type de fichier, et il va lui
appliquer les loaders qui correspondent.

Dans notre cas, nous voulons exÃ©cuter Babel pour tous les fichiers JavaScript de notre projet (sauf ceux qui se trouvent dans le dossier
`node_modules`, car ce sont les dÃ©pendances NPM et nous ne sommes pas censÃ©s modifier leur code).

**webpack.config.js**

```javascript
const path = require('path');

module.exports = {
    mode: "production",
    entry: {
        polyfill: "babel-polyfill",
        app: "./src/index.js"
    },
    output: {
        filename: "[name].bundle.js",
        path: path.resolve(__dirname, "dist")
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: "babel-loader",
                    options: {
                        presets: ["@babel/preset-env"]
                    }
                }
            }
        ]
    }
};
```

Vous pouvez passer des options aux loaders. Ainsi, pour Babel, vous pourriez lui demander de charger d'autres plugins pour gÃ©rer des syntaxes
qui ne sont encore que des propositions pour de futures versions de JavaScript. Ici, nous chargeons le preset de base qui va nous permettre de
transpiler notre code.

Vous remarquerez aussi que nous avons ajoutÃ© une entrÃ©e dans l'objet `entry`Â : `polyfill: "babel-polyfill"`. Cela veut dire que lorsque nous
compilons notre code, deux fichiers vont Ãªtre gÃ©nÃ©rÃ©s : notre code depuis notre fichier `index.js`Â et le polyfill de Babel. Le polyfill permet
Ã  Babel d'apporter des modifications au code lors de son exÃ©cution. Cela peut Ãªtre nÃ©cessaire pour certaines choses, et c'est le cas de `async`
/ `await`. Afin de prendre en compte ce fichier de polyfill, il va falloir mettre Ã  jourÂ le fichier `index.html`Â afin de le charger aussi
(avant notre code) :

**index.html**

```html
<!doctype html>
<html>
    <head>
        <title>My project</title>
    </head>
    <body>
        <script src="./dist/polyfill.bundle.js"></script>
        <script src="./dist/app.bundle.js"></script>
    </body>
</html>
```

Avec Ã§a, tous les navigateurs devraient afficher la page et exÃ©cuter correctement le code gÃ©nÃ©rÃ© par `npm run build`.

:::info
Si un jour vous avez la curiositÃ© de regarder Ã  quoi ressemble un code gÃ©nÃ©rÃ© par Webpack, vous verrez que ce n'est pas trÃ¨s lisible. Voici par
exemple un tout petit Ã©chantillon de ce que Ã§a peut donner :
:::

:::note javascript
!function(e){var t=window.webpackHotUpdate;window.webpackHotUpdate=function(e,n){!function(e,t){if(!D[e]||!w[e])return;
for(var n in w[e]=!1,t)Object.prototype.hasOwnProperty.call(t,n)&&(h[n]=t[n]);0==--y&&0===g&&k()}(e,n),t&&t(e,n)};
var n,r=!0,o="a220c62656b2d8bce261",a={},i=[],u=[];function s(e){var t=O[e];if(!t)return _;var r=function(r)
{return t.hot.active?(O[r]?-1===O[r].parents.indexOf(e)&&O[r].parents.push(e):(i=[e],n=r),-1===t.children.indexOf(r)&&t
.children.push(r)):(console.warn("[HMR] unexpected require("+r+") from disposed module "+e),i=[]),_(r)},o=function(e)
{return{configurable:!0,enumerable:!0,get:function(){return _[e]},set:function(t){_[e]=t}}};
for(var a in _)Object.prototype.hasOwnProperty.call(_,a)&&"e"!==a&&"t"!==a&&Object.defineProperty(r,a,o(a));
return r.e=function(e){return"ready"===f&&d("prepare"),g++,_.e(e).then(t,(function(e){throw t(),e}));
function t(){g--,"prepare"===f&&(b[e]||x(e),0===g&&0===y&&k())}},r.t=function(e,t){return 1&t&&(e=r(e)),_.t(e,-2&t)},r}
function c(t){var r={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,
_selfInvalidated:!1,_disposeHandlers:[],_main:n!==t,active:!0,accept:function(e,t){if(void 0===e)r._selfAccepted=!0;
else if("function"==typeof e)r._selfAccepted=e;else if("object"==typeof e)for(var n=0;n<e.length;n++)r.
_acceptedDependencies[e[n]]=t||function(){};else r._acceptedDependencies[e]=t||function(){}},decline:function(e){
if(void 0===e)r._selfDeclined=!0;else if("object"==typeof e)for(var t=0;t<e.length;t++)r._declinedDependencies[e[t]]=!0;
else r._declinedDependencies[e]=!0},dispose:function(e){r._disposeHandlers.push(e)},addDisposeHandler:
function(e){r._disposeHandlers.push(e)},removeDisposeHandler:function(e){var t=r._disposeHandlers.indexOf(e);
t>=0&&r._disposeHandlers.splice(t,1)},invalidate:function(){switch(this._selfInvalidated=!0,f){
case"idle":(h={})[t]=e[t],d("ready");break;case"ready":T(t);break;
:::

:::info
Pas terrible nâ€™est-ce pas ? Eh bien c'est Ã  cause de la minification du code ! Webpack, dans sa version actuelle, compresse le code
automatiquement lorsque vous le paramÃ©trez avecÂ mode: 'production', ce qui est le cas ici !
:::

### Webpack serve

Nous avons maintenant un environnement optimisÃ© qui vous permet :
- De minifier votre code ;
- De packager votre code ;
- De sÃ©parer trÃ¨s facilement votre code en plusieurs fichiers afin de bien l'organiser ;
- D'utiliser trÃ¨s facilement des bibliothÃ¨ques dÃ©veloppÃ©es par la communautÃ© grÃ¢ce Ã  NPM ;
- De transpiler votre code pour pouvoir utiliser les versions next gen de JavaScript ;

Que demander de plus ?

Un serveur pour tester votre code et qui recharge automatiquement votre navigateur dÃ¨s que vous modifiez votre code ?

Alors allons-y ! C'est exactement ce queÂ _webpack serve_ permet de faire.Â ![:soleil:](https://openclassrooms.com/bundles/common/images/smiley/soleil.png)

Il faut toutÂ d'abord installer le module :

```shell
npm install webpack-serve --save-dev
```

Ensuite, je vous conseille d'ajouterÂ une nouvelle commande au fichierÂ `package.json`Â :

```json
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack",
    "start": "webpack serve"
}
```

`start`Â est une commande un peu spÃ©ciale car elle est exÃ©cutÃ©e avec un simple `npm start`Â (vous noterez l'absence de `run` aprÃ¨sÂ `npm`Â ).

Enfin, _webpack serve_Â va considÃ©rer que les fichiers gÃ©nÃ©rÃ©s par Webpack sont Ã  la racine du server, il nous faut donc mettre Ã  jour notre
fichier `index.html`Â :

**index.html**

```html
<!doctype html>
<html>
    <head>
        <title>My project</title>
    </head>
    <body>
        <script src="/polyfill.bundle.js"></script>
        <script src="/app.bundle.js"></script>
    </body>
</html>
```

Une fois que tout Ã§a est fait, il suffit deÂ lancer le serveur de dÃ©veloppement :

```shell
npm start
```

La commande indique que l'application est disponible Ã  l'adresse [http://localhost:8080/](http://localhost:8080/).Â Il suffira de vousÂ y rendre
pour voir votre application.

Tant que cette commande est active, toute modification duÂ code source activera Webpack qui recompilera le code automatiquement et rafraÃ®chira
le navigateur, montrant ainsi vos modifications.Â ![:)](https://openclassrooms.com/bundles/common/images/smiley/smile.png)

### En rÃ©sumÃ©

Dans ce chapitre, vous avez appris :
- Ã€Â installer Webpack ;
- Ã€Â configurer Webpack pour votre projet ;
- Ã€Â compiler votre projet ;
- Ã€Â installer Babel pour transpiler votre code ;
- Ã€Â utiliser `webpack serve`Â pour tester votre application et mettre Ã  jour votre navigateur Ã  chaque modification de votre code.

### Conclusion

<Vimeo vimeoId="539128272" />

<br />

Ã‡a y est, vous savez tout ce qu'il faut pour travailler dans de bonnes conditions.

:::info
Dans ce cours, vous avez appris Ã  :
- RÃ©cupÃ©rer et modifier des Ã©lÃ©ments du DOM ;
- Capter les Ã©vÃ©nements du DOM ;
- Communiquer avec un service web ;
- Utiliser des mÃ©thodes asynchrones ;
- Utiliser un environnement de dÃ©veloppement.
:::

FÃ©licitation pour votre travail.Â Pensez Ã  rÃ©aliser le dernier quizÂ pour valider vos compÃ©tences !

_Sachez que malgrÃ© tout, nous n'avons fait qu'effleurer la surface. Il y a tant de choses possibles, que je vous invite Ã  aller faire un tour
dans les diffÃ©rentes documentations des modules que nous avons vus !_

-----

## Quiz : Mettez en place les bons outils pour travailler

[Mettez en place les bons outils pour travailler - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/exercises/4097)

#### CompÃ©tences Ã©valuÃ©es

<i class="bi bi-check2-circle"></i> Utiliser un environnement de dÃ©veloppement

-----

#### Question 1 : Vous travaillez en Ã©quipe avec 3 autres dÃ©veloppeurs, sur un mÃªme projet. Vous remarquez que dâ€™un dÃ©veloppeur Ã  lâ€™autre, la syntaxe du code nâ€™est pas la mÃªme. Que pouvez-vous mettre en place pour remÃ©dier Ã  ce problÃ¨meÂ ?

<i class="bi bi-record-circle"></i> Un Linter<br />
<i class="bi bi-circle"></i> Un Minifier<br />
<i class="bi bi-circle"></i> Un Bundler<br />
<i class="bi bi-circle"></i> Un Transpiler<br />
<br />

_Le Linter est un outil permettant de vÃ©rifier le code. Il permet de dÃ©tecter des erreurs de syntaxe, et de faire en sorte que tous les
dÃ©veloppeurs dâ€™une Ã©quipe respectent les mÃªmes conventions dâ€™Ã©criture._

-----

#### Question 2 : Vous remarquez que votre site Internet met du temps Ã  charger. En investiguant un peu plus, vous vous rendez compte que câ€™est le tÃ©lÃ©chargement de votre code JavaScript qui est le plus long. Quâ€™est-ce que vous pourriez envisager pour amÃ©liorer cela ?

*Attention, plusieurs rÃ©ponses sont possibles.*

<i class="bi bi-check-square-fill"></i> Utiliser le Minifier<br />
<i class="bi bi-check-square-fill"></i> Utiliser un Bundler<br />
<i class="bi bi-square"></i>  Utiliser un Transpiler<br />
<br />

_Le Minifier est un outil permettant de compresser le code. Il va renommer toutes vos variables afin que leur nom soit court, et il va
supprimer tous les espaces et les retours Ã  la ligne de votre code. Cela permet de charger votre site web plus rapidement._

_Quant au Bundler, câ€™est un outil permettant de regrouper tous les fichiers de code de votre projet en un seul fichier. Cela permet aux
navigateurs de nâ€™avoir quâ€™un seul fichier Ã  charger, et ainsi dâ€™aller plus vite Ã©galement._

-----

#### Question 3 : Vous avez beau vous tenir au courant des nouvelles versions de JavaScript, vous savez que dâ€™un navigateur Ã  lâ€™autre, les conventions peuvent Ãªtre diffÃ©rentes. Pour vous Ã©viter des erreurs, que mettez-vous en place ?

<i class="bi bi-circle"></i> Le Minifier<br />
<i class="bi bi-circle"></i> Un Bundler<br />
<i class="bi bi-record-circle"></i> Un Transpiler<br />
<br />

_Le Transpiler est un outil permettant de rendre votre code compatible avec tous les navigateurs. Cela vous permet dâ€™utiliser les syntaxes de
JavaScript les plus rÃ©centes, sans avoir Ã  vous soucier que le navigateur de votre visiteur les comprenne._

-----

#### Question 4 : Vous avez trouvÃ© sur Internet un super module JavaScript qui vous permettrait de gÃ©nÃ©rer des UUID. Comment pourriez-vous lâ€™intÃ©grer Ã  votre projet ?

<i class="bi bi-circle"></i> En utilisant un Bundler<br />
<i class="bi bi-circle"></i> En utilisant un Transpiler<br />
<i class="bi bi-record-circle"></i> En utilisant NPM<br />
<br />

_NPM est un outil permettant de gÃ©rer les dÃ©pendances Ã  dâ€™autres modules JavaScript. Cela vous permet dâ€™utiliser du code Ã©crit par dâ€™autres
dÃ©veloppeurs et qui peut Ãªtre utile Ã  votre projet. Il permet Ã©galement dâ€™Ã©crire vos propres modules Ã  partager avec la communautÃ© de JavaScript._

-----

#### Question 5 : Que fait cet extrait ?

```shell
npm install babel-loader --save-dev
```

<i class="bi bi-circle"></i> Il installe le module <i>babel-loader</i><br />
<i class="bi bi-record-circle"></i> Il installe le module <i>babel-loader</i> et lâ€™ajoute dans votre fichier <i>package.json</i><br />
<i class="bi bi-circle"></i> Il vÃ©rifie que <i>babel-loader</i> est bien installÃ© dans votre projet<br />
<i class="bi bi-circle"></i> Il installe le module <i>babel-loader</i> globalement dans votre systÃ¨me<br />
<br />

_Cela vous permet dâ€™installer le module babel-loader et de lâ€™enregistrer dans votre fichier package.json._

-----

#### Question 6 : Ã‰tant donnÃ© ce fichier package.json :

```json
{
    "name": "mon-projet",
    "scripts": {
        "build": "echo 'Salut'",
        "start": "echo â€˜Coucouâ€™",
    },
    "version": "1.0.0",
    "devDependencies": {},
    "dependencies": {}
}
```

**Que fait cette commande ?**

```shell
npm run build
```

<i class="bi bi-circle"></i> Elle affiche "Coucou"<br />
<i class="bi bi-record-circle"></i> Elle affiche "Salut"<br />
<i class="bi bi-circle"></i> Elle transpile notre projet<br />
<i class="bi bi-circle"></i> Elle lance notre projet<br />
<br />

_Elle affiche "Salut". En effet, npm run build va lancer la commande build contenue dans les scripts. Ici elle fait un simple echo â€˜Salutâ€™,
mais Ã§a aurait pu Ãªtre nâ€™importe quelle commande._

-----

#### Question 7 : Vous aimeriez utiliser dans votre projet un minifier, un bundler et un transpiler. Que pourriez-vous mettre en place ?

<i class="bi bi-record-circle"></i> webpack<br />
<i class="bi bi-circle"></i> Babel<br />
<i class="bi bi-circle"></i> NPM<br />
<br />

_Ã€Â lâ€™origine, webpack est un bundler, mais grÃ¢ce Ã  ses loaders et ses plugins, il vous permet de faire bien plus de choses :_
- _minifier_
- _transpiler_
- _charger du CSS_
- _â€¦_

-----

#### Question 8 : En considÃ©rant le fichier webpack.config.js suivant :

```javascript
const path = require('path');

module.exports = {
    mode: "production",
    entry: {
        openclassrooms: "./src/index.js"
    },
    output: {
        filename: "[name].my-app.js",
        path: path.resolve(__dirname, "prod")
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: "babel-loader",
                    options: {
                        presets: ["@babel/preset-env"]
                    }
                }
            }
        ]
    }
};
```

**Que se passera-t-il quand on exÃ©cutera la commande suivante : `webpack` ?**

<i class="bi bi-circle"></i> On va crÃ©er un linter pour le fichier <code>src/index.js</code>.<br />
<i class="bi bi-record-circle"></i> On va bundler notre programme en partant du fichier <code>src/index.js</code>Â et en lâ€™enregistrant dans le
fichier <code>prod/openclassrooms.my-app.js</code>. On utilisera au passage le transpiler Babel pour rendre nos fichiers JavaScript compatibles
avec tous les navigateurs.<br />
<i class="bi bi-circle"></i> On va bundler notre programme en partant du fichier <code>src/index.js</code>Â et en lâ€™enregistrant dans le fichier
<code>dist/app.bundle.js</code>. On utilisera au passage le transpiler Babel pour rendre nos fichiers JavaScript compatibles avec tous les
navigateurs.<br />
<i class="bi bi-circle"></i> On va bundler notre programme en partant du fichier <code>src/index.js</code>Â et en lâ€™enregistrant dans le fichier
<code>dist/test.bundle.js</code>.<br />
<br />

_En effet, comme on peut le voir dans lâ€™objet `entry`, on va chercher le fichier `src/index.js` qui sâ€™appellera dans webpack `openclassrooms`._

_On peut aussi voir dans lâ€™objet `output` que le chemin de destination (`path`) sera le rÃ©pertoire actuel auquel on ajoutera le dossier `prod`.
On peut aussi voir que le fichier de destination (`filename`) sera `[name].my-app.js`, câ€™est-Ã -dire que `[name]` sera remplacÃ© par le nom du
fichier `entry` : `openclassrooms`, soit au final : `openclassrooms.my-app.js.`_

_Enfin, on peut voir quâ€™on va utiliser un loader qui va sâ€™exÃ©cuter sur tous les fichiers `.js` Ã  lâ€™exception de ceux qui se trouvent dans
`node_modules`._
