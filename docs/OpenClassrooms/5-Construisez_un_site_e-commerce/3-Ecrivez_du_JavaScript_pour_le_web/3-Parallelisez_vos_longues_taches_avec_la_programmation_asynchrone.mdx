---
id: 3-Parallelisez_vos_longues_taches_avec_la_programmation_asynchrone
title: Parall√©lisez vos longues t√¢ches avec la programmation asynchrone
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo, CodePen } from 'mdx-embed';

# Parall√©lisez vos longues t√¢ches avec la programmation asynchrone

## Comprenez comment fonctionne l'asynchrone en JS

[Comprenez comment fonctionne l'asynchrone en JS - √âcrivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5577651-comprenez-comment-fonctionne-lasynchrone-en-js)

<Vimeo vimeoId="539128094" />

<br />

Saviez-vous que JavaScript est synchrone et n'a qu'un seul _thread_ d'ex√©cution ?

:::note ?
... qu'est-ce que tu nous racontes l√† ?
:::

### JavaScript est synchrone et mono-thread

:::note ?
Qu'est-ce que √ßa veut dire ?
:::

Eh bien, tout simplement qu'il n'y a qu'**un seul fil d'ex√©cution** du code source. Cela signifie que lorsque vous √©crivez du code, chaque
ligne sera ex√©cut√©e **l'une apr√®s l'autre** en attendant la fin de l'ex√©cution de la ligne pr√©c√©dente. Il n'y a pas d'autre code qui pourra
√™tre ex√©cut√© en parall√®le. Il ne peut faire qu'une seule chose √† la fois.

Mais dans le titre du chapitre tu parles de faire de l'asynchrone en JavaScript, et l√† tu nous dis que ce n'est plus possible ?

Eh bien, en fait il est possible et m√™me tr√®s facile de faire de l'asynchrone en JavaScript, mais l'ex√©cution restera synchrone...

üßê

Bon, essayons de clarifier tout √ßa maintenant...

Si du code **synchrone** est du code qui s'ex√©cute ligne apr√®s ligne en attendant la **fin de l'ex√©cution** de la ligne pr√©c√©dente, alors on
peut facilement en d√©duire que du code **asynchrone** va s'ex√©cuter ligne apr√®s ligne, mais¬†la ligne suivante¬†**n'attendra pas** que la ligne
asynchrone ait fini son ex√©cution. Prenons cet exemple :

```javascript
let productId = 1;
let productPrice = getProductPriceAsync(productId);
doSomething(productPrice);
```

En admettant que la fonction `getProductPriceAsync()`¬†soit asynchrone, alors la ligne suivante sera ex√©cut√©e avant la fin de l'ex√©cution de la
fonction asynchrone, mais il ne sera pas encore possible d'utiliser la valeur de `productPrice`¬†(nous verrons¬†dans le chapitre suivant¬†comment
nous pouvons nous en servir).

Mais comment peut-on faire √ßa avec un langage synchrone ?

Avec ce qu'on appelle l'_event loop_ !

### L'event loop

En JavaScript, chaque ligne de code est ex√©cut√©e de fa√ßon synchrone, mais il est possible de demander √† ex√©cuter du code de mani√®re asynchrone.
Et lorsque l'on demande √† ex√©cuter une fonction de fa√ßon asynchrone, la fonction en question est plac√©e dans une sorte de **file d'attente**
qui va ex√©cuter toutes les fonctions qu'elle contient les unes apr√®s les autres. C'est ce qu'on appelle l'_**event loop**._¬†Tout le c≈ìur du
langage fonctionne autour de √ßa.

:::info
Ainsi, le code n'est pas r√©ellement ex√©cut√© en parall√®le car il est mis en file d'attente, mais il ne bloque pas l'ex√©cution du code depuis
lequel il a √©t√© appel√©.
:::

### Jouez avec l'event loop

Maintenant que vous comprenez un peu mieux ce qu'est l'event loop, voyons concr√®tement comment demander √† ex√©cuter du code de mani√®re asynchrone.

#### La fonction setTimeout

`setTimeout`¬†est¬†la fonction **la plus r√©pandue** lorsque l'on veut ex√©cuter du code asynchrone sans bloquer le fil d'ex√©cution en cours. Cette
fonction prend 2 param√®tres :
- La **fonction √† ex√©cuter** de mani√®re asynchrone (qui sera donc ajout√©e √† la file d'attente de l'event loop) ;
- Le **d√©lai**, en millisecondes, avant d'ex√©cuter cette fonction.

```javascript
setTimeout(function() {
    console.log("I'm here!")
}, 5000);
console.log("Where are you?");
```

Dans l'exemple ci-dessus, le texte `Where are you?`¬†s'affichera avant `I'm here!`, qui ne sera affich√© qu'au bout de 5 secondes.

La fonction `setTimeout`¬†nous retourne une valeur permettant d'identifier le code asynchrone que l'on veut ex√©cuter. Il est possible de passer
cet identifiant en param√®tre √† la fonction `clearTimeout`, si vous souhaitez annuler l'ex√©cution asynchrone de la fonction avant qu'elle ne
soit ex√©cut√©e.

:::info
Pour en savoir plus sur la fonction setTimeout, vous trouverez la documentation [ici, sur le site de W3school](https://www.w3schools.com/jsref/met_win_settimeout.asp).
:::

#### Les autres m√©thodes

Il existe d'autres m√©thodes un peu moins r√©pandues, voire tr√®s peu utilis√©es :
- `setInterval`¬†([documentation √† retrouver ici](https://www.w3schools.com/jsref/met_win_setinterval.asp)) : elle fonctionne exactement comme
`setTimeout`, √† ceci pr√®s qu'elle ex√©cute la fonction pass√©e en param√®tre **en boucle** √† une **fr√©quence d√©termin√©e** par le temps en
millisecondes pass√© en second param√®tre. Il suffira de passer la valeur de retour de `setInterval`¬†√† `clearInterval`¬†pour **stopper**
l'ex√©cution en boucle de la fonction ;
- `setImmediate`¬†([documentation √† retrouver ici](https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate)). Cette fonction prend
en seul param√®tre la fonction √† ex√©cuter de fa√ßon synchrone. ¬†La fonction en question sera plac√©e dans la **file d'attente** de l'event loop,
mais va **passer devant** toutes les autres fonctions, sauf certaines sp√©cifiques au Javascript : les √©v√©nements (les m√™mes qu'on a vus au
premier chapitre, et qui sont donc ex√©cut√©s de fa√ßon asynchrone¬†üòâ), le rendu, et l'I/O. Il existe aussi `nextTick`, qui permet, l√†, de
court-circuiter tout le monde. √Ä utiliser avec pr√©caution, donc...

### Le cas de l'I/O

L'I/O correspond aux √©v√©nements li√©s √† l'_**input**_(les flux d'entr√©e) et l'_**output**_(les flux de sortie). Cela correspond notamment √† la
lecture/√©criture des fichiers, aux requ√™tes HTTP, etc.

Vous avez d√ª remarquer que lorsque l'on ex√©cutait la fonction¬†`fetch()` lors d'une requ√™te HTTP, celle-ci ne bloquait pas l'ex√©cution du code.
On n'attend pas que la requ√™te soit envoy√©e et une r√©ponse re√ßue avant d'ex√©cuter le reste du code. C'est donc une **fonction asynchrone**.

D‚Äôailleurs, _`fetch()`_ retourne une _Promise_ qui est une autre fa√ßon de faire de l‚Äôasynchrone car les fonctions _`then()`_ et _`catch()`_ sont
appel√©es plus tard lorsque le travail (dans ce qu‚Äôon a vu dans le chapitre pr√©c√©dent il s‚Äôagissait d‚Äôune requ√™te HTTP) est termin√©. Et de la
m√™me mani√®re, tout ce qui touche √† l'I/O peut √™tre ex√©cut√© de mani√®re asynchrone. Et c'est tant mieux, car leur ex√©cution peut prendre du temps. üòé

### En r√©sum√©

Dans ce chapitre, vous avez appris :
- Que le JavaScript est synchrone et mono-thread ;
- Que l‚Äôevent loop est le moteur de JavaScript qui ex√©cute les fonctions JavaScript asynchrones sous forme d‚Äô√©v√©nements ;
- Comment utiliser la m√©thode¬† setTimeout ;
- Qu'il existe d'autres m√©thodes asynchrones : _setInterval_, _setImmediate_ ;
- Que l'I/O est g√©r√© de mani√®re asynchrone avec JavaScript.

Vous savez maintenant comment ex√©cuter du code de mani√®re asynchrone, mais on ne sait pas comment profiter du r√©sultat de ce code depuis celui
qui l'a ex√©cut√©.

_Vous vous rappelez de notre exemple de code avec la fonction `getProductPriceAsync` ? Eh bien, avec ce que nous venons d'apprendre nous ne
sommes pas en mesure de renvoyer le r√©sultat de notre code dans la variable `productPrice`. Et c'est justement dans le prochain chapitre que
nous allons voir √ßa !_

-----

## G√©rez du code asynchrone

[G√©rez du code asynchrone - √âcrivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5577676-gerez-du-code-asynchrone)

<Vimeo vimeoId="539128130" />

<br />

Nous allons maintenant voir comment on peut ex√©cuter du code asynchrone et renvoyer le r√©sultat que l'on souhaite √† celui qui a lanc√© le code.

### Callbacks

C'est la m√©thode la plus "vieille" mais toujours utilis√©e par beaucoup de modules JavaScript (nous verrons ce que sont les modules dans la
derni√®re partie de ce cours). Une _**callback**_ est simplement une fonction que vous d√©finissez. Le principe de la¬†callback¬†est de la
**passer en param√®tre** d'une fonction asynchrone. Une fois que la fonction asynchrone a fini sa t√¢che, elle va appeler notre fonction
_callback_ en lui passant un **r√©sultat**. Ainsi, le code que nous mettons dans notre fonction¬†_callback_ sera ex√©cut√© de mani√®re asynchrone.
Cela ne vous rappelle pas quelque chose ? Les **√©v√©nements** ! Les √©v√©nements sont un exemple typique de fonction asynchrone √† laquelle on
passe une fonction¬†_callback_.

```javascript
element.addEventListener('click', function(e) {
    // Do something here ...
});
```

Dans l'exemple ci-dessus, la fonction qui est envoy√©e √† `addEventListener`¬†est une callback. Elle n'est pas appel√©e tout de suite, elle est
appel√©e plus tard, d√®s que l'utilisateur clique sur l'√©l√©ment. √áa ne bloque donc pas l'ex√©cution du code et c'est donc asynchrone. üòÅ

Les¬†callbacks sont la **base de l'asynchrone** en JavaScript et sont tr√®s utilis√©es.

> Par exemple, la fonction que nous passons en param√®tre √†¬†`setTimeout`¬†est une callback.

Les¬†callbacks sont faciles √† comprendre et √† utiliser, mais elles souffrent d'un gros probl√®me de lisibilit√© du code, via ce qu'on appelle le
_callback hell_. En effet, on se retrouve r√©guli√®rement dans des situations o√π on va imbriquer plusieurs couches de¬†callbacks, rendant le code
difficile √† lire et pouvant g√©n√©rer des erreurs.

```javascript
elt.addEventListener('click', function(e) {
    mysql.connect(function(err) {
        mysql.query(sql, function(err, result) {
            fs.readFile(filePath, function(err, data) {
                mysql.query(sql, function(err, result) {
                    // etc.
                });
            });
        });
    });
});
```

Ce code, qui n'est pas facile √† lire, pourrait pourtant correspondre √† un cas d'utilisation concret des callbacks : d√®s que l'utilisateur
clique sur un √©l√©ment, on ouvre une connexion¬†_MySQL_, puis on r√©cup√®re des donn√©es depuis la base de donn√©es, on lit un contenu dans un
fichier et on fait une nouvelle requ√™te¬†_MySQL_, etc.

C'est bien beau de g√©rer du code asynchrone, mais rien ne vous garantit que tout se soit bien pass√©. Il nous faut donc un m√©canisme pour savoir
si une erreur est survenue !

#### G√©rez¬†des erreurs callbacks

Pour g√©rer les erreurs avec les¬†callbacks, la m√©thode la plus utilis√©e est de prendre¬†**2¬†param√®tres** dans notre¬†callback. Le 2e param√®tre
est notre donn√©e et le 1er est l'erreur. Si elle n'est pas¬†_**null**_ ou¬†_**undefined**_,¬† elle¬†contiendra un message d'erreur indiquant qu'une
erreur est intervenue.

Si on reprend l'exemple ci-dessus, on voit par exemple que la lecture d'un fichier avec le module `fs`¬†peut nous retourner une erreur :

```javascript
fs.readFile(filePath, function(err, data) {
    if (err) {
        throw err;
    }
    // Do something with data
});
```

### Promise

Les¬†_**promise**_, ou _promesses_ en fran√ßais, sont un peu plus complexes mais bien plus puissantes et faciles √† lire que les¬†callbacks.

Lorsque l'on ex√©cute du code asynchrone, celui-ci va imm√©diatement nous retourner une "promesse" qu'un r√©sultat nous sera envoy√© prochainement.

Cette promesse est en fait un objet¬†`Promise`¬†qui peut √™tre `resolve`¬†avec un r√©sultat, ou `reject`¬†avec une erreur.

Lorsque l'on r√©cup√®re une `Promise`, on peut utiliser sa fonction `then()`¬†pour ex√©cuter du code d√®s que la promesse est r√©solue, et sa fonction
`catch()`¬†pour ex√©cuter du code d√®s qu'une erreur est survenue.

Voyons avec un exemple concret pour mieux comprendre :

```javascript
functionThatReturnsAPromise()
    .then(function(data) {
        // Do something with data
    })
    .catch(function(err) {
        // Do something with error
    });
```

Dans l'exemple ci-dessus, la fonction `functionThatReturnsAPromise`¬†nous renvoie une `Promise`. On peut donc utiliser sa fonction `then()` en
lui passant une fonction qui sera ex√©cut√©e d√®s qu'un r√©sultat sera re√ßu (avec le r√©sultat en question pass√© √† notre fonction). On peut aussi
utiliser sa fonction `catch()`¬†en lui passant une fonction qui sera ex√©cut√©e si une erreur est survenue (avec l'erreur en question pass√©e √†
notre fonction).

Le gros avantage est que l'on peut aussi **cha√Æner** les `Promise`. Ainsi, la valeur que l'on retourne dans la fonction que l'on passe √†
`then()`¬†est transform√©e en une nouvelle `Promise`¬†r√©solue, que l'on peut utiliser avec une nouvelle fonction `then()`. Si notre fonction
retourne par contre une exception, alors une nouvelle `Promise`¬†rejet√©e est cr√©√©e et on peut l'intercepter avec la fonction `catch()`. Mais si
la fonction que l'on a pass√©e √† `catch()`¬†retourne une nouvelle valeur, alors on a √† nouveau une `Promise`¬†r√©solue que l'on peut utiliser avec
une fonction `then()`, etc.

Voici un exemple qui vous montre comment on peut profiter des `Promise`¬†pour cha√Æner notre code asynchrone :

```javascript
returnAPromiseWithNumber2()
    .then(function(data) { // Data is 2
        return data + 1;
    })
    .then(function(data) { // Data is 3
        throw new Error('error');
    })
    .then(function(data) {
        // Not executed
    })
    .catch(function(err) {
        return 5;
    })
    .then(function(data) { // Data is 5
        // Do something
    });
```

Dans l'exemple ci-dessus, la fonction `returnAPromiseWithNumber2`¬†nous renvoie une `Promise` qui va √™tre r√©solue avec le nombre `2`.
- La premi√®re fonction `then()`¬†va r√©cup√©rer cette valeur.
- Puis, dans cette fonction on retourne `2 + 1`, ce qui cr√©e une nouvelle `Promise`¬†qui est imm√©diatement r√©solue avec `3`.
- Puis, dans le `then()`¬†suivant, nous retournons une erreur.

De ce fait, le¬†`then()` qui suit ne sera pas appel√© et c'est le¬†`catch()` suivant qui va √™tre appel√© avec l'erreur en question. Lui-m√™me
retourne une nouvelle valeur qui est transform√©e en Promise¬†qui est imm√©diatement r√©solue avec la valeur¬†`5`. Le dernier¬†`then()`¬†va √™tre
ex√©cut√© avec cette valeur.

:::info
L‚ÄôAPI `Fetch`¬†utilise les `Promise`¬†pour g√©rer les r√©ponses aux requ√™tes HTTP, comme nous l‚Äôavons vu dans la partie pr√©c√©dente.
:::

#### G√©rez des¬†erreurs Promise

Nous avons d√©j√† vu comment se g√®rent les erreurs avec les `Promise`. Une erreur correspond √† une **exception** qui a √©t√© lanc√©e, et il est
possible de l'intercepter en appelant la fonction `catch()`¬†de la `Promise`.

### Async/await

`async`¬†et `await`¬†sont 2 nouveaux mots cl√©s qui permettent de g√©rer le code asynchrone de mani√®re beaucoup plus intuitive, en bloquant
l'ex√©cution d'un code asynchrone jusqu'√† ce qu'il retourne un r√©sultat.

```javascript
async function fonctionAsynchrone1() {/* code asynchrone */}
async function fonctionAsynchrone2() {/* code asynchrone */}

async function fonctionAsynchrone3() {
    const value1 = await fonctionAsynchrone1();
    const value2 = await fonctionAsynchrone2();
    return value1 + value2;
}
```

Dans cet exemple, nous avons un total de 3 fonction asynchrones : `fonctionAsynchrone1`, `fonctionAsynchrone2`, `fonctionAsynchrone3`. Quand
on utilise `async`¬†et `await`, une fonction asynchrone doit avoir le mot cl√© `async`¬†avant la fonction. Ensuite, dans le code, nous pouvons
faire appel √† des fonctions asynchrones et attendre leur r√©sultat gr√¢ce au mot cl√© `await`¬†que l'on met devant l'appel de la fonction.

:::caution !
`async`¬†/ `await`¬†utilisent les Promise en arri√®re-plan, il est donc possible d'utiliser les 2 en m√™me temps.
:::

#### G√©rez des¬†erreurs async/await

`async` / `await` utilisant les Promise, la lev√©e d'une erreur se fait aussi par une **exception**.

Pour intercepter cette erreur, par contre, il suffit d'ex√©cuter notre code asynchrone dans un bloc¬†`try {} catch (e) {}`, l'erreur √©tant
envoy√©e dans le¬†`catch`.

### √Ä vous de jouer¬†!

![16189267631776_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/20/16189267631776_A-vous-de-jouer%20%282%29.png)

Rendez-vous sur [cet √©diteur CodePen](https://codepen.io/nicolaspatschkowski/pen/NWqyaKP) pour r√©aliser l'exercice suivant.

Dans cet exercice j'ai cr√©√© 2 fonctions asynchrones (avec le mot cl√©¬†`async`)¬†`getNumber1()`¬†et¬†`getNumber2()`.
1. Dans un premier temps nous allons cr√©er une fonction asynchrone (avec¬†`async`) qui s'appelle¬†`compute`¬†et qui va r√©cup√©rer les r√©sultats des
2 fonctions asynchrones¬†`getNumber1()`¬†et¬†`getNumber2()`¬†(avec¬†`await`) et renvoyer la somme des 2 valeurs r√©cup√©r√©es.
2. Maintenant nous allons appeler notre fonction¬†`compute()`¬†et utiliser sa valeur de retour comme une¬†`Promise`¬†pour finalement afficher le
r√©sultat de la promesse dans le contenu HTML de l'√©l√©ment ayant pour ID¬†`result`.

<CodePen codePenId="NWqyaKP" />

```javascript
async function getNumber1() {
  return 10;
}
async function getNumber2() {
  return 4;
}
async function compute() {
  const number1 = await getNumber1();
  const number2 = await getNumber2();
  return number1 + number2;
}
compute() 
  .then(function(value) {
    document
      .getElementById("result")
      .innerText = value + '';
});
```

Vous avez termin√© ? Voici la [solution CodePen](https://codepen.io/fabienhenon/pen/XWNGgvd).

<CodePen codePenId="XWNGgvd" />

### En r√©sum√©

Dans ce chapitre, vous avez appris :
- Qu'une¬†callback est une fonction appel√©e "plus tard" ;
- Que les¬†`Promise`¬†sont des objets qui nous fournissent les fonctions _`then()`_ et _`catch()`_ pour g√©rer le code asynchrone ;
- Que `async`¬†et¬†`await`¬†permettent de faire de l‚Äôasynchrone avec une syntaxes plus naturelle, et qu‚Äôils utilisent en arri√®re plan les
_Promise._

_Nous connaissons maintenant 3 techniques pour faire du code asynchrone et pouvoir utiliser sa valeur ; voyons maintenant comment √ßa peut nous
servir dans le cas de plusieurs requ√™tes HTTP !_

-----

## Parall√©lisez plusieurs requ√™tes HTTP

[Parall√©lisez plusieurs requ√™tes HTTP - √âcrivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5866911-parallelisez-plusieurs-requetes-http)

<Vimeo vimeoId="539128158" />

<br />

Dans ce chapitre, nous allons voir comment **encha√Æner** les requ√™tes HTTP en ex√©cutant 2 requ√™tes GET¬†en m√™me temps (en parall√®le), puis 1
requ√™te POST une fois que les 2 requ√™tes pr√©c√©dentes sont termin√©es (en s√©quence). Pour cela, nous allons avoir besoin des techniques
asynchrones vues au chapitre pr√©c√©dent.

### Encha√Ænez des requ√™tes avec les callbacks

Voyons ensemble comment faire nos 2 requ√™tes **en parall√®le**, suivies d'une requ√™te **en s√©quence** avec les¬†callbacks. Et vous verrez, √ßa
peut vite devenir complexe !

> Pour cet exemple, nous partons du principe que nous avons acc√®s √† 2 fonctions (`get`¬†et `post`). Elles font respectivement une requ√™te `GET`
et une requ√™te `POST`¬†et elles prennent en param√®tre :
> - l'URL de la requ√™te,
> - une callback √† ex√©cuter quand on a le r√©sultat (avec une variable d'erreur en premier param√®tre).

```javascript
var GETRequestCount = 0;
var GETRequestResults = [];
function onGETRequestDone(err, result) {
    if (err) throw err;
    GETRequestCount++;
    GETRequestResults.push(result);
    if (GETRequestCount == 2) {
        post(url3, function(err, result) {
            if (err) throw err;
            // We are done here !
        });
    }
}

get(url1, onGETRequestDone);
get(url2, onGETRequestDone);
```

Comme vous pouvez le voir, le code est assez particulier √† lire. Il y¬†a¬†d'autres fa√ßons d'√©crire ce code, mais √ßa reste une des fa√ßons les plus
simples et rapides √† √©crire.

Afin d'ex√©cuter 2 requ√™tes `GET`¬†en m√™me temps, nous pouvons appeler 2 fois la fonction `get()`. √âtant donn√© que cette fonction est
**asynchrone**, elle ne bloquera pas l'ex√©cution du code. Ainsi l'autre fonction `get()`¬†sera aussi appel√©e alors que la premi√®re ne sera pas
encore termin√©e. C'est comme √ßa qu'on peut avoir 2 requ√™tes en parall√®le.

Par contre, nous voulons ex√©cuter une requ√™te `POST`¬†une fois que les **2 requ√™tes `GET`¬†sont termin√©es**, et pas avant ! Pour ce faire, nous
devons savoir si les requ√™tes `GET`¬†sont termin√©es. C'est pour √ßa que la variable `GETRequestCount`¬†est cr√©√©e. On va l'**incr√©menter** dans la
fonction _callback_ que l'on a envoy√©e aux appels √† `get()`, et si on atteint 2 (le nombre de requ√™tes `GET`¬†qu'on a faites), alors on va
ex√©cuter la requ√™te `POST`.

:::info
`GETRequestResults`¬†sert √† conserver les r√©ponses des requ√™tes `GET`, car on ne les a pas toutes les 2 en m√™me temps.
:::

### Encha√Ænez des requ√™tes avec les Promise

Gr√¢ce √† la fonction `Promise.all`, voyons comment ex√©cuter nos requ√™tes en parall√®le et en s√©quence avec les `Promise`.

> Pour cet exemple, nous partons du principe que nous avons acc√®s √† 2 fonctions (`get`¬†et `post`) qui font respectivement une requ√™te `GET` et
une requ√™te `POST`¬†quand on leur passe en param√®tre l'URL de la requ√™te. Ces fonctions retourneront une `Promise`¬†avec le r√©sultat de la
requ√™te.

```javascript
Promise.all([get(url1), get(url2)])
    .then(function(results) {
        return Promise.all([results, post(url3)]];
    })
    .then(function(allResults) {
        // We are done here !
    });
```

Ici, nous utilisons la fonction `Promise.all`¬†qui prend en param√®tre une liste de `Promise`¬†(cela peut aussi √™tre de simples valeurs qui sont
alors transform√©es en `Promise`¬†r√©solues), et qui permet de toutes les ex√©cuter en parall√®le et de retourner une nouvelle `Promise`¬†qui sera
r√©solue quand toutes les `Promise`¬†seront r√©solues.

Ainsi, la fonction `then()`¬†recevra les r√©sultats de toutes les `Promise`¬†sous forme d'un tableau.

Afin d'ex√©cuter notre requ√™te `POST`¬†une fois que les requ√™tes `GET`¬†sont termin√©es, nous l'ex√©cutons donc dans la fonction `then()`.

:::info
Notez que dans la fonction `then()`, nous faisons encore une fois appel √† la fonction `Promise.all`¬†en lui passant les r√©sultats des requ√™tes
`GET`¬†et notre requ√™te `POST`. √âtant donn√© que `Promise.all` consid√®re les simples valeurs comme des `Promise` r√©solues, cela nous permet, dans
le prochain `then()`, de r√©cup√©rer une liste qui contient les r√©sultats des requ√™tes `GET`¬†et le r√©sultat de la requ√™te `POST`¬†:
`allResults = [ [ getResult1, getResult2 ], postResult ]`.
:::

### Encha√Ænez des requ√™tes avec async/await

Finalement, voyons comment ex√©cuter le m√™me code mais avec `async`¬†/ `await`.

> Pour cet exemple, nous partons du principe que nous avons acc√®s √† 2 fonctions (`get`¬†et `post`) qui font respectivement une requ√™te `GET` et
une requ√™te `POST`¬†quand on leur passe en param√®tre l'URL de la requ√™te. Ces fonctions sont asynchrones (avec le mot cl√© `async`).

```javascript
async function requests() {
    var getResults = await Promise.all([get(url1), get(url2)]);
    var postResult = await post(url3);
    return [getResults, postResult\];
}
requests().then(function(allResults) {
    // We are done here !
});
```

Nous utilisons aussi la fonction `Promise.all`¬†dans ce code, car c'est comme √ßa que l'on peut ex√©cuter des fonctions asynchrones en parall√®le
(rappelez-vous que `async`¬†correspond en arri√®re-plan √† une `Promise`).

Par contre, ici, nous utilisons `await`¬†devant `Promise.all`¬†afin d'attendre la fin de l'ex√©cution des 2 requ√™tes `GET`, puis nous utilisons
`await`¬†devant la requ√™te `POST`¬†afin d'attendre son r√©sultat. Puis nous renvoyons un tableau avec tous les r√©sultats.

Lorsque nous appelons la fonction `requests()`, ici, nous utilisons `then()`¬†pour r√©cup√©rer tous les r√©sultats (mais vous auriez aussi pu
utiliser `await`¬†au sein d'une autre fonction avec le mot cl√©¬†`async`).

### En r√©sum√©

Dans ce chapitre, vous avez appris :
- √Ä encha√Æner des requ√™tes avec la m√©thode des callbacks ;
- √Ä encha√Æner des requ√™tes avec la m√©thode des `Promise`¬†;
- √Ä¬†encha√Æner des requ√™tes avec la m√©thode `async`¬†/ `await`.

_Vous connaissez maintenant 3 techniques pour ex√©cuter du code asynchrone et vous savez les mettre en situation. √Ä vous maintenant de vous
faire votre propre avis sur celle que vous pr√©f√©rez utiliser. Il est temps maintenant de passer √† la prochaine partie o√π nous verrons comment
coder en JavaScript dans un environnement plus efficace.¬† üòé_

-----

## Quiz : Parall√©lisez vos longues t√¢ches avec la programmation asynchrone

[Parall√©lisez vos longues t√¢ches avec la programmation asynchrone - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/exercises/3197)

#### Comp√©tences √©valu√©es

<i class="bi bi-check2-circle"></i> Utiliser des m√©thodes asynchrones

-----

#### Question 1 : Que peut-on dire du langage JavaScript ?

<i class="bi bi-circle"></i> Qu'il est asynchrone et mono-thread<br />
<i class="bi bi-record-circle"></i> Qu'il est synchrone et mono-thread<br />
<i class="bi bi-circle"></i> Qu'il est asynchrone et multi-thread<br />
<i class="bi bi-circle"></i> Qu'il est synchrone et multi-thread<br />
<br />

*Le JavaScript est un langage synchrone et mono-thread. L'asynchrone se fait gr√¢ce √† l'event loop en envoyant des fonctions dans sa file
d'attente.*

-----

#### Question 2 : Qu'est-ce que l'event loop ?

<i class="bi bi-record-circle"></i> Un gros tunnel mono-thread dans lequel sont empil√©es des fonctions qui vont √™tre ex√©cut√©es les unes apr√®s
les autres<br />
<i class="bi bi-circle"></i> Un gros tunnel multi-thread dans lequel les fonctions vont √™tre parall√©lis√©es pour √™tre ex√©cut√©es de mani√®re
asynchrone<br />
<i class="bi bi-circle"></i> Une simple boucle ¬†`for`¬† dans laquelle on ex√©cute g√©n√©ralement des √©v√©nements<br />
<i class="bi bi-circle"></i> Cela¬†n'existe pas<br />
<br />

*On peut voir l'event loop comme √©tant un tunnel mono-thread dans lequel on va mettre en file d'attente des fonctions pour¬†d√©caler leur
ex√©cution.*

-----

#### Question 3 : Qu‚Äôaffiche cet extrait ?

```javascript
setTimeout(function() {
    console.log("Prems");
});
console.log("Deuz");
```

<i class="bi bi-circle"></i><code>Prems</code>, puis <code>Deuz</code><br />
<i class="bi bi-record-circle"></i><code>Deuz</code>, puis <code>Prems</code><br />
<br />

_`setTimeout` sert √† retarder l'ex√©cution d'une fonction du temps indiqu√©. Il va ajouter la fonction pass√©e en param√®tre √† l'event loop, et
demander √† attendre un certain temps avant de l'ex√©cuter. Si aucun temps n‚Äôest pass√© √† la fonction (comme dans notre exemple), alors notre
callback sera ex√©cut√©e au prochain tour de l‚Äôevent loop, et donc apr√®s `Deuz`._

-----

#### Question 4 : Qu'est-ce qu'une¬†callback ?

<i class="bi bi-circle"></i> Une fonction qui va ex√©cuter une autre fonction lorsqu'elle a termin√© ce qu'elle devait faire<br />
<i class="bi bi-record-circle"></i> Une fonction qui sera ex√©cut√©e par une autre fonction lorsque cette derni√®re aura termin√© ce qu'elle devait
faire<br />
<i class="bi bi-circle"></i> Une fonction qui va r√©cup√©rer toutes les informations de navigation d'un utilisateur<br />
<br />

*La diff√©rence est subtile : une callback est une fonction (appelons-la¬†`cb`) que l'on passe en param√®tre √† une autre fonction (appelons-la
`fn`). C'est `fn`¬†qui va ex√©cuter `cb`¬†lorsqu'elle aura fini ce qu'elle doit faire.*

-----

#### Question 5 : Qu'est-ce qu'une `Promise`¬†?

<i class="bi bi-circle"></i> Une promesse que l'on ne tient jamais (comme toutes les promesses)<br />
<i class="bi bi-circle"></i> Un objet JavaScript qui n'aura jamais de valeur<br />
<i class="bi bi-record-circle"></i> Un objet JavaScript d√©di√© aux traitements asynchrones<br />
<i class="bi bi-circle"></i> Une fonction qui¬†promet d'ex√©cuter du code dans un d√©lai imparti<br />
<br />

_Une `Promise` est un objet JavaScript utilis√© pour r√©aliser des traitements asynchrones tels que des appels API (GET, POST, etc.). Elle
dispose de plusieurs statuts :_
- _"pending". La requ√™te est en train d‚Äô√™tre r√©alis√©e._
- _"resolve". La requ√™te a √©t√© r√©alis√©e et aucune erreur n‚Äôa eu lieu. La fonction `then()` est appel√©e._
- _"reject". Une erreur est survenue et le traitement asynchrone a √©chou√©. La fonction `catch()` est appel√©e._

-----

#### Question 6 : Qu‚Äôaffiche ce code ?

```javascript
async function num1() { return 42; }
async function num2() { return Promise.resolve(3); }

async function compute() {
    const n1 = await num1();
    const n2 = await num2();
    return n1 + n2;
}

compute()
    .then(function(res) {
        console.log(res);
    })
    .catch(function() {
        console.log(‚ÄúErreur‚Äù);
});
```

<i class="bi bi-record-circle"></i> 45<br />
<i class="bi bi-circle"></i> Une <i>Promise</i><br />
<i class="bi bi-circle"></i> "Erreur"<br />
<br />

_`async` et `await` sont des mots cl√©s du langage JavaScript qui permettent de cr√©er du code asynchrone qui utilisera les `Promise` en
arri√®re-plan. Dans notre exemple, la fonction `compute` r√©cup√®re le r√©sultat des fonctions `num1` et `num2` en attendant que leur `Promise`
soit r√©solue (ce qui est imm√©diatement le cas de nos 2 fonctions car l‚Äôune renvoie directement une valeur num√©rique, et l‚Äôautre utilise
`Promise.resolve()` qui indique que la `Promise` est r√©solue)._

_`compute` renvoie donc une `Promise` qui vaudra 45. Lorsqu‚Äôon l‚Äôappelle, ici, on utilise la fonction `then()` car `async` et `await` sont des
`Promise` en arri√®re-plan, et on affiche le r√©sultat (45) dans la console._

-----

#### Question 7 : Sachant que promise1 sera r√©solue avec la valeur "Salut", et que promise2 sera r√©solue avec "toi", qu‚Äôaffiche cet extrait¬†?

```javascript
Promise.all([promise1, promise2])
.then(function(values) {
    console.log(values.join(" "));
});
```

<i class="bi bi-circle"></i> ["Salut", "toi"]<br />
<i class="bi bi-record-circle"></i> "Salut toi"<br />
<i class="bi bi-circle"></i> "Salut"<br />
<i class="bi bi-circle"></i> "toi"<br />
<br />

_`Promise.all` prend en param√®tre une liste de `Promise` et retourne une nouvelle `Promise` qui sera r√©solue une fois que toutes les `Promise`
seront r√©solues. Cette `Promise`¬†contiendra le r√©sultat de toutes les `Promise`¬†sous forme de liste et en conservant l‚Äôordre dans la fonction
`all()`. Ainsi, notre code affichera "Salut toi"._

-----

#### Question 8 : Que fait cet extrait ?

```javascript
setInterval(callback, 1000);
```

<i class="bi bi-circle"></i> Il ex√©cute la callback au bout de 1 seconde<br />
<i class="bi bi-circle"></i> Il ex√©cute la callback au bout de 1¬†000 secondes<br />
<i class="bi bi-record-circle"></i> Il ex√©cute la callback toutes les 1 seconde<br />
<i class="bi bi-circle"></i> Il ex√©cute la callback toutes les 1¬†000 secondes<br />
<br />

_`setInterval` permet d'ex√©cuter une fonction de callback toutes les X ms. La fonction prend le d√©lai en millisecondes et non en secondes._

-----

#### Question 9 : Que fait ce code et que contient la variable `promiseRes` ?

**(Dans cet extrait nous utilisons la fonction `reduce` . Elle permet de parcourir une liste et de la r√©duire √† une seule valeur¬†:
l‚Äôaccumulateur. Pour en savoir plus, n‚Äôh√©sitez pas √† aller faire un tour sur la [documentation de la fonction](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)).**

```javascript
async function func1() {
    return 3;
}

async function func2() {
    return 4;
}

var promiseRes =
    Promise
        .all([func1(), func2()])
        .then(function(results) {
            return results.reduce(function(acc, res) {
                return acc * res;
            }, 2);
        })
        .then(function(time) {
            return setTimeout(callback, time * 1000);
        });
```

<i class="bi bi-record-circle"></i><code>promiseRes</code>¬†vaut¬†une promesse r√©solue avec l'identifiant de la fonction <code>setTimeout</code>,
et la callback est appel√©e apr√®s 24¬†secondes<br />
<i class="bi bi-circle"></i><code>promiseRes</code>¬†vaut un identifiant de <code>setTimeout</code>, et la callback est appel√©e apr√®s 12¬†secondes<br />
<i class="bi bi-circle"></i><code>promiseRes</code>¬†vaut un identifiant de <code>setTimeout</code>, et la callback est appel√©e apr√®s¬†24 secondes<br />
<i class="bi bi-circle"></i><code>promiseRes</code>¬†vaut une promesse r√©solue avec l'identifiant de la fonction <code>setTimeout</code>, et la
callback est appel√©e apr√®s 12¬†secondes<br />
<br />

_Ici nous ex√©cutons 2 fonctions asynchrones en parall√®le avec `Promise.all`. La premi√®re fonction `then()`¬†va appeler `reduce`¬†sur la liste de
r√©sultats (3, et 4) et multiplier les valeurs entre elles avec une valeur initiale de 2, soit¬†: `2 * 3 * 4 = 24`._

_Le r√©sultat est pass√© √† la prochaine fonction `then()`, qui va appeler une callback apr√®s `time`¬†secondes, `time`¬†correspondant ici √† 24, le
r√©sultat du pr√©c√©dent `then()`._

_Enfin, on retourne le r√©sultat de la fonction `setTimeout()`, `promiseRes`¬†contient donc une `Promise`¬†qui sera r√©solue avec l'identifiant de
la fonction `setTimeout`¬†retourn√©._
