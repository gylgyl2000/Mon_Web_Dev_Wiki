---
id: 3-Parallelisez_vos_longues_taches_avec_la_programmation_asynchrone
title: ParallÃ©lisez vos longues tÃ¢ches avec la programmation asynchrone
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo, CodePen } from 'mdx-embed';

# ParallÃ©lisez vos longues tÃ¢ches avec la programmation asynchrone

## Comprenez comment fonctionne l'asynchrone en JS

[Comprenez comment fonctionne l'asynchrone en JS - Ã‰crivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5577651-comprenez-comment-fonctionne-lasynchrone-en-js)

<Vimeo vimeoId="539128094" />

<br />

Saviez-vous que JavaScript est synchrone et n'a qu'un seul _thread_ d'exÃ©cution ?

:::note ?
... qu'est-ce que tu nous racontes lÃ  ?
:::

### JavaScript est synchrone et mono-thread

:::note ?
Qu'est-ce que Ã§a veut dire ?
:::

Eh bien, tout simplement qu'il n'y a qu'**un seul fil d'exÃ©cution** du code source. Cela signifie que lorsque vous Ã©crivez du code, chaque
ligne sera exÃ©cutÃ©e **l'une aprÃ¨s l'autre** en attendant la fin de l'exÃ©cution de la ligne prÃ©cÃ©dente. Il n'y a pas d'autre code qui pourra
Ãªtre exÃ©cutÃ© en parallÃ¨le. Il ne peut faire qu'une seule chose Ã  la fois.

Mais dans le titre du chapitre tu parles de faire de l'asynchrone en JavaScript, et lÃ  tu nous dis que ce n'est plus possible ?

Eh bien, en fait il est possible et mÃªme trÃ¨s facile de faire de l'asynchrone en JavaScript, mais l'exÃ©cution restera synchrone...

ğŸ§

Bon, essayons de clarifier tout Ã§a maintenant...

Si du code **synchrone** est du code qui s'exÃ©cute ligne aprÃ¨s ligne en attendant la **fin de l'exÃ©cution** de la ligne prÃ©cÃ©dente, alors on
peut facilement en dÃ©duire que du code **asynchrone** va s'exÃ©cuter ligne aprÃ¨s ligne, maisÂ la ligne suivanteÂ **n'attendra pas** que la ligne
asynchrone ait fini son exÃ©cution. Prenons cet exemple :

```javascript
let productId = 1;
let productPrice = getProductPriceAsync(productId);
doSomething(productPrice);
```

En admettant que la fonction `getProductPriceAsync()`Â soit asynchrone, alors la ligne suivante sera exÃ©cutÃ©e avant la fin de l'exÃ©cution de la
fonction asynchrone, mais il ne sera pas encore possible d'utiliser la valeur de `productPrice`Â (nous verronsÂ dans le chapitre suivantÂ comment
nous pouvons nous en servir).

Mais comment peut-on faire Ã§a avec un langage synchrone ?

Avec ce qu'on appelle l'_event loop_ !

### L'event loop

En JavaScript, chaque ligne de code est exÃ©cutÃ©e de faÃ§on synchrone, mais il est possible de demander Ã  exÃ©cuter du code de maniÃ¨re asynchrone.
Et lorsque l'on demande Ã  exÃ©cuter une fonction de faÃ§on asynchrone, la fonction en question est placÃ©e dans une sorte de **file d'attente**
qui va exÃ©cuter toutes les fonctions qu'elle contient les unes aprÃ¨s les autres. C'est ce qu'on appelle l'_**event loop**._Â Tout le cÅ“ur du
langage fonctionne autour de Ã§a.

:::info
Ainsi, le code n'est pas rÃ©ellement exÃ©cutÃ© en parallÃ¨le car il est mis en file d'attente, mais il ne bloque pas l'exÃ©cution du code depuis
lequel il a Ã©tÃ© appelÃ©.
:::

### Jouez avec l'event loop

Maintenant que vous comprenez un peu mieux ce qu'est l'event loop, voyons concrÃ¨tement comment demander Ã  exÃ©cuter du code de maniÃ¨re asynchrone.

#### La fonction setTimeout

`setTimeout`Â estÂ la fonction **la plus rÃ©pandue** lorsque l'on veut exÃ©cuter du code asynchrone sans bloquer le fil d'exÃ©cution en cours. Cette
fonction prend 2 paramÃ¨tres :
- La **fonction Ã  exÃ©cuter** de maniÃ¨re asynchrone (qui sera donc ajoutÃ©e Ã  la file d'attente de l'event loop) ;
- Le **dÃ©lai**, en millisecondes, avant d'exÃ©cuter cette fonction.

```javascript
setTimeout(function() {
    console.log("I'm here!")
}, 5000);
console.log("Where are you?");
```

Dans l'exemple ci-dessus, le texte `Where are you?`Â s'affichera avant `I'm here!`, qui ne sera affichÃ© qu'au bout de 5 secondes.

La fonction `setTimeout`Â nous retourne une valeur permettant d'identifier le code asynchrone que l'on veut exÃ©cuter. Il est possible de passer
cet identifiant en paramÃ¨tre Ã  la fonction `clearTimeout`, si vous souhaitez annuler l'exÃ©cution asynchrone de la fonction avant qu'elle ne
soit exÃ©cutÃ©e.

:::info
Pour en savoir plus sur la fonction setTimeout, vous trouverez la documentation [ici, sur le site de W3school](https://www.w3schools.com/jsref/met_win_settimeout.asp).
:::

#### Les autres mÃ©thodes

Il existe d'autres mÃ©thodes un peu moins rÃ©pandues, voire trÃ¨s peu utilisÃ©es :
- `setInterval`Â ([documentation Ã  retrouver ici](https://www.w3schools.com/jsref/met_win_setinterval.asp)) : elle fonctionne exactement comme
`setTimeout`, Ã  ceci prÃ¨s qu'elle exÃ©cute la fonction passÃ©e en paramÃ¨tre **en boucle** Ã  une **frÃ©quence dÃ©terminÃ©e** par le temps en
millisecondes passÃ© en second paramÃ¨tre. Il suffira de passer la valeur de retour de `setInterval`Â Ã  `clearInterval`Â pour **stopper**
l'exÃ©cution en boucle de la fonction ;
- `setImmediate`Â ([documentation Ã  retrouver ici](https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate)). Cette fonction prend
en seul paramÃ¨tre la fonction Ã  exÃ©cuter de faÃ§on synchrone. Â La fonction en question sera placÃ©e dans la **file d'attente** de l'event loop,
mais va **passer devant** toutes les autres fonctions, sauf certaines spÃ©cifiques au Javascript : les Ã©vÃ©nements (les mÃªmes qu'on a vus au
premier chapitre, et qui sont donc exÃ©cutÃ©s de faÃ§on asynchroneÂ ğŸ˜‰), le rendu, et l'I/O. Il existe aussi `nextTick`, qui permet, lÃ , de
court-circuiter tout le monde. Ã€ utiliser avec prÃ©caution, donc...

### Le cas de l'I/O

L'I/O correspond aux Ã©vÃ©nements liÃ©s Ã  l'_**input**_(les flux d'entrÃ©e) et l'_**output**_(les flux de sortie). Cela correspond notamment Ã  la
lecture/Ã©criture des fichiers, aux requÃªtes HTTP, etc.

Vous avez dÃ» remarquer que lorsque l'on exÃ©cutait la fonctionÂ `fetch()` lors d'une requÃªte HTTP, celle-ci ne bloquait pas l'exÃ©cution du code.
On n'attend pas que la requÃªte soit envoyÃ©e et une rÃ©ponse reÃ§ue avant d'exÃ©cuter le reste du code. C'est donc une **fonction asynchrone**.

Dâ€™ailleurs, _`fetch()`_ retourne une _Promise_ qui est une autre faÃ§on de faire de lâ€™asynchrone car les fonctions _`then()`_ et _`catch()`_ sont
appelÃ©es plus tard lorsque le travail (dans ce quâ€™on a vu dans le chapitre prÃ©cÃ©dent il sâ€™agissait dâ€™une requÃªte HTTP) est terminÃ©. Et de la
mÃªme maniÃ¨re, tout ce qui touche Ã  l'I/O peut Ãªtre exÃ©cutÃ© de maniÃ¨re asynchrone. Et c'est tant mieux, car leur exÃ©cution peut prendre du temps. ğŸ˜

### En rÃ©sumÃ©

Dans ce chapitre, vous avez appris :
- Que le JavaScript est synchrone et mono-thread ;
- Que lâ€™event loop est le moteur de JavaScript qui exÃ©cute les fonctions JavaScript asynchrones sous forme dâ€™Ã©vÃ©nements ;
- Comment utiliser la mÃ©thodeÂ  setTimeout ;
- Qu'il existe d'autres mÃ©thodes asynchrones : _setInterval_, _setImmediate_ ;
- Que l'I/O est gÃ©rÃ© de maniÃ¨re asynchrone avec JavaScript.

Vous savez maintenant comment exÃ©cuter du code de maniÃ¨re asynchrone, mais on ne sait pas comment profiter du rÃ©sultat de ce code depuis celui
qui l'a exÃ©cutÃ©.

_Vous vous rappelez de notre exemple de code avec la fonction `getProductPriceAsync` ? Eh bien, avec ce que nous venons d'apprendre nous ne
sommes pas en mesure de renvoyer le rÃ©sultat de notre code dans la variable `productPrice`. Et c'est justement dans le prochain chapitre que
nous allons voir Ã§a !_

-----

## GÃ©rez du code asynchrone

[GÃ©rez du code asynchrone - Ã‰crivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5577676-gerez-du-code-asynchrone)

<Vimeo vimeoId="539128130" />

<br />

Nous allons maintenant voir comment on peut exÃ©cuter du code asynchrone et renvoyer le rÃ©sultat que l'on souhaite Ã  celui qui a lancÃ© le code.

### Callbacks

C'est la mÃ©thode la plus "vieille" mais toujours utilisÃ©e par beaucoup de modules JavaScript (nous verrons ce que sont les modules dans la
derniÃ¨re partie de ce cours). Une _**callback**_ est simplement une fonction que vous dÃ©finissez. Le principe de laÂ callbackÂ est de la
**passer en paramÃ¨tre** d'une fonction asynchrone. Une fois que la fonction asynchrone a fini sa tÃ¢che, elle va appeler notre fonction
_callback_ en lui passant un **rÃ©sultat**. Ainsi, le code que nous mettons dans notre fonctionÂ _callback_ sera exÃ©cutÃ© de maniÃ¨re asynchrone.
Cela ne vous rappelle pas quelque chose ? Les **Ã©vÃ©nements** ! Les Ã©vÃ©nements sont un exemple typique de fonction asynchrone Ã  laquelle on
passe une fonctionÂ _callback_.

```javascript
element.addEventListener('click', function(e) {
    // Do something here ...
});
```

Dans l'exemple ci-dessus, la fonction qui est envoyÃ©e Ã  `addEventListener`Â est une callback. Elle n'est pas appelÃ©e tout de suite, elle est
appelÃ©e plus tard, dÃ¨s que l'utilisateur clique sur l'Ã©lÃ©ment. Ã‡a ne bloque donc pas l'exÃ©cution du code et c'est donc asynchrone. ğŸ˜

LesÂ callbacks sont la **base de l'asynchrone** en JavaScript et sont trÃ¨s utilisÃ©es.

> Par exemple, la fonction que nous passons en paramÃ¨tre Ã Â `setTimeout`Â est une callback.

LesÂ callbacks sont faciles Ã  comprendre et Ã  utiliser, mais elles souffrent d'un gros problÃ¨me de lisibilitÃ© du code, via ce qu'on appelle le
_callback hell_. En effet, on se retrouve rÃ©guliÃ¨rement dans des situations oÃ¹ on va imbriquer plusieurs couches deÂ callbacks, rendant le code
difficile Ã  lire et pouvant gÃ©nÃ©rer des erreurs.

```javascript
elt.addEventListener('click', function(e) {
    mysql.connect(function(err) {
        mysql.query(sql, function(err, result) {
            fs.readFile(filePath, function(err, data) {
                mysql.query(sql, function(err, result) {
                    // etc.
                });
            });
        });
    });
});
```

Ce code, qui n'est pas facile Ã  lire, pourrait pourtant correspondre Ã  un cas d'utilisation concret des callbacks : dÃ¨s que l'utilisateur
clique sur un Ã©lÃ©ment, on ouvre une connexionÂ _MySQL_, puis on rÃ©cupÃ¨re des donnÃ©es depuis la base de donnÃ©es, on lit un contenu dans un
fichier et on fait une nouvelle requÃªteÂ _MySQL_, etc.

C'est bien beau de gÃ©rer du code asynchrone, mais rien ne vous garantit que tout se soit bien passÃ©. Il nous faut donc un mÃ©canisme pour savoir
si une erreur est survenue !

#### GÃ©rezÂ des erreurs callbacks

Pour gÃ©rer les erreurs avec lesÂ callbacks, la mÃ©thode la plus utilisÃ©e est de prendreÂ **2Â paramÃ¨tres** dans notreÂ callback. Le 2e paramÃ¨tre
est notre donnÃ©e et le 1er est l'erreur. Si elle n'est pasÂ _**null**_ ouÂ _**undefined**_,Â  elleÂ contiendra un message d'erreur indiquant qu'une
erreur est intervenue.

Si on reprend l'exemple ci-dessus, on voit par exemple que la lecture d'un fichier avec le module `fs`Â peut nous retourner une erreur :

```javascript
fs.readFile(filePath, function(err, data) {
    if (err) {
        throw err;
    }
    // Do something with data
});
```

### Promise

LesÂ _**promise**_, ou _promesses_ en franÃ§ais, sont un peu plus complexes mais bien plus puissantes et faciles Ã  lire que lesÂ callbacks.

Lorsque l'on exÃ©cute du code asynchrone, celui-ci va immÃ©diatement nous retourner une "promesse" qu'un rÃ©sultat nous sera envoyÃ© prochainement.

Cette promesse est en fait un objetÂ `Promise`Â qui peut Ãªtre `resolve`Â avec un rÃ©sultat, ou `reject`Â avec une erreur.

Lorsque l'on rÃ©cupÃ¨re une `Promise`, on peut utiliser sa fonction `then()`Â pour exÃ©cuter du code dÃ¨s que la promesse est rÃ©solue, et sa fonction
`catch()`Â pour exÃ©cuter du code dÃ¨s qu'une erreur est survenue.

Voyons avec un exemple concret pour mieux comprendre :

```javascript
functionThatReturnsAPromise()
    .then(function(data) {
        // Do something with data
    })
    .catch(function(err) {
        // Do something with error
    });
```

Dans l'exemple ci-dessus, la fonction `functionThatReturnsAPromise`Â nous renvoie une `Promise`. On peut donc utiliser sa fonction `then()` en
lui passant une fonction qui sera exÃ©cutÃ©e dÃ¨s qu'un rÃ©sultat sera reÃ§u (avec le rÃ©sultat en question passÃ© Ã  notre fonction). On peut aussi
utiliser sa fonction `catch()`Â en lui passant une fonction qui sera exÃ©cutÃ©e si une erreur est survenue (avec l'erreur en question passÃ©e Ã 
notre fonction).

Le gros avantage est que l'on peut aussi **chaÃ®ner** les `Promise`. Ainsi, la valeur que l'on retourne dans la fonction que l'on passe Ã 
`then()`Â est transformÃ©e en une nouvelle `Promise`Â rÃ©solue, que l'on peut utiliser avec une nouvelle fonction `then()`. Si notre fonction
retourne par contre une exception, alors une nouvelle `Promise`Â rejetÃ©e est crÃ©Ã©e et on peut l'intercepter avec la fonction `catch()`. Mais si
la fonction que l'on a passÃ©e Ã  `catch()`Â retourne une nouvelle valeur, alors on a Ã  nouveau une `Promise`Â rÃ©solue que l'on peut utiliser avec
une fonction `then()`, etc.

Voici un exemple qui vous montre comment on peut profiter des `Promise`Â pour chaÃ®ner notre code asynchrone :

```javascript
returnAPromiseWithNumber2()
    .then(function(data) { // Data is 2
        return data + 1;
    })
    .then(function(data) { // Data is 3
        throw new Error('error');
    })
    .then(function(data) {
        // Not executed
    })
    .catch(function(err) {
        return 5;
    })
    .then(function(data) { // Data is 5
        // Do something
    });
```

Dans l'exemple ci-dessus, la fonction `returnAPromiseWithNumber2`Â nous renvoie une `Promise` qui va Ãªtre rÃ©solue avec le nombre `2`.
- La premiÃ¨re fonction `then()`Â va rÃ©cupÃ©rer cette valeur.
- Puis, dans cette fonction on retourne `2 + 1`, ce qui crÃ©e une nouvelle `Promise`Â qui est immÃ©diatement rÃ©solue avec `3`.
- Puis, dans le `then()`Â suivant, nous retournons une erreur.

De ce fait, leÂ `then()` qui suit ne sera pas appelÃ© et c'est leÂ `catch()` suivant qui va Ãªtre appelÃ© avec l'erreur en question. Lui-mÃªme
retourne une nouvelle valeur qui est transformÃ©e en PromiseÂ qui est immÃ©diatement rÃ©solue avec la valeurÂ `5`. Le dernierÂ `then()`Â va Ãªtre
exÃ©cutÃ© avec cette valeur.

:::info
Lâ€™API `Fetch`Â utilise les `Promise`Â pour gÃ©rer les rÃ©ponses aux requÃªtes HTTP, comme nous lâ€™avons vu dans la partie prÃ©cÃ©dente.
:::

#### GÃ©rez desÂ erreurs Promise

Nous avons dÃ©jÃ  vu comment se gÃ¨rent les erreurs avec les `Promise`. Une erreur correspond Ã  une **exception** qui a Ã©tÃ© lancÃ©e, et il est
possible de l'intercepter en appelant la fonction `catch()`Â de la `Promise`.

### Async/await

`async`Â et `await`Â sont 2 nouveaux mots clÃ©s qui permettent de gÃ©rer le code asynchrone de maniÃ¨re beaucoup plus intuitive, en bloquant
l'exÃ©cution d'un code asynchrone jusqu'Ã  ce qu'il retourne un rÃ©sultat.

```javascript
async function fonctionAsynchrone1() {/* code asynchrone */}
async function fonctionAsynchrone2() {/* code asynchrone */}

async function fonctionAsynchrone3() {
    const value1 = await fonctionAsynchrone1();
    const value2 = await fonctionAsynchrone2();
    return value1 + value2;
}
```

Dans cet exemple, nous avons un total de 3 fonction asynchrones : `fonctionAsynchrone1`, `fonctionAsynchrone2`, `fonctionAsynchrone3`. Quand
on utilise `async`Â et `await`, une fonction asynchrone doit avoir le mot clÃ© `async`Â avant la fonction. Ensuite, dans le code, nous pouvons
faire appel Ã  des fonctions asynchrones et attendre leur rÃ©sultat grÃ¢ce au mot clÃ© `await`Â que l'on met devant l'appel de la fonction.

:::caution !
`async`Â / `await`Â utilisent les Promise en arriÃ¨re-plan, il est donc possible d'utiliser les 2 en mÃªme temps.
:::

#### GÃ©rez desÂ erreurs async/await

`async` / `await` utilisant les Promise, la levÃ©e d'une erreur se fait aussi par une **exception**.

Pour intercepter cette erreur, par contre, il suffit d'exÃ©cuter notre code asynchrone dans un blocÂ `try {} catch (e) {}`, l'erreur Ã©tant
envoyÃ©e dans leÂ `catch`.

### Ã€ vous de jouerÂ !

![16189267631776_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/20/16189267631776_A-vous-de-jouer%20%282%29.png)

Rendez-vous sur [cet Ã©diteur CodePen](https://codepen.io/nicolaspatschkowski/pen/NWqyaKP) pour rÃ©aliser l'exercice suivant.

Dans cet exercice j'ai crÃ©Ã© 2 fonctions asynchrones (avec le mot clÃ©Â `async`)Â `getNumber1()`Â etÂ `getNumber2()`.
1. Dans un premier temps nous allons crÃ©er une fonction asynchrone (avecÂ `async`) qui s'appelleÂ `compute`Â et qui va rÃ©cupÃ©rer les rÃ©sultats des
2 fonctions asynchronesÂ `getNumber1()`Â etÂ `getNumber2()`Â (avecÂ `await`) et renvoyer la somme des 2 valeurs rÃ©cupÃ©rÃ©es.
2. Maintenant nous allons appeler notre fonctionÂ `compute()`Â et utiliser sa valeur de retour comme uneÂ `Promise`Â pour finalement afficher le
rÃ©sultat de la promesse dans le contenu HTML de l'Ã©lÃ©ment ayant pour IDÂ `result`.

<CodePen codePenId="NWqyaKP" />

```javascript
async function getNumber1() {
  return 10;
}
async function getNumber2() {
  return 4;
}
async function compute() {
  const number1 = await getNumber1();
  const number2 = await getNumber2();
  return number1 + number2;
}
compute() 
  .then(function(value) {
    document
      .getElementById("result")
      .innerText = value + '';
});
```

Vous avez terminÃ© ? Voici la [solution CodePen](https://codepen.io/fabienhenon/pen/XWNGgvd).

<CodePen codePenId="XWNGgvd" />

### En rÃ©sumÃ©

Dans ce chapitre, vous avez appris :
- Qu'uneÂ callback est une fonction appelÃ©e "plus tard" ;
- Que lesÂ `Promise`Â sont des objets qui nous fournissent les fonctions _`then()`_ et _`catch()`_ pour gÃ©rer le code asynchrone ;
- Que `async`Â etÂ `await`Â permettent de faire de lâ€™asynchrone avec une syntaxes plus naturelle, et quâ€™ils utilisent en arriÃ¨re plan les
_Promise._

_Nous connaissons maintenant 3 techniques pour faire du code asynchrone et pouvoir utiliser sa valeur ; voyons maintenant comment Ã§a peut nous
servir dans le cas de plusieurs requÃªtes HTTP !_

-----

## ParallÃ©lisez plusieurs requÃªtes HTTP

[ParallÃ©lisez plusieurs requÃªtes HTTP - Ã‰crivez du JavaScript pour le web - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5866911-parallelisez-plusieurs-requetes-http)

<Vimeo vimeoId="539128158" />

<br />

Dans ce chapitre, nous allons voir comment **enchaÃ®ner** les requÃªtes HTTP en exÃ©cutant 2 requÃªtes GETÂ en mÃªme temps (en parallÃ¨le), puis 1
requÃªte POST une fois que les 2 requÃªtes prÃ©cÃ©dentes sont terminÃ©es (en sÃ©quence). Pour cela, nous allons avoir besoin des techniques
asynchrones vues au chapitre prÃ©cÃ©dent.

### EnchaÃ®nez des requÃªtes avec les callbacks

Voyons ensemble comment faire nos 2 requÃªtes **en parallÃ¨le**, suivies d'une requÃªte **en sÃ©quence** avec lesÂ callbacks. Et vous verrez, Ã§a
peut vite devenir complexe !

> Pour cet exemple, nous partons du principe que nous avons accÃ¨s Ã  2 fonctions (`get`Â et `post`). Elles font respectivement une requÃªte `GET`
et une requÃªte `POST`Â et elles prennent en paramÃ¨tre :
> - l'URL de la requÃªte,
> - une callback Ã  exÃ©cuter quand on a le rÃ©sultat (avec une variable d'erreur en premier paramÃ¨tre).

```javascript
var GETRequestCount = 0;
var GETRequestResults = [];
function onGETRequestDone(err, result) {
    if (err) throw err;
    GETRequestCount++;
    GETRequestResults.push(result);
    if (GETRequestCount == 2) {
        post(url3, function(err, result) {
            if (err) throw err;
            // We are done here !
        });
    }
}

get(url1, onGETRequestDone);
get(url2, onGETRequestDone);
```

Comme vous pouvez le voir, le code est assez particulier Ã  lire. Il yÂ aÂ d'autres faÃ§ons d'Ã©crire ce code, mais Ã§a reste une des faÃ§ons les plus
simples et rapides Ã  Ã©crire.

Afin d'exÃ©cuter 2 requÃªtes `GET`Â en mÃªme temps, nous pouvons appeler 2 fois la fonction `get()`. Ã‰tant donnÃ© que cette fonction est
**asynchrone**, elle ne bloquera pas l'exÃ©cution du code. Ainsi l'autre fonction `get()`Â sera aussi appelÃ©e alors que la premiÃ¨re ne sera pas
encore terminÃ©e. C'est comme Ã§a qu'on peut avoir 2 requÃªtes en parallÃ¨le.

Par contre, nous voulons exÃ©cuter une requÃªte `POST`Â une fois que les **2 requÃªtes `GET`Â sont terminÃ©es**, et pas avant ! Pour ce faire, nous
devons savoir si les requÃªtes `GET`Â sont terminÃ©es. C'est pour Ã§a que la variable `GETRequestCount`Â est crÃ©Ã©e. On va l'**incrÃ©menter** dans la
fonction _callback_ que l'on a envoyÃ©e aux appels Ã  `get()`, et si on atteint 2 (le nombre de requÃªtes `GET`Â qu'on a faites), alors on va
exÃ©cuter la requÃªte `POST`.

:::info
`GETRequestResults`Â sert Ã  conserver les rÃ©ponses des requÃªtes `GET`, car on ne les a pas toutes les 2 en mÃªme temps.
:::

### EnchaÃ®nez des requÃªtes avec les Promise

GrÃ¢ce Ã  la fonction `Promise.all`, voyons comment exÃ©cuter nos requÃªtes en parallÃ¨le et en sÃ©quence avec les `Promise`.

> Pour cet exemple, nous partons du principe que nous avons accÃ¨s Ã  2 fonctions (`get`Â et `post`) qui font respectivement une requÃªte `GET` et
une requÃªte `POST`Â quand on leur passe en paramÃ¨tre l'URL de la requÃªte. Ces fonctions retourneront une `Promise`Â avec le rÃ©sultat de la
requÃªte.

```javascript
Promise.all([get(url1), get(url2)])
    .then(function(results) {
        return Promise.all([results, post(url3)]];
    })
    .then(function(allResults) {
        // We are done here !
    });
```

Ici, nous utilisons la fonction `Promise.all`Â qui prend en paramÃ¨tre une liste de `Promise`Â (cela peut aussi Ãªtre de simples valeurs qui sont
alors transformÃ©es en `Promise`Â rÃ©solues), et qui permet de toutes les exÃ©cuter en parallÃ¨le et de retourner une nouvelle `Promise`Â qui sera
rÃ©solue quand toutes les `Promise`Â seront rÃ©solues.

Ainsi, la fonction `then()`Â recevra les rÃ©sultats de toutes les `Promise`Â sous forme d'un tableau.

Afin d'exÃ©cuter notre requÃªte `POST`Â une fois que les requÃªtes `GET`Â sont terminÃ©es, nous l'exÃ©cutons donc dans la fonction `then()`.

:::info
Notez que dans la fonction `then()`, nous faisons encore une fois appel Ã  la fonction `Promise.all`Â en lui passant les rÃ©sultats des requÃªtes
`GET`Â et notre requÃªte `POST`. Ã‰tant donnÃ© que `Promise.all` considÃ¨re les simples valeurs comme des `Promise` rÃ©solues, cela nous permet, dans
le prochain `then()`, de rÃ©cupÃ©rer une liste qui contient les rÃ©sultats des requÃªtes `GET`Â et le rÃ©sultat de la requÃªte `POST`Â :
`allResults = [ [ getResult1, getResult2 ], postResult ]`.
:::

### EnchaÃ®nez des requÃªtes avec async/await

Finalement, voyons comment exÃ©cuter le mÃªme code mais avec `async`Â / `await`.

> Pour cet exemple, nous partons du principe que nous avons accÃ¨s Ã  2 fonctions (`get`Â et `post`) qui font respectivement une requÃªte `GET` et
une requÃªte `POST`Â quand on leur passe en paramÃ¨tre l'URL de la requÃªte. Ces fonctions sont asynchrones (avec le mot clÃ© `async`).

```javascript
async function requests() {
    var getResults = await Promise.all([get(url1), get(url2)]);
    var postResult = await post(url3);
    return [getResults, postResult\];
}
requests().then(function(allResults) {
    // We are done here !
});
```

Nous utilisons aussi la fonction `Promise.all`Â dans ce code, car c'est comme Ã§a que l'on peut exÃ©cuter des fonctions asynchrones en parallÃ¨le
(rappelez-vous que `async`Â correspond en arriÃ¨re-plan Ã  une `Promise`).

Par contre, ici, nous utilisons `await`Â devant `Promise.all`Â afin d'attendre la fin de l'exÃ©cution des 2 requÃªtes `GET`, puis nous utilisons
`await`Â devant la requÃªte `POST`Â afin d'attendre son rÃ©sultat. Puis nous renvoyons un tableau avec tous les rÃ©sultats.

Lorsque nous appelons la fonction `requests()`, ici, nous utilisons `then()`Â pour rÃ©cupÃ©rer tous les rÃ©sultats (mais vous auriez aussi pu
utiliser `await`Â au sein d'une autre fonction avec le mot clÃ©Â `async`).

### En rÃ©sumÃ©

Dans ce chapitre, vous avez appris :
- Ã€ enchaÃ®ner des requÃªtes avec la mÃ©thode des callbacks ;
- Ã€ enchaÃ®ner des requÃªtes avec la mÃ©thode des `Promise`Â ;
- Ã€Â enchaÃ®ner des requÃªtes avec la mÃ©thode `async`Â / `await`.

_Vous connaissez maintenant 3 techniques pour exÃ©cuter du code asynchrone et vous savez les mettre en situation. Ã€ vous maintenant de vous
faire votre propre avis sur celle que vous prÃ©fÃ©rez utiliser. Il est temps maintenant de passer Ã  la prochaine partie oÃ¹ nous verrons comment
coder en JavaScript dans un environnement plus efficace.Â  ğŸ˜_

-----

## Quiz : ParallÃ©lisez vos longues tÃ¢ches avec la programmation asynchrone

[ParallÃ©lisez vos longues tÃ¢ches avec la programmation asynchrone - OpenClassrooms](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/exercises/3197)

#### CompÃ©tences Ã©valuÃ©es

<i class="bi bi-check2-circle"></i> Utiliser des mÃ©thodes asynchrones

-----

#### Question 1 : Que peut-on dire du langage JavaScript ?

<i class="bi bi-circle"></i> Qu'il est asynchrone et mono-thread<br />
<i class="bi bi-record-circle"></i> Qu'il est synchrone et mono-thread<br />
<i class="bi bi-circle"></i> Qu'il est asynchrone et multi-thread<br />
<i class="bi bi-circle"></i> Qu'il est synchrone et multi-thread<br />
<br />

*Le JavaScript est un langage synchrone et mono-thread. L'asynchrone se fait grÃ¢ce Ã  l'event loop en envoyant des fonctions dans sa file
d'attente.*

-----

#### Question 2 : Qu'est-ce que l'event loop ?

<i class="bi bi-record-circle"></i> Un gros tunnel mono-thread dans lequel sont empilÃ©es des fonctions qui vont Ãªtre exÃ©cutÃ©es les unes aprÃ¨s
les autres<br />
<i class="bi bi-circle"></i> Un gros tunnel multi-thread dans lequel les fonctions vont Ãªtre parallÃ©lisÃ©es pour Ãªtre exÃ©cutÃ©es de maniÃ¨re
asynchrone<br />
<i class="bi bi-circle"></i> Une simple boucle Â `for`Â  dans laquelle on exÃ©cute gÃ©nÃ©ralement des Ã©vÃ©nements<br />
<i class="bi bi-circle"></i> CelaÂ n'existe pas<br />
<br />

*On peut voir l'event loop comme Ã©tant un tunnel mono-thread dans lequel on va mettre en file d'attente des fonctions pourÂ dÃ©caler leur
exÃ©cution.*

-----

#### Question 3 : Quâ€™affiche cet extrait ?

```javascript
setTimeout(function() {
    console.log("Prems");
});
console.log("Deuz");
```

<i class="bi bi-circle"></i><code>Prems</code>, puis <code>Deuz</code><br />
<i class="bi bi-record-circle"></i><code>Deuz</code>, puis <code>Prems</code><br />
<br />

_`setTimeout` sert Ã  retarder l'exÃ©cution d'une fonction du temps indiquÃ©. Il va ajouter la fonction passÃ©e en paramÃ¨tre Ã  l'event loop, et
demander Ã  attendre un certain temps avant de l'exÃ©cuter. Si aucun temps nâ€™est passÃ© Ã  la fonction (comme dans notre exemple), alors notre
callback sera exÃ©cutÃ©e au prochain tour de lâ€™event loop, et donc aprÃ¨s `Deuz`._

-----

#### Question 4 : Qu'est-ce qu'uneÂ callback ?

<i class="bi bi-circle"></i> Une fonction qui va exÃ©cuter une autre fonction lorsqu'elle a terminÃ© ce qu'elle devait faire<br />
<i class="bi bi-record-circle"></i> Une fonction qui sera exÃ©cutÃ©e par une autre fonction lorsque cette derniÃ¨re aura terminÃ© ce qu'elle devait
faire<br />
<i class="bi bi-circle"></i> Une fonction qui va rÃ©cupÃ©rer toutes les informations de navigation d'un utilisateur<br />
<br />

*La diffÃ©rence est subtile : une callback est une fonction (appelons-laÂ `cb`) que l'on passe en paramÃ¨tre Ã  une autre fonction (appelons-la
`fn`). C'est `fn`Â qui va exÃ©cuter `cb`Â lorsqu'elle aura fini ce qu'elle doit faire.*

-----

#### Question 5 : Qu'est-ce qu'une `Promise`Â ?

<i class="bi bi-circle"></i> Une promesse que l'on ne tient jamais (comme toutes les promesses)<br />
<i class="bi bi-circle"></i> Un objet JavaScript qui n'aura jamais de valeur<br />
<i class="bi bi-record-circle"></i> Un objet JavaScript dÃ©diÃ© aux traitements asynchrones<br />
<i class="bi bi-circle"></i> Une fonction quiÂ promet d'exÃ©cuter du code dans un dÃ©lai imparti<br />
<br />

_Une `Promise` est un objet JavaScript utilisÃ© pour rÃ©aliser des traitements asynchrones tels que des appels API (GET, POST, etc.). Elle
dispose de plusieurs statuts :_
- _"pending". La requÃªte est en train dâ€™Ãªtre rÃ©alisÃ©e._
- _"resolve". La requÃªte a Ã©tÃ© rÃ©alisÃ©e et aucune erreur nâ€™a eu lieu. La fonction `then()` est appelÃ©e._
- _"reject". Une erreur est survenue et le traitement asynchrone a Ã©chouÃ©. La fonction `catch()` est appelÃ©e._

-----

#### Question 6 : Quâ€™affiche ce code ?

```javascript
async function num1() { return 42; }
async function num2() { return Promise.resolve(3); }

async function compute() {
    const n1 = await num1();
    const n2 = await num2();
    return n1 + n2;
}

compute()
    .then(function(res) {
        console.log(res);
    })
    .catch(function() {
        console.log(â€œErreurâ€);
});
```

<i class="bi bi-record-circle"></i> 45<br />
<i class="bi bi-circle"></i> Une <i>Promise</i><br />
<i class="bi bi-circle"></i> "Erreur"<br />
<br />

_`async` et `await` sont des mots clÃ©s du langage JavaScript qui permettent de crÃ©er du code asynchrone qui utilisera les `Promise` en
arriÃ¨re-plan. Dans notre exemple, la fonction `compute` rÃ©cupÃ¨re le rÃ©sultat des fonctions `num1` et `num2` en attendant que leur `Promise`
soit rÃ©solue (ce qui est immÃ©diatement le cas de nos 2 fonctions car lâ€™une renvoie directement une valeur numÃ©rique, et lâ€™autre utilise
`Promise.resolve()` qui indique que la `Promise` est rÃ©solue)._

_`compute` renvoie donc une `Promise` qui vaudra 45. Lorsquâ€™on lâ€™appelle, ici, on utilise la fonction `then()` car `async` et `await` sont des
`Promise` en arriÃ¨re-plan, et on affiche le rÃ©sultat (45) dans la console._

-----

#### Question 7 : Sachant que promise1 sera rÃ©solue avec la valeur "Salut", et que promise2 sera rÃ©solue avec "toi", quâ€™affiche cet extraitÂ ?

```javascript
Promise.all([promise1, promise2])
.then(function(values) {
    console.log(values.join(" "));
});
```

<i class="bi bi-circle"></i> ["Salut", "toi"]<br />
<i class="bi bi-record-circle"></i> "Salut toi"<br />
<i class="bi bi-circle"></i> "Salut"<br />
<i class="bi bi-circle"></i> "toi"<br />
<br />

_`Promise.all` prend en paramÃ¨tre une liste de `Promise` et retourne une nouvelle `Promise` qui sera rÃ©solue une fois que toutes les `Promise`
seront rÃ©solues. Cette `Promise`Â contiendra le rÃ©sultat de toutes les `Promise`Â sous forme de liste et en conservant lâ€™ordre dans la fonction
`all()`. Ainsi, notre code affichera "Salut toi"._

-----

#### Question 8 : Que fait cet extrait ?

```javascript
setInterval(callback, 1000);
```

<i class="bi bi-circle"></i> Il exÃ©cute la callback au bout de 1 seconde<br />
<i class="bi bi-circle"></i> Il exÃ©cute la callback au bout de 1Â 000 secondes<br />
<i class="bi bi-record-circle"></i> Il exÃ©cute la callback toutes les 1 seconde<br />
<i class="bi bi-circle"></i> Il exÃ©cute la callback toutes les 1Â 000 secondes<br />
<br />

_`setInterval` permet d'exÃ©cuter une fonction de callback toutes les X ms. La fonction prend le dÃ©lai en millisecondes et non en secondes._

-----

#### Question 9 : Que fait ce code et que contient la variable `promiseRes` ?

**(Dans cet extrait nous utilisons la fonction `reduce` . Elle permet de parcourir une liste et de la rÃ©duire Ã  une seule valeurÂ :
lâ€™accumulateur. Pour en savoir plus, nâ€™hÃ©sitez pas Ã  aller faire un tour sur la [documentation de la fonction](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)).**

```javascript
async function func1() {
    return 3;
}

async function func2() {
    return 4;
}

var promiseRes =
    Promise
        .all([func1(), func2()])
        .then(function(results) {
            return results.reduce(function(acc, res) {
                return acc * res;
            }, 2);
        })
        .then(function(time) {
            return setTimeout(callback, time * 1000);
        });
```

<i class="bi bi-record-circle"></i><code>promiseRes</code>Â vautÂ une promesse rÃ©solue avec l'identifiant de la fonction <code>setTimeout</code>,
et la callback est appelÃ©e aprÃ¨s 24Â secondes<br />
<i class="bi bi-circle"></i><code>promiseRes</code>Â vaut un identifiant de <code>setTimeout</code>, et la callback est appelÃ©e aprÃ¨s 12Â secondes<br />
<i class="bi bi-circle"></i><code>promiseRes</code>Â vaut un identifiant de <code>setTimeout</code>, et la callback est appelÃ©e aprÃ¨sÂ 24 secondes<br />
<i class="bi bi-circle"></i><code>promiseRes</code>Â vaut une promesse rÃ©solue avec l'identifiant de la fonction <code>setTimeout</code>, et la
callback est appelÃ©e aprÃ¨s 12Â secondes<br />
<br />

_Ici nous exÃ©cutons 2 fonctions asynchrones en parallÃ¨le avec `Promise.all`. La premiÃ¨re fonction `then()`Â va appeler `reduce`Â sur la liste de
rÃ©sultats (3, et 4) et multiplier les valeurs entre elles avec une valeur initiale de 2, soitÂ : `2 * 3 * 4 = 24`._

_Le rÃ©sultat est passÃ© Ã  la prochaine fonction `then()`, qui va appeler une callback aprÃ¨s `time`Â secondes, `time`Â correspondant ici Ã  24, le
rÃ©sultat du prÃ©cÃ©dent `then()`._

_Enfin, on retourne le rÃ©sultat de la fonction `setTimeout()`, `promiseRes`Â contient donc une `Promise`Â qui sera rÃ©solue avec l'identifiant de
la fonction `setTimeout`Â retournÃ©._
