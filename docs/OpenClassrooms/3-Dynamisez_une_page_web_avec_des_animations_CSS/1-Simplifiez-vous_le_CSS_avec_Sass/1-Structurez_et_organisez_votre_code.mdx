---
sidebar_position: 2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# Structurez et organisez votre code 

## Tirez un maximum de ce cours

[Tirez un maximum de ce cours - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6595338-tirez-un-maximum-de-ce-cours)

<Vimeo vimeoId="534082067" />

<br />

Le meilleur moyen de tirer le meilleur parti de ce cours est de :
- regarder chaque **vidÃ©o** pour comprendre pourquoi les concepts abordÃ©s dans chaque chapitre sont importants ;
- lire le **texte** sous la vidÃ©o pour apprendre comment appliquer les concepts abordÃ©s ;
- pratiquer au fur et Ã  mesure grÃ¢ce aux **exercices interactifs** ;
- tester votre comprÃ©hension des concepts clÃ©s grÃ¢ce aux **quiz**Â Ã  chaque fin de section.

### Rencontrez votre professeur !

#### Kassandre Pedro

![Kassandre Pedro](https://user.oc-static.com/upload/2019/10/24/15719062754123_saas_auteur.png)

Kassandre Pedro

Kassandre a fait des Ã©tudes de langues (CorÃ©en) avant de faire partie de la deuxiÃ¨me promotion de 42 Paris en 2014. Elle nâ€™a
cessÃ© de coder depuis ! Elle a travaillÃ© dans plusieurs startups avant d'atterrir chez GitHub en 2018.

Elle a fui la grisaille parisienne pour sâ€™installer au plus prÃ¨s des montagnes et de lâ€™ocÃ©an,Â au Pays basque, afin de pouvoir
sâ€™adonner Ã  sa deuxiÃ¨me passionÂ : les sports de glisse.

Kassandre a su allier ses deux passions et a lancÃ© Seacher en 2018,Â  avec deux amis. Seacher est un outil de gestion alliÃ© Ã  une
plateforme de rÃ©servation pour les sports de glisse tels que le surf, le snowboard ou le ski.

Ayant une appÃ©tence forte pour lâ€™Ã©ducation, elle est aussi freelance au sein de structures comme WILLA ou Iron Hack sur son temps
libre, pour transmettre sa passion et son expÃ©rience.

-----

## Structurez votre CSS

[Structurez votre CSS - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6595695-structurez-votre-css)

<Vimeo vimeoId="534110004" />

<br />

### DÃ©couvrez pourquoi Ã©crire du code bien structurÃ©

Ã‰crire du **CSS dÃ©sordonnÃ©**, de nombreux dÃ©veloppeurs lâ€™ont fait ! On ne commence pas forcÃ©ment Ã  Ã©crire du CSS de maniÃ¨re
dÃ©sordonnÃ©e. Il sâ€™agit plutÃ´t dâ€™un processus progressif qui se met en place Ã  mesure que lâ€™on fait de nouveaux changements, comme
commencer par Ã©crire du CSS directement dans le HTML. Et, Ã  moins dâ€™Ãªtre prÃ©voyant et vigilant, vous allez finir avec une codebase
CSS chaotique sans vraiment rÃ©aliser comment vous en Ãªtes arrivÃ© lÃ .

:::info
On appelle ici codebase lâ€™ensemble du code source que vous allez Ã©crire.
:::

:::note ?
Est-ce que câ€™est vraiment embÃªtant ? Tant que je finis mon projet, quel est le problÃ¨me ? ğŸ™„
:::

Pour rÃ©pondre Ã  cette question, suivons ensemble le cours de la vie dâ€™un site web de maniÃ¨re hypothÃ©tique.

Un client vous charge de crÃ©er un **formulaire de contact** comprenant quelques cases de texte et un bouton. Vous Ã©crivez le HTML
et le CSS, en assignant le nom de classe btn au bouton qui possÃ¨de lâ€™**ensemble des rÃ¨gles**, ou groupe dâ€™instructions CSS,
suivant :

```css
.btn {
    background-color: #001534;
    color: #15DEA5;
    border-radius: 3rem;
    width: 100%;
    padding: 1.5rem;
}
```

Tout cela a lâ€™air plutÃ´t pas mal et le client est content ! Tellement content quâ€™il vous demande de travailler sur le reste du
site. Tout Ã  coup, vous vous retrouvez Ã  avoir besoin de toute une sÃ©rie de boutons de diffÃ©rentes tailles, couleurs et formes.
Mais le problÃ¨me, câ€™est que `.btn`Â est trÃ¨s **spÃ©cifique** : il a ses propres taille, couleur et dimension. Et malheureusement,
cela ne convient pas aux nouveaux boutons. Vous allez donc devoir crÃ©er de nouveaux boutons avec leurs propres rÃ¨gles et vous
retrouver avec des classes telles que `.btn-alt`,Â `.btn-big`Â etÂ `.btn-round`. Plus tard, vous avez besoin encore dâ€™autres boutons,
et comme vos boutons sont eux aussi spÃ©cifiques, vous ajoutezÂ `.btn-small`Â etÂ `.btn-alt-2`. Vous commencez Ã  voir le problÃ¨me ?
Plus vous allez avoir des boutons spÃ©cifiques, plus vous allez en crÃ©er, et ainsi de suite. Avec le temps,Â vous allez avoir un
trop grand nombre de sÃ©lecteurs pour vous souvenir de lâ€™utilitÃ© de chacun.

:::note ?
OK, mais je peux juste aller changer tous les noms manuellement si besoin, non ? Il nâ€™y en a pas tant que Ã§a pour le moment, et
si le client est content, quâ€™est-ce que Ã§a peut bien faire ?
:::

OK, câ€™est vrai, le site a une bonne tÃªte et le client est encore plus content... pour le moment !Â Quelques mois passent et un
beau jour votre client vous recontacte car il a besoin de modifier certains Ã©lÃ©ments prÃ©cis, dâ€™ajouter des choses, et vous devez
vous replonger dans votre code. Et câ€™est alors que vous commencez Ã  vous demander : Ã  quoi ressemble `.btn-alt`, dÃ©jÃ  ? Et câ€™est
quoi la diffÃ©rence avec `.btn-alt-2`Â ? Et quelle est _rÃ©ellement_ la taille de`.btn-big`Â ? Et pourquoi est-ce que jâ€™ai fait Ã§a ? ğŸ˜­

PlutÃ´t que dâ€™effectuer vos changements rapidement et facilement, vous vous retrouvez Ã  **passer beaucoup trop de temps** Ã  dÃ©mÃªler
le plat de spaghettis quâ€™est devenu votre CSS. Mais alors, comment faire pour garder le fil entre vos diffÃ©rents Ã©lÃ©ments, et
surtout dans un projet de grande envergure ? Comment gÃ©rer et se retrouver dans un CSS oÃ¹ vous faites sans cesse des ajouts et des
modifications ?

Câ€™est bien connu, le CSS est compliquÃ© Ã  maintenir en ordre. Il lui **manque beaucoup de structure**, structure que lâ€™on retrouve
dans la plupart des autres langages de programmation. Ã‡a se voit rien quâ€™en comparant des extraits de code en **HTML** et en **CSS** :
jetez un Å“il au code ci-dessous ğŸ‘‡ğŸ¼

#### **HTML**

```html
<body>
  <main class="container">
      <form class="form">
        <h1 class="form__heading">Contact me</h1>
        <div class="form__field">
            <label for="contact-name">name</label>
            <input type="text" name="contact-name" id="contact-name">
        </div>
        <div class="form__field">
            <label for="contact-email">email</label>
            <input type="email" name="contact-email" id="contact-email">
        </div>
        <div class="form__field">
            <label for="mssg">message</label>
            <textarea name="mssg" id="mssg" cols="30" rows="10"></textarea>
        </div>
        <button class="btn btn--full-width">Submit</button>
      </form>
  </main>
</body>
```

#### Â **CSS**

```css
.container {
  margin: 6rem;
  padding: 1.5rem 1.5rem 0 1.5rem;
  border: 0.1rem solid #D6FFF5; }
}

.form {
  width: 100%;
  padding-bottom: 1.5rem;
}

.form__field label {
  color: #D6FFF5;
  display: block;
  font-size: 2rem;
  line-height: 2rem;
  padding-top: 1.5rem;
}

.form__field input {
  width: 100%;
  background: #001534;
  border: 0.1rem solid #15DEA5;
  padding: 1.5rem;
  color: #D6FFF5;
}
```

Avez-vous remarquÃ© la faÃ§on dont on voit tout de suite que les **Ã©lÃ©ments HTML** sont reliÃ©s entre eux par leur structure ? Alors
que le CSS, lui, ressemble plutÃ´t Ã  une longue liste qui Ã©numÃ¨re un tas de rÃ¨gles les unes aprÃ¨s les autres, sans aucun lien
logique visible. Il nâ€™y a pas grand-chose pour indiquer les relations entre les **sÃ©lecteurs**, ni leur **spÃ©cificitÃ©**. Maintenir
de lâ€™ordre quand il nâ€™y a pas beaucoup de structure visible, câ€™est encore plus compliquÃ©. Mais pas de souci, nous allons remÃ©dier
Ã  cela. ğŸ’ª

:::info
Petit rappel : les **sÃ©lecteurs** CSS dÃ©terminent Ã  quels Ã©lÃ©ments sâ€™applique un ensemble de rÃ¨gles donnÃ©es. La **spÃ©cificitÃ©**
mesure Ã  quel point un sÃ©lecteur est _spÃ©cifique_... Pas de panique, nous aborderons cela de plus prÃ¨s au cours de ce chapitre...
:::

Dans ce cours, vous allez apprendre comment Ã©crire du CSS qui est Ã  la fois mieux **organisÃ© et surtout maintenable**, en :
- appliquant des **structures de fichiers** clairement dÃ©finies ;
- travaillant avec un **prÃ©processeur CSS** appelÃ© **Sass**, une technologie qui amÃ©liore votre codebase et vous simplifie la vie.

Votre vous du futur vous dit â€œmerci !â€ ğŸ˜‰

### Appliquez le principe du DRY

Mais alors, comment procÃ©der pour vous assurer que le CSS que vous Ã©crivez est propre et maintenable ? La premiÃ¨re Ã©tape est de
**trouver des points communs**. Pour cela, reprenons lâ€™exemple de code CSS donnÃ© ci-dessus :

```css
.container {
    margin: 6rem;
    padding: 1.5rem 1.5rem 0 1.5rem;
    border: 0.1rem solid #D6FFF5; }
}

.form {
    width: 100%;
    padding-bottom: 1.5rem;
}

.form__field label {
    color: #D6FFF5;
    display: block;
    font-size: 2rem;
    line-height: 2rem;
    padding-top: 1.5rem;
}

.form__field input {
    width: 100%;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    padding: 1.5rem;
    color: #D6FFF5;
}
```

Regardez :Â on voit quelques rÃ¨gles qui se rÃ©pÃ¨tent.

![Image montrant les endroits oÃ¹ le code se rÃ©pÃ¨te.](https://user.oc-static.com/upload/2019/10/09/15706160075006_image6.png)

Le code se rÃ©pÃ¨te Ã  certains endroits

Par exemple, vous avez plusieurs boutons que vous utilisez dans votre codebase. Tous vos boutons utilisent le mÃªme _padding_ et
la mÃªme _couleur de texte_, et quasiment tous ont la mÃªme couleur de fond. Cela signifie que vous avez dupliquÃ© votre code.

Il existe un concept dans la programmation appelÃ© le **principe DRY**, qui est une abrÃ©viation en anglaisÂ signifiant
â€œ**Donâ€™t repeat yourself**â€.

Et en franÃ§ais, sâ€™il vous plaÃ®t ? ğŸ¤”

**â€œNe vous rÃ©pÃ©tez pas !â€**

Toutes ces couches de rÃ¨gles CSS rÃ©pÃ©titives dans votre code, comme les copier-coller de couleur, de taille et autre, vous
empÃªchent de crÃ©er une codebase **DRY**, la rendent encore plus difficile Ã  maintenir et compliquent sa modification.Â 

:::note ?
Bon, mais je fais quoi du coup, concrÃ¨tement ? ğŸ¤”
:::

La premiÃ¨re Ã©tape clÃ© consiste Ã  faire un **refactoring** ; en dâ€™autres termes, effectuez un grand mÃ©nage dans votre code pour
Ã©viter les rÃ©pÃ©titions. Rappelez-vous : â€œ**Ne vous rÃ©pÃ©tez pas !**â€. CommenÃ§ons par passer en revue tous vos sÃ©lecteurs pour
trouver des points communs. Prenons lâ€™exemple dâ€™un bouton. Il faut regarder tous les boutons dÃ©crits dans le code et noter
quelles rÃ¨gles sont identiques. Disons que vous remarquez que tous vos boutons ont la mÃªme couleur de fond, la mÃªme couleur et
le mÃªme padding. Au lieu de placer tous ces attributs dans chacun de vos boutons, vous allez les rÃ©unir au mÃªme endroit et Ã©viter
de vous rÃ©pÃ©ter. Vous obtiendrez quelque chose qui ressemble Ã  :

```css
.btn {
    background-color: #001534;
    color: #15DEA5;
    padding: 1.5rem;
}
```

Avec ce code, sans rÃ¨gles supplÃ©mentaires, le bouton aura la largeur de son contenu, plus le padding. Et les coins seront carrÃ©s !
Vous avez donc un bouton gÃ©nÃ©rique que vous pouvez utiliser autant de fois que vous le voulez sans ajout de code et surtout sans
rÃ©pÃ©tition. Parfait, non ?

:::note ?
Et si jâ€™ai un bouton qui doit Ãªtre plus large ou plus arrondi, je fais quoi ? ğŸ¤”
:::

Pas de panique, vous pouvez crÃ©er des **rÃ¨gles** **additionnelles** au `.btn`Â original, qui seront rÃ©parties dans de nouveaux
sÃ©lecteurs plus spÃ©cifiques :

```css
.btn-wide {
    width: 100%;
}

/* And... */
.btn-rounded {
    border-radius: 3rem;
}
```

Donc en HTML, au lieu de ressembler Ã  Ã§a :

```html
<button class="btn">...</button>
```

votre **markup** ressemble Ã  Ã§a :

```html
<button class="btn btn-rounded btn-wide">...</button>
```

:::info
**_Markup_** est parfois utilisÃ© comme une forme abrÃ©gÃ©e pour dire _HTML_, qui signifieÂ _**Hyper Text Markup Language**_.
:::

Ce que nous venons de faire sâ€™appelle _**separation of concerns**_ (ou _sÃ©paration des prÃ©occupations_). Lâ€™idÃ©e est que votre HTML
ne contient que les informations nÃ©cessaires Ã  son contenu. Ainsi, toutes vos rÃ¨gles de style sont dÃ©finies dans votre fichier CSS
et sont rÃ©utilisables. Fini le CSS en dur dans le HTML ! Dans notre exemple de bouton .btn, nous avons dÃ©fini lâ€™apparence de nos
boutons et rien de plus.

:::info
**Un sÃ©lecteur est un ensemble de rÃ¨gles de base**.
:::

Chaque bouton dans votre code aura les qualitÃ©s dÃ©finies dans le sÃ©lecteur. Ensuite, pour ajouter des rÃ¨gles supplÃ©mentaires,
nous crÃ©ons les **sÃ©lecteurs** dans `.btn-wide`Â et `.btn-rounded`Â qui modifieront notre bouton de base `.btn`.

```css
.btn {
    background-color: #001534;
    color: #15DEA5;
    padding: 1.5rem;
}

.btn-wide {
    width: 100%;
}

/* And... */
.btn-rounded {
    border-radius: 3rem;
}
```

Ensuite, lorsquâ€™on les ajoute les uns aprÃ¨s les autres dans notre markup, nous disons que lâ€™on utilise `.btn`Â puis que lâ€™on
appliqueÂ `.btn-rounded`Â et enfin `.btn-wide`.

```html
<button class="btn btn-rounded btn-wide">...</button>
```

Ainsi, en regroupant vos classes et en les sÃ©parant par leur fonction, votre codebase devient instantanÃ©ment **plus facile Ã 
maintenir**. PlutÃ´t que de recourir Ã  Ctrl+F et _Chercher-remplacer_ pour modifier le padding de l'ensemble de vos boutons
spÃ©cifiques, il vous suffit de changer la valeur dâ€™un seul ensemble de rÃ¨gles, ici `.btn`, et la modification se rÃ©percutera dans
tous les `.btn`Â de votre site.

```css
.btn {
    background-color: #001534;
    color: #15DEA5;
    padding: 1.5rem;
}
```

Une fois de plus, votre futurÂ vous vous fait part de toute sa gratitude.Â  ğŸ™Œ

#### **Essayez par vous-mÃªme !**

**![](https://user.oc-static.com/upload/2021/04/14/16183908793229_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, vous allez vous entraÃ®ner en crÃ©ant une nouvelle classe et en sÃ©parant les propriÃ©tÃ©s typographiques pour les
appliquer indÃ©pendamment sur la div de votre choix.

:::caution !
Comment utiliser ces exercices interactifs ?

Pour vous permettre de pratiquer, je vous ai crÃ©Ã© des exercices interactifs.<br />
Lâ€™Ã©cran de votre exercice est divisÃ© en deux parties.<br />
Ã€ gauche, se trouvent les instructions et les Ã©tapes Ã  suivre. Attention, les Ã©tapes reprÃ©sentent une check-list. Cela signifie
que le fait quâ€™un Â« v Â» vert apparaisse ne veut pas dire que lâ€™Ã©tape est rÃ©ussie mais que vous indiquez avoir fait cette Ã©tape.

Ã€ droite, se trouve le code que vous devez modifier pour faire lâ€™exercice.
:::

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/910B19169CF8001FBBBC495527F59D97" width="100%" height="500" frameborder="0"></iframe>

:::info
Avez-vousÂ essayÃ© l'exercice ? [Comparez votre travail avec cette correction](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-1/chapitre-2%2Fexercice-1).
:::

### Lâ€™impact de la spÃ©cificitÃ© sur la structure de votre code

Vous savez maintenant _pourquoi_ il est important de structurer votre code, mais pour le faire efficacement, vous devez comprendre
un concept fondamental, la **spÃ©cificitÃ©**.

#### **Quâ€™est-ce que la spÃ©cificitÃ© ?**

Si on prend la dÃ©finition de la [documentation MDN](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#Specificity),
on obtient :

> _**La spÃ©cificitÃ©**_ _est la maniÃ¨re dont le navigateur dÃ©cide quelle rÃ¨gle sâ€™applique si plusieurs rÃ¨gles ont des sÃ©lecteurs
diffÃ©rents, mais peuvent quand mÃªme sâ€™appliquer au mÃªme Ã©lÃ©ment._

En dâ€™autres termes, la spÃ©cificitÃ© permet **dâ€™attribuer** un **score** Ã  un sÃ©lecteur afin de dÃ©terminer lequel a le plus de
valeur par rapport Ã  un autre au sein du HTML, et permet donc de dÃ©terminer la **prioritÃ©** dâ€™un sÃ©lecteur par rapport Ã  un autre.
Câ€™est comme un systÃ¨me de scores : celui qui a le plus de points gagne ! ğŸ‘©â€ğŸ­

:::info
[MDN](https://developer.mozilla.org/en-US/), ou _Mozilla Developer Network_, est un site hÃ©bergÃ© par la fondation Mozilla qui
contient beaucoup de documentation et notamment celle des standards HTML, CSS ou JavaScript.
:::

:::note ?
Euh... au secours ? **ğŸ˜¶**
:::

Pas de panique, on va y aller ensemble Ã©tape par Ã©tape ! Prenons un exemple pour illustrer. Disons que vous avez un Ã©lÃ©ment bouton
dont lâ€™id est `submit-button`Â et la classe est `.button`Â :

##### **HTML**

Nous avons trois sÃ©lecteurs : une div, un id `#submit-button`Â et une classe `.button`

```html
<div id="submit-button" class="button">Click Here!</div>
```

Travaillons avec `#submit-button`Â etÂ `.button`. Dans votre fichier CSS, `#submit-button`Â etÂ `.button`Â ont une couleur de fond
diffÃ©rente car vous utilisez la classe `.button`Â autre part dans votre code :

#####  **CSS**

```css
#submit-button {
    background-color: #15DEA5;
}

.button {
    background-color: #DB464B;
}
```

Du coup dans ce cas lÃ , quand vous voyez votre bouton dans un navigateur, de quelle couleur sera-t-il ? ğŸ¤”

La rÃ©ponse se trouve dans la **spÃ©cificitÃ©** de chaque sÃ©lecteur. Quand des rÃ¨gles contradictoires sâ€™appliquent Ã  un Ã©lÃ©ment,
comme dans notre exemple avec plusieurs couleurs de fond en mÃªme temps, le navigateur appliquera la rÃ¨gle Ã©manant du sÃ©lecteur
**le plus spÃ©cifique**.

:::note ?
Mais comment un navigateur dÃ©termine-t-il la spÃ©cificitÃ© dâ€™un sÃ©lecteur ?
:::

Regardons cela de plus prÃ¨s !

#### **DÃ©couvrez les quatre piliers de la spÃ©cificitÃ©**

Un navigateur distingue quatre catÃ©gories de rÃ¨gles CSS.

##### **1) Le style inline, dÃ©fini directement dans le HTML**

Lorsque vous Ã©crivez du CSS dans du HTML, câ€™est ce quâ€™on appelle du _style inline_.

```html
<div style="background-color:#15DEA5;">Click Here!</div>
```

##### **2) LesÂ id**

Les id sont uniques et sâ€™appliquent Ã  un object unique. Vous ne pouvez pas utiliser plusieurs fois un id dans votre HTML.

```html
<style> #submit-button { background-color: #15DEA5; } </style>
<div id="submit-button">Click Here!</div>
```

##### **3) Les classes, pseudoclasses et attributs**

Une **pseudoclasse** est un mot clÃ© ajoutÃ© Ã  un sÃ©lecteur qui permet de **spÃ©cifier un Ã©tat** comme `:hover`, par exemple, qui
indique que lâ€™on passe la souris au-dessus du sÃ©lecteur. Les attributs permettent de sÃ©lectionner un sÃ©lecteur prÃ©cis.

```html
<style> .button { background-color: #DB464B; } </style>
<div class="button">Click Here!</div>
```

##### **4) Les Ã©lÃ©ments et pseudoÃ©lÃ©ments**

```html
<style> div { background-color: #DB464B; } </style>
<div>Click Here!</div>
```

Quand le navigateur dÃ©termine quelle rÃ¨gle appliquer parmi celles contradictoires comme dans notre cas, il fait le compte du
nombre de catÃ©gories qui sont implÃ©mentÃ©es par un sÃ©lecteur. Nous allons reprÃ©senter la spÃ©cificitÃ© avec un **tableau** qui
rÃ©pertorie les types de sÃ©lecteurs sous forme de tableau de scores, afin que vous compreniez comment le navigateur procÃ¨de.

Dans notre exemple, nos trois sÃ©lecteurs seraient donc pris en compte comme suit.

##### SÃ©lecteur 1

#submit-button {...} :

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | **1** | 0 | 0 |

##### SÃ©lecteur 2

.button {...} :

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | **1** | 0 |

##### SÃ©lecteur 3

div {...} :

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | 0 | **1** |

Une fois cette comptabilisation effectuÃ©e, le navigateur commence par regarder les scores des sÃ©lecteurs dans la **colonne de
gauche**, parce que **le CSS local (dans le HTML, inline) est plus spÃ©cifique**. Sâ€™il y trouve un sÃ©lecteur avec un score plus
Ã©levÃ© que les autres dans la premiÃ¨re colonne, le navigateur appliquera son style en prioritÃ©. En cas dâ€™Ã©galitÃ©, il passe Ã  la
colonne suivante et effectue la mÃªme opÃ©ration.

Dans le cas de nos trois sÃ©lecteurs, la premiÃ¨re colonne est Ã  0 pour les 3Â sÃ©lecteurs. Aucun dâ€™entre eux nâ€™a de CSS implÃ©mentÃ©
localement dans le HTML. Câ€™est pour cette raison quâ€™ils ont tous un score de zÃ©ro. Le navigateur passe donc Ã  la colonne suivante,
la colonne ID, oÃ¹ un gagnant se dÃ©gage clairement : #submit-button a un score Ã©gal Ã  1, alors que les autres ont zÃ©ro. Le
navigateur appliquera lâ€™ensemble de rÃ¨gles deÂ #submit-buttonÂ  pour la couleur de fond.

:::note ?
Mais alors, que se passerait-il si on ajoutait une deuxiÃ¨me classe au sÃ©lecteur bouton ?
:::

##### **HTML & CSS**

```html
<style>
.button.submit-button { background-color: #DB464B; }
</style>
<div class="button submit-button">Click Here!</div>
```

:::info
Pour les besoins de lâ€™exercice et afin que les changements soient plus faciles Ã  visualiser, jâ€™ai mis le CSS entre des crochets
`<style>`Â en haut de notre fichier HTML, mais je vous encourage fortement Ã  **utiliser des fichiers HTML et CSS sÃ©parÃ©s**.
:::

Cela modifierait sa spÃ©cificitÃ©, qui deviendrait :

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | **2** | 0 |

Bien quâ€™il pourrait sembler que le nouveau sÃ©lecteur Ã  double classe `.button.submit-button`Â soit plus spÃ©cifique, il nâ€™est
toujours pas au niveau de `#submit-button`. Souvenez-vous, **le navigateur travaille de gauche Ã  droite**, et puisque
`#submit-button`Â a un score plus Ã©levÃ© dans la colonne ID, le navigateur nâ€™ira pas plus loin. Peu importe quâ€™un sÃ©lecteur ait
deux classes ou 200, un sÃ©lecteur id sera toujours plus spÃ©cifique quâ€™une classe.

:::info
Notez quâ€™il nâ€™y a **pas dâ€™espace** entre les noms des classes dans le sÃ©lecteur CSS, contrairement au HTML. Ceci indique au
navigateur quâ€™un Ã©lÃ©ment doit contenir **toutes** les rÃ¨gles du sÃ©lecteur pour Ãªtre applicable.
:::

:::note ?
Un rÃ©sumÃ© sâ€™il vous plaÃ®t ! Câ€™est trop long ! ğŸ˜±
:::

Si vous ajoutiez un **espace** entre les classes dans le CSS, le sÃ©lecteur jouerait le rÃ´le dâ€™un **combinateur descendant**. Cela
voudrait dire que lâ€™ensemble de rÃ¨gles ne sâ€™appliquerait quâ€™aux Ã©lÃ©ments auxquels a Ã©tÃ© assignÃ©e la deuxiÃ¨me classe, qui seraient
les enfants dâ€™un Ã©lÃ©ment auquel a Ã©tÃ© assignÃ© la premiÃ¨re classe. Puisque nous essayons de crÃ©er un sÃ©lecteur pour un div qui
contient les deux sÃ©lecteurs, nous devons faire attention quâ€™il nâ€™y ait pas dâ€™espaces. ğŸ˜

:::note 
Et si on veut vraiment utiliser la couleur de la classe `.submit-button`Â ?
:::

Au lieu dâ€™une deuxiÃ¨me classe, vous pourriez aussi y ajouter lâ€™id :

##### **HTML & CSS**

```html
<style>
    #submit-button {background-color: #15DEA5;}
    #submit-button.button { background-color: #DB464B;}
</style>
<div id="submit-button" class="button">
Click Here!
</div>
```

Ce qui vous donne :

**#submit-button {...}** 

| Inline | IDÂ | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | **1** | 0 | 0 |

**#submit-button.button {...}** 

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | **1** | **1** | 0 |

Maintenant il y a Ã©galitÃ© dans la colonne ID, le navigateur passe donc Ã  la colonne classe, oÃ¹ `.button`Â lâ€™emporte 1-0. Le
navigateur applique donc sa couleur de fond au bouton.

:::caution !
En rÃ¨gle gÃ©nÃ©rale, **Ã©vitez dâ€™utiliser des id dans vos sÃ©lecteurs**. Votre but est dâ€™Ã©crire du code rÃ©utilisable, les id sont
utilisÃ©s dans le cas de **valeurs uniques**. En consÃ©quence, tous les sÃ©lecteurs qui les utilisent ne peuvent, par dÃ©finition,
Ãªtre utilisÃ©s quâ€™une fois.
:::

Les id sont difficiles Ã  outrepasser puisquâ€™ils ont une spÃ©cificitÃ© plus importante. Sauf que vous voulez Ã©crire du code propre
et maintenable, alors comment faire ? Eh bien, en vous focalisant principalement sur les **sÃ©lecteurs de classe**, vous ferez en
sorte quâ€™ils aient une **spÃ©cificitÃ© plus basse**, ce qui les rendra plus aisÃ©s Ã  contourner proprement.

Comme vous allez le voir dans le prochain chapitre, vous aurez souvent besoin dâ€™**outrepasser** certains attributs Ã  lâ€™aide dâ€™un
autre sÃ©lecteur, plutÃ´t que dâ€™Ã©crire une longue liste de sÃ©lecteurs spÃ©cifiques. Cela contribuera Ã  rendre votre code plus
**modulaire et rÃ©utilisable**.

:::note ?
Du coup, que se passe-t-il si le navigateur passe en revue toutes les colonnes et arrive Ã  un match nul ?
:::

#### **Battle royale : la spÃ©cificitÃ© en cas dâ€™Ã©galitÃ©**

Changez lâ€™id #submit-button par la classe .submit et le CSS comme suit : ğŸ‘‡ğŸ¼

##### **HTML & CSS**

```html
<style>
    .submit {background-color: #15DEA5;}
    .button { background-color: #DB464B;}
    </style>
<div class="button submit">
Cliquez ici!
</div>
```

`.submit`Â et `.button`Â ont tous deux le mÃªme score.

**.button {...}** 

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | **1** | 0 |

**.submit {...}** 

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | **1** | 0 |

Alors, quel sÃ©lecteur lâ€™emporte ?

En cas dâ€™Ã©galitÃ©, le navigateur sÃ©lectionne le **dernier sÃ©lecteur** Ã  avoir Ã©tÃ© dÃ©clarÃ©, dans notre casÂ `.button`.

![Image reprÃ©sentant un bouton cliquez ici rouge](https://user.oc-static.com/upload/2019/10/09/15706234062941_image7.png)

La couleur Rouge l'emporte

`.button`Â lâ€™emporte sur `.submit`, car il est le dernier Ã  avoir Ã©tÃ© dÃ©clarÃ©.

Donc, si vous les Ã©changez pour que `.submit`Â soit dÃ©clarÃ© en dernier :

```html
<style>
    .button { background-color: #DB464B;}
    .submit {background-color: #15DEA5;}
</style>
<div class="button submit">
Cliquez ici !
</div>
```

le navigateur utilisera la couleur de fond de `.submit`Â :

![Image reprÃ©sentant un bouton cliquez ici vert](https://user.oc-static.com/upload/2019/10/09/15706234984875_image11.png)

La couleur Vert l'emporte

Maintenant queÂ `.submit`Â est dÃ©clarÃ© en dernier, câ€™est sa couleur de fond qui apparaÃ®t.

En vous restreignant aux classes pour crÃ©er vos sÃ©lecteurs CSS, vous ferez en sorte quâ€™ils aient une spÃ©cificitÃ© basse mais
constante. Cela rend les **rÃ¨gles** **contradictoires** plus faciles Ã  prÃ©voir et surtout Ã  gÃ©rer !

#### **Essayez par vous-mÃªme !**

**![](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Pratiquez en analysant la spÃ©cificitÃ© entre deux sÃ©lecteurs de classe avec deux boutons et leur couleurs. ğŸ‘Œ

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/48A9E867B164CB508693379200484B1D" width="100%" height="500" frameborder="0"></iframe>

:::info
Et si vous compariez votre travail avec [la correction de l'exercice](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-1/chapitre-2%2Fexercice-2) ?
:::

### Adoptez de bonnes pratiques

Vous avez vu ce que sont le principe **DRY** et la **spÃ©cificitÃ©**. Mais existe-t-il des rÃ¨gles Ã  suivre ? ğŸ¤”

Il nâ€™existe pas de rÃ¨gles absolues pour crÃ©er lâ€™architecture de votre CSS, seulement des recommandations trÃ¨s variÃ©es... Une
rapide recherche Google vous livrera des flopÃ©es dâ€™articles [medium.com](https://www.medium.com/) sur le sujet. Certains sont
dâ€™accord avec lâ€™idÃ©e que _chaque dÃ©veloppeur fait comme il lâ€™entend_, dâ€™autres vous diront que non, il faut suivre une
**nomenclature** **commune**, tandis que dâ€™autres encore Ã©mettent certaines rÃ©serves sur quelques principes. Au sein de toute
cette bataille de â€œ_câ€™est moi qui ai raison !!!"_, jâ€™ai choisi de vous prÃ©senter des solutions pratiques. Les mÃ©thodes prÃ©sentÃ©es
dans ce cours sont des **pratiques** **testÃ©es et largement adoptÃ©es par les dÃ©veloppeurs**.Â Ces bases vous seront dâ€™un grand
secours pour crÃ©er une codebase CSS maintenable et propre, et ce, pour des projets de nâ€™importe quelle taille.

La notion la plus importante lorsquâ€™on veut bÃ¢tir un code front-end robuste et maintenable est de **sâ€™asseoir, Ã©tablir un plan et
sâ€™y tenir coÃ»te que coÃ»te**. Au lieu de replonger la tÃªte la premiÃ¨re dans votre code existant comme nous lâ€™avons fait dans
lâ€™exemple ci-dessus et vous lancer dans des modifications Ã  la volÃ©e, vous devez **rÃ©flÃ©chir et anticiper** la faÃ§on de structurer
votre code, avant dâ€™Ã©crire la moindre premiÃ¨re ligne de code. Câ€™est trÃ¨s important, et cela vous fera gagner du temps par la suite.

### En rÃ©sumÃ©

- Lorsque vous codez, pensez Ã  adopter **le DRY** : ne vous rÃ©pÃ©tez pas !
- Lorsque vous crÃ©ez des **sÃ©lecteurs**, faites attention Ã  ne pas y entasser trop de rÃ¨gles. SÃ©parer les sÃ©lecteurs par leur
fonction vous aidera Ã  garder votre code comprÃ©hensible et maintenable.
- La **spÃ©cificitÃ©** permet de mesurer le poids dâ€™un sÃ©lecteur au sein du HTML parmi les autres.


- Il existe **quatre niveaux** de spÃ©cificitÃ© :
    - les feuilles de style locales (_inline styles_) ;
    - les id ;
    - les classes, pseudoclasses et attributs ;
    - les Ã©lÃ©ments et pseudoÃ©lÃ©ments.
- Votre navigateur applique les Ã©lÃ©ments **les plus spÃ©cifiques** en premier.
- Le CSS **nâ€™a pas de structure rigide**, ce qui complique la tÃ¢che pour avoir une codebase propre et maintenable.
- En **crÃ©ant et en appliquant votre propre structure**, vous pouvez mettre de lâ€™ordre dans un CSS brouillon...

_Dans le chapitre suivant, vous irez plus loin en mettant en application vos nouvelles connaissances en matiÃ¨re de spÃ©cificitÃ© et
de structure, en crÃ©ant des sÃ©lecteurs modulables et structurÃ©s pour la mise en forme de votre site._

-----

## CrÃ©ez des sÃ©lecteurs HTML avec la mÃ©thodologie BEM

[CrÃ©ez des sÃ©lecteurs HTML avec la mÃ©thodologie BEM - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6595809-creez-des-selecteurs-html-avec-la-methodologie-bem)

<Vimeo vimeoId="534137448" />

<br />

Soyons honnÃªtes, **vous passerez plus de temps Ã  lire votre code quâ€™Ã  lâ€™Ã©crire**. Il vous faudra souvent vous replonger dedans
et le parcourir Ã  la recherche dâ€™un Ã©lÃ©ment Ã  modifier, ou juste pour vous rappeler comment fonctionne tel ou tel Ã©lÃ©ment.

Lorsque vous Ã©crivez du code, il est primordial de le faire en anticipant lâ€™Ã©volution de votre projet et ce quâ€™il pourrait
devenir. D'ici quelque temps, il est possible que vous auriez oubliÃ© la raison de l'appel de ce sÃ©lecteur `.btn-alt`Â et encore
moins Ã  quoi il sert.

Avoir la possibilitÃ© de jeter un coup dâ€™Å“il Ã  un nom de classe et savoir immÃ©diatement le rÃ´le de votre classe et comment elle
interagit avec dâ€™autres Ã©lÃ©ments nous ferait gagner beaucoup de temps et dâ€™Ã©nergie Ã  lâ€™avenir, nâ€™est-ce pas ?

### Apprenez-en un peu plus sur BEM

Eh bien, pour rÃ©pondre Ã  cette problÃ©matique, je vous prÃ©sente **BEM**, une convention CSS qui va nous aider Ã  rendre nos classes
plus comprÃ©hensibles, et ce grÃ¢ce au **nommage**.

:::info
Le nommage vient du terme **_naming_** en anglais, qui est le fait dâ€™identifier une caractÃ©ristique en lui attribuant un nom.
Lorsque vous voyez un grand nombre dâ€™arbres, vous appelez Ã§a une forÃªt. Câ€™est du naming !
:::

BEM est lâ€™acronyme de _**bloc, Ã©lÃ©ment, modificateur**_. En assignant chaque sÃ©lecteur que vous Ã©crivez Ã  lâ€™une de ces trois
catÃ©gories, vous Ãªtes en mesure de dÃ©finir sa fonctionnalitÃ© et ses relations, tout en le nommant correctement, et de dÃ©finir un
sÃ©lecteur comme un bloc, Ã©lÃ©ment ou modificateur.

Pas mal, non ? Mais que sont au juste les blocs, Ã©lÃ©ments et modificateurs ?

#### **Construisez des blocs**

Un bloc est un composant, ou une section dâ€™une page qui est **autonome et peut fonctionner indÃ©pendamment du reste de la page**.
Cela peut Ãªtre un header, un footer, un conteneur, un menu ou mÃªme un bouton. Le but est simple : vous pourriez supprimer tout ce
quâ€™il y a autour de votre bloc et vous pourriez toujours comprendre de quoi il sâ€™agit.

Rappelez-vous, dans lâ€™introduction, je vous parlais de construire un portfolio. Jetons-y un Å“il. Nous avons un logo, une barre
de navigation, une citation et une grille de projets.

![La page dâ€™accueil du portfolio servant d'exemple](https://user.oc-static.com/upload/2019/10/09/15706237955338_image4.png)

La page dâ€™accueil du portfolio servant d'exemple

Si on supprimait tout sauf le titre dâ€™un projet, Ã§a nâ€™aurait plus trop de sens en soi. Le titre ne serait alors quâ€™un bout de
texte isolÃ©, sans aucun lien avec le reste.

![Image montrant un morceau isolÃ© du site appelÃ© le titre du projet](https://user.oc-static.com/upload/2019/10/09/15706238427329_image5.png)

Le titre, oui, mais le titre de quoiâ€¦ ?

Mais si nous isolons lâ€™aperÃ§u entier dâ€™un projet (le titre, lâ€™image, la description) : Ã§a fonctionne. On a une image avec un
titre et une description, on comprend de quoi il sâ€™agit. Cela signifie que dans la terminologie BEM, notre preview de projet est
un **bloc** !

![Image montrant le bloc projet](https://user.oc-static.com/upload/2019/10/09/15706238999699_image2.png)

AperÃ§u du projet

On nomme un bloc en dÃ©crivant sa **fonction**. Nommons notre bloc pour notre aperÃ§u de projet `.proj-prev`Â (prev pour _preview_
ou _aperÃ§u_ en franÃ§ais), en y assignant uniquement les rÃ¨gles qui sont spÃ©cifiques Ã  la configuration de ce bloc en particulier.

Nous pouvons dÃ©finir que le texte soit blanc pour tous les Ã©lÃ©ments utilisÃ©s dans notre bloc. En assignant ce paramÃ¨tre au bloc,
tous ses Ã©lÃ©ments hÃ©riteront de cette couleur. Nous devons aussi dÃ©finir une marge pour le bas du bloc.

##### **CSS**

```css
.proj-prev {
    color: #fff;
    margin-bottom: .25rem;
}
```

Nous avons utilisÃ© le sÃ©lecteurÂ `.proj-prev`Â pour dÃ©finir laÂ forme de notre bloc : il a une petite marge en bas et le texte est
blanc. Peu importe ce que vous ajoutez dans votre aperÃ§u de projet, le texte sera blanc et il y aura une marge en bas. Nous avons
donc un morceau de code rÃ©utilisable, ce qui nous permet dâ€™avoir une codebase bien ordonnÃ©e, tout en assurant une certaine
cohÃ©rence graphique et qui, bonus, suit le principe **DRY** (vous vous en souvenez ? ğŸ˜‰).

#### **CrÃ©ez des Ã©lÃ©ments**

Maintenant, est-ce que vous vous souvenez de ce bout de texte pour le titre du projet qui ne fonctionnait pas tout seul ? Il ne
peut pas fonctionner de faÃ§on autonome, mais en revanche il fait partie intÃ©grante du bloc : il sâ€™agit dâ€™un **Ã©lÃ©ment** de ce
bloc.

![Image montrant un bloc et un Ã©lÃ©ment](https://user.oc-static.com/upload/2019/10/09/15706240250407_image12.png)

Le titre du projet est un Ã©lÃ©ment du bloc

Le nom dâ€™un Ã©lÃ©ment doit indiquer deux choses :
- son **bloc parent**, suivi dâ€™un **double underscore** (aussi appelÃ© â€œdundersâ€) ;
- la **fonction** de lâ€™Ã©lÃ©ment. Comme câ€™est le titre de notre projet, on va le nommer `.proj-prev__heading`Â et lui assigner
lâ€™ensemble de rÃ¨gles qui suit.

**CSS**

```css
.proj-prev__heading {
    font-size: 4rem;
    padding-left: 2.5rem;
    margin: 0;
    line-height: 6rem;
}
```

Nous avons vu les blocs et les Ã©lÃ©ments, passons Ã  prÃ©sent aux **modificateurs** !

#### **Ã‰laborez des modificateurs**

Les modificateurs modifient lâ€™apparence dâ€™un bloc mais aussi dâ€™un Ã©lÃ©ment. Voyez-les comme des **sÃ©lecteurs qui crÃ©ent
diffÃ©rentes versions dâ€™un bloc ou dâ€™un Ã©lÃ©ment**. Besoin de changer la taille, la couleur, la police, etc. dâ€™un Ã©lÃ©ment, tout en
le gardant tel quel ? Câ€™est un modificateur quâ€™il vous faut !

Imaginons que vous vouliez faire les choses un peu diffÃ©remment pour certains projets, histoire de les faire ressortir. La
couleur de base du texte pour le bloc est le blanc, mais pour certains projets, vous voudriez les mettre en valeur en utilisant
du vert clair.

Pour cela, vous allez crÃ©er un modificateur pour votre blocÂ `.proj-prev`. Pour nommer le **modificateur**, vous devez prÃ©ciser
le **bloc** (ou lâ€™Ã©lÃ©ment) quâ€™il modifie, y ajouter **deux tirets** suivi du style graphique de votre modificateur. Puisque vous
Ãªtes en train de modifier le bloc `.proj-prev`Â pour lui donner un texte vert couleur menthe, vous pouvez lâ€™appeler
`.proj-prev--mint`Â et lui attribuerÂ une couleur.

##### **CSS**

```css
.proj-prev--mint {
    color: #15DEA5;
}
```

Et lâ€™appliquer au bloc HTML.

##### **HTML**

```html
<section class="proj-prev proj-prev--mint">
    <div class="proj-prev__image">
        <img src="/public/img/photography_1280w.jpg" alt="project title goes here" >
    </div>
    <h1 class="proj-prev__heading">
        Project Title
    </h1>
    <p class="proj-prev__byline">
        project keywords would go here
    </p>
</section>
```

Et quand on regarde le rendu du HTML, on voit quâ€™il y a bel et bien un projet qui ressort avec un texte couleur menthe sans
modifier les autresÂ  ğŸ‰ :

![Nous avons modifiÃ© la couleur du texte pour un seul des blocs](https://user.oc-static.com/upload/2019/10/09/15706242548401_image8.png)

Nous avons modifiÃ© la couleur du texte pour un seul des blocs

Voici toute la page dâ€™accueil, sÃ©parÃ©e en blocs, Ã©lÃ©ments et modificateurs :

![Notre page dâ€™accueil divisÃ©e en blocs, Ã©lÃ©ments et modificateurs](https://user.oc-static.com/upload/2019/10/09/15706242907473_image9.png)

Notre page dâ€™accueil divisÃ©e en blocs, Ã©lÃ©ments et modificateurs

Quand vous construisez vos pages, imaginez que vous empilez des boÃ®tes dans des boÃ®tes en les dessinant, Ã§a vous aidera Ã  mieux
visualiser votre structure HTML. ğŸ˜‰

### CrÃ©ez votre propre barre de navigation avec BEM

Maintenant que nous avons passÃ© en revue les fondamentaux de BEM, mettons-les en application en crÃ©ant une **barre de navigation**
avec nos nouveauxÂ sÃ©lecteurs.ğŸ¤˜

```html
<nav class="nav">
    <ul>
        <li class="nav__link nav__link--active">work</li>
        <li class="nav__link"> <a href="/about.html">about</a> </li>
        <li class="nav__link"> <a href="/contact.html">contact</a>  </li>
    </ul>
</nav>
```

Notez bien, câ€™est important : les sÃ©lecteurs BEM sont **toujours** **implÃ©mentÃ©s sous forme de classes**.

:::note ?
Mais pourquoi ? ğŸ¤”
:::

Pour pouvoir appliquer les modificateurs avec des rÃ©sultats cohÃ©rents, vous devez Ãªtre sÃ»r que **vos sÃ©lecteurs ont une
spÃ©cificitÃ© aussi basse que possible**. Si vous assignez le sÃ©lecteur de bloc avec unÂ id au lieu dâ€™une classe, sa spÃ©cificitÃ©
prendra automatiquement le dessus sur tous les modificateurs assignÃ©s en tant que classe.

Rappelez-vous, dans le chapitre prÃ©cÃ©dent nous avons vu que quand le navigateur interprÃ¨te vos Ã©lÃ©ments, il cherche dâ€™abord les
**classes locales**, puis les id, puis les classes, et enfin les Ã©lÃ©ments. Sâ€™il croise un sÃ©lecteur attachÃ© Ã  un id, celui-ci
prendra le dessus sur toute rÃ¨gle potentiellement contradictoire provenant dâ€™une classe. Or, le but dâ€™un **modificateur** est
dâ€™introduire une **rÃ¨gle** **contradictoire**, comme une couleur ou une taille de police diffÃ©rente, et que celle-ci annule la
rÃ¨gle originelle ; câ€™est pourquoi on utilise toujours des classes pour implÃ©menter des sÃ©lecteurs BEM !

Jetons Ã  prÃ©sent un Å“il au CSS de notre barre de navigation :

##### **CSS**

```css
.nav {
    padding-right: 6rem;
    text-align: right;
}

.nav__link {
    display: inline;
    font-size: 3rem;
    padding-left: 1.5rem;
}

.nav__link a {
    text-decoration: none;
    color: #D6FFF5;
}

.nav__link--active {
    color: #001534;
}

.nav__link a:hover {
    color: #fff;
}
```

Pendant que nous essayons de garder une spÃ©cificitÃ© basse pour notre sÃ©lecteur, les pseudoclasses, comme par exempleÂ `:hover`,
et les **combinateurs**, tels que les combinateurs descendants, peuvent parfaitement Ãªtre utilisÃ©s.

:::note ?
Pause pause pause ! Combinateurs descen... quoi ? ğŸ˜…
:::

Un **combinateur descendant**, aussi appelÃ© _sÃ©lecteur dâ€™Ã©lÃ©ments descendant_, permet de sÃ©lectionner les Ã©lÃ©ments qui dÃ©pendent
dâ€™un sÃ©lecteur. Il est matÃ©rialisÃ© par un ou plusieurs espaces. Par exemple, `div span`Â permet de cibler nâ€™importe quel span dans
un Ã©lÃ©ment div.

Les combinateurs descendants vont **augmenter** la spÃ©cificitÃ© du sÃ©lecteur, mais ils peuvent aussi contribuer Ã  crÃ©er du
**code plus propre et plus lisible** en diminuant le besoin dâ€™assigner une classe Ã  _chaque Ã©lÃ©ment de la page_.ğŸ˜±

En CSS, les combinateurs, peu importe leur type, sÃ©lectionnent les Ã©lÃ©ments en fonction de leur relation Ã  un Ã©lÃ©ment dÃ©fini.

Prenons une liste non ordonnÃ©e, `<ul>`, et les items de cette liste, `<li>`. PlutÃ´t que de crÃ©er un sÃ©lecteur de classe pour le
`<li>`Â et de lâ€™appliquer Ã  chacun des items, vous pouvez appliquer un **combinateur enfant** qui sÃ©lectionnera tous les enfants
directs du `<ul>`.

##### **CSS**

```css
ul.list {
    list-style: none;
}

ul.list > li {
    font-weight: 100;
    color: #001534;
}
```

Ce qui donne un HTML beaucoup plus propre que dâ€™appliquer une classe Ã  chaqueÂ `<li>`Â :

##### **HTML**

```html
<ul class="list">
    <li>List Item</li>
    <li>List Item</li>
    <li>List Item</li>
</ul>
```

:::info
Ne faites pas trop attention au combinateur enfant, on en parlera plus en dÃ©tail dansÂ unÂ prochainÂ chapitre.
:::

BEM nous a aidÃ© Ã  rendre notre CSS beaucoup mieux organisÃ© et plus efficace, et notre HTML plus propre et lisible, en dÃ©finissant
clairement la fonction des sÃ©lecteurs. Mais notre CSS nâ€™en reste pas moins un gros amas de code sans forme.

#### **Essayez par vous-mÃªme !**

![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)

Adaptez le code fourni en utilisant la mÃ©thode BEM.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/2025781BA1CB53D344796C4E5370D43C" width="100%" height="500" frameborder="0"></iframe>

:::info
Comparez votre exercice avec [la correction](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-1/chapitre-3%2Fexercice-1) !
:::

### En rÃ©sumÃ©

- BEM signifie _bloc, Ã©lÃ©ment, modificateur_ :
    - les blocs sont des bouts de code autonomes ;
    - les Ã©lÃ©ments sont les parties qui forment le bloc ;
    - les modificateurs changent lâ€™apparence ou le comportement dâ€™un bloc ou dâ€™un Ã©lÃ©ment.
- Les blocs sont nommÃ©s en fonction de leur rÃ´le :
    - les Ã©lÃ©ments indiquent le nom de leur bloc parent, suivi dâ€™un double underscore/dunder (__) puis du rÃ´le de lâ€™Ã©lÃ©ment :
    form__label.
- Les modificateurs utilisent le nom du bloc ou de lâ€™Ã©lÃ©ment quâ€™ils modifient, suivi de deux tirets (--) et de ce que le
sÃ©lecteur modifie : button--green.
- Vous nâ€™avez pas besoin dâ€™attribuer Ã  chaque Ã©lÃ©ment dâ€™une page web un sÃ©lecteur de classe. Vous pouvez utiliser les sÃ©lecteurs
pour que votre code HTML soit plus propre et concis.

_Le chapitre suivant va vous prÃ©senter des outils qui donneront plus de structure visuelle Ã  votre CSS, tout en vous facilitant
la vie au passage. PrÃ©parez-vous Ã  plonger dans le monde des prÃ©processeurs CSS et de Sass !_

-----

## Utilisez les prÃ©processeurs CSS pour des fonctionnalitÃ©s avancÃ©es

[Utilisez les prÃ©processeurs CSS pour des fonctionnalitÃ©s avancÃ©es - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6596497-utilisez-les-preprocesseurs-css-pour-des-fonctionnalites-avancees)

<Vimeo vimeoId="534172368" />

<br />

Ne serait-ce pas merveilleux si vous pouviez Ã©crire votre CSS comme vous Ã©crivez votre HTML ? PlutÃ´t quâ€™une longue liste de
sÃ©lecteurs CSS, vous pourriez **indenter** vos Ã©lÃ©ments et modificateurs au sein de leur bloc parent, comme ceci :

```css
.nav {
    padding-right: 6rem;
    flex: 2 1 auto;
    text-align: right;
        .nav__link {
            display: inline;
            font-size: 3rem;
            padding-left: 1.5rem;
                .nav__link--active {
                    color: #001534;
                }
        }
}
```

### CrÃ©ez une hiÃ©rarchie dans votre code

Avoir une **hiÃ©rarchie visuelle** ne rend pas seulement les choses beaucoup plus faciles Ã  lire, cela permet aussi dâ€™Ãªtre plus
concis. En forÃ§ant un objet Ã  exister au sein de **blocs parents**, votre codebase devient beaucoup plus facile Ã  lire et Ã 
maintenir. PlutÃ´t que de parcourir votre document de haut en bas en cherchant des Ã©lÃ©ments dans un bout de code, vous nâ€™avez
plus quâ€™Ã  localiser le bloc que vous cherchez en particulier, et tous les Ã©lÃ©ments qui lui sont reliÃ©s se trouveront au mÃªme
endroit.

Voici votre nouveau meilleur ami : le **prÃ©processeur CSS** !Â 

:::info
Les prÃ©processeurs sont des **outils**, ou des programmes, qui vont vous permettre de **gÃ©nÃ©rer du CSS** Ã  partir des fichiers
Ã©crits dans la syntaxe du prÃ©processeur que vous avez choisi. Les prÃ©processeurs CSS regorgent dâ€™outils qui vous seront trÃ¨s
utiles dans votre quÃªte dâ€™un code plus structurÃ© et organisÃ©.
:::

GrÃ¢ce aux prÃ©processeurs, vous pouvez rÃ©diger votre code dâ€™une maniÃ¨re plus cohÃ©rente visuellement, en utilisant des
fonctionnalitÃ©s comme le **nesting**.

:::info
Le nesting est le fait dâ€™imbriquer les sÃ©lecteurs lâ€™un dans lâ€™autre en crÃ©ant une hiÃ©rarchie, exactement comme en HTML !
:::

Regardez donc une Ã©criture utilisant le nesting dans un prÃ©processeur, Ã  gauche, avec le rÃ©sultat en CSSÂ classique Ã  droite :


<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
.nav {
    padding-right: 6rem;
    flex: 2 1 auto;
    text-align: right;
    .nav__link {
        display: inline;
        font-size: 3rem;
        padding-left: 1.5rem;
            .nav__link--active {
                color: #001534;;
            }
    }
}


```

</div>
<div style={{width:'49%'}}>

```css title="css"
.nav {
    padding-right: 6rem;
    flex: 2 1 auto;
    text-align: right;
}

.nav .nav__link {
    display: inline;
    font-size: 3rem;
    padding-left: 1.5rem;
}

.nav .nav__link .nav__link--active {
    color: #001534;
}
```

</div>
</div>

<br />

Ne vous prÃ©occupez pas trop de la syntaxe pour le moment, on y viendra. ğŸ˜‡ Observez la faÃ§on dont le **code imbriquÃ©** (ou
_nestÃ©_) produit un fichier CSS trÃ¨s standardisÃ©. Coder en utilisant une syntaxe plus cohÃ©rente câ€™est bien, le souci câ€™est que
les navigateurs voudront toujours que vos feuilles de style leur soient fournies sous forme dâ€™un bon vieux fichier CSS classique.
**Les prÃ©processeurs vous permettent dâ€™avoir les deux Ã  la fois**, en transformant la syntaxe vers du code CSS standard qui sera
compris par les navigateurs.

### DÃ©couvrez les fonctionnalitÃ©s des prÃ©processeurs

Les prÃ©processeurs regorgent dâ€™outils qui vont nous aider Ã  mieux structurer notre code. Dans cette partie du chapitre, nous
allons rapidement les dÃ©couvrir afin que vous soyez familier avec ces outils sans trop creuser. Nous les verrons plus en dÃ©tail
plus tard dans le cours. En attendant, vous pouvez vous familiariser avec leur nom et leur fonction.

#### Les variables

En plus dâ€™avoir une syntaxe beaucoup plus agrÃ©able visuellement, grÃ¢ce aux prÃ©processeurs vous avez accÃ¨s Ã  des fonctionnalitÃ©s
que vous pouvez trouver dans dâ€™autres langages de programmation courants, tels que les **variables** :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
$mint: #15DEA5;
.header {
    background-color: $mint
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.header {
    background-color: #15DEA5;
}

```

</div>
</div>

<br />

Les variables vous permettent de **stocker des valeurs rÃ©pÃ©tÃ©es frÃ©quemment**, comme par exemple les couleurs et les mensurations,
dans un Ã©lÃ©ment unique que vous pouvez **rÃ©utiliser Ã  travers lâ€™ensemble de votre code**. Imaginez que vous avez utilisÃ© une
nuance de vert des centaines de fois dans un site, mais que vous dÃ©cidez de le changer en rouge. GrÃ¢ce aux variables, il vous
suffit de faire le changement une seule fois et il sera rÃ©percutÃ© partout oÃ¹ la variable a Ã©tÃ© utilisÃ©e. Un seul changement est
plus propre et facile que des centaines ! Pratique, non ?

#### Les boucles

Les **boucles**, qui **automatisent les tÃ¢ches rÃ©pÃ©titives** telles que la crÃ©ation dâ€™une sÃ©rie de modificateurs de couleurs,
par exemple, vous Ã©pargnent un vrai calvaire tout en gardant une codebase plus petite et plus simple Ã  gÃ©rerÂ :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
$colours: (
    mint: #15DEA5,
    navy: #001534,
    seafoam: #D6FFF5,
    white: #fff,
    rust: #DB464B
);

@each $colour, $hex in $colours {
    .btn--#{$colour} {
        background-color: $hex;
    }
}






```

</div>
<div style={{width:'49%'}}>

```css title="css"
.btn--mint {
    background-color: #15DEA5;
}

.btn--navy {
    background-color: #001534;
}

.btn--seafoam {
    background-color: #D6FFF5;
}

.btn--white {
    background-color: #fff;
}

.btn--rust {
    background-color: #DB464B;
}
```

</div>
</div>

<br />

#### Les structures conditionnelles (ou conditions)

Les **opÃ©rations logiques** vous permettent dâ€™Ã©crire **un mÃªme bloc de code que vous pouvez utiliser dans diffÃ©rentes
circonstances** et qui le font rÃ©agir en consÃ©quence, comme changer la couleur du texte en fonction de la couleur du fond. Par
exemple _si_ le fond est bleu foncÃ©, _alors_ passer le texte en blanc. Avec le temps, cela vous donne une codebase plus petite,
plus concise qui est donc beaucoup plus facile Ã  maintenir.

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
@if (lightness(#15DEA5) > 25%) {
    .header {
        color: #fff;
        background-color: $mint;
}

}@else{
    .header {
        color: #000;
        background-color: $mint;
    }
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.header {
    color: #fff;
    background-color: #15DEA5;
}








```

</div>
</div>

<br />

Pas de panique ! Câ€™Ã©tait juste une introduction. Ne vous prÃ©occupez pas de comment Ã©crire des conditions ou des boucles pour le
moment, nous verrons cela en dÃ©tail plus tard dans le cours. Au lieu de cela, regardez comment nous employons les prÃ©processeurs
pour automatiser la crÃ©ation des sÃ©lecteurs.

### DÃ©couvrez les diffÃ©rents prÃ©processeurs CSS

![Image montrant 3 prÃ©processeurs](https://user.oc-static.com/upload/2019/10/09/15706249219051_image10.png)

Les diffÃ©rents prÃ©processeurs

Il existe de nombreux prÃ©processeurs CSS, mais les trois plus reconnus sont **Sass**, **Less** et **Stylus**. Et entre nous, il
nâ€™y a pas grand chose qui les diffÃ©rencie. ğŸ¤« Il existe, il est vrai, quelques diffÃ©rences de syntaxe et de fonctionnalitÃ©, mais
globalement, **ils font tous la mÃªme chose et de maniÃ¨re trÃ¨s similaire**.

Dans ce cours, nous allons utiliser Sass, mais ce qui compte, câ€™est dâ€™apprendre et d'intÃ©grer les concepts et process liÃ©s Ã 
lâ€™utilisation dâ€™un prÃ©processeur CSS, qui peuvent Ã©galement sâ€™appliquer Ã  Less et Stylus.

:::info
Dans dâ€™autres termes, dites-vous que Sass, Less et Stylus sont **diffÃ©rentes marques pour un mÃªme outil**, un peu comme des
snowboards fabriquÃ©s par Burton ou Rossignol. Leur couleur et leur forme peuvent varier, leur taille aussi, mais ce sont avant
tout des snowboards et vous pourrez rider sans aucun problÃ¨me avec le premier comme le deuxiÃ¨me. Ce qui compte, ce nâ€™est pas la
marque, câ€™est la fonction. Apprendre Ã  rider un snowboard Burton ou Rossignol ne vous empÃªchera pas de descendre un jour une
piste avec une Salomon.
:::

Du coup, pourquoi Sass ? Comme je lâ€™ai dit plus haut, ce sont des outils trÃ¨s similaires. Toutefois, vous avez beaucoup plus de
chances de tomber sur Sass dans votre vie professionnelle, et il est donc logique de faire son apprentissage sur lâ€™outil que vous
Ãªtes le plus susceptible dâ€™utiliser dans votre travail quotidien, nâ€™est-ce pas ?

:::info
**[Selon ce sondage](https://ashleynolan.co.uk/blog/frontend-tooling-survey-2018-results)**, la part de marchÃ© de Sass est dix
fois supÃ©rieure Ã  celle de Less. Bien que lâ€™Ã©chantillon ait Ã©tÃ© assez limitÃ© (5Â 000 rÃ©ponses), Ã§a donne tout de mÃªme une idÃ©e sur
la notoriÃ©tÃ© de Sass.
:::

### En rÃ©sumÃ©

- Les prÃ©processeurs CSS vous permettent dâ€™imbriquer votre code (on appelle Ã§a le _nesting_) pour crÃ©er une hiÃ©rarchie plus
facile Ã  lire et regrouper des morceaux de code entre eux.
- Il existe plein de prÃ©processeurs, mais le plus courant est Sass, qui signifie _Syntactically Awesome Style Sheets_ (â€œFeuilles
de style syntaxiquement fantastiquesâ€).
- Au-delÃ  du nesting, les prÃ©processeurs vous permettent dâ€™utiliser des fonctionnalitÃ©s de programmation pour crÃ©er une codebase
plus maintenable, tout en diminuant les Ã©normes quantitÃ©s de code Ã  Ã©crire.

_Dans le prochain chapitre, nous aborderons Sass en apprenant sa syntaxe et les outils que vous utiliserez pour lâ€™Ã©crire._

-----

## DÃ©couvrez Sass et sa syntaxe

[DÃ©couvrez Sass et sa syntaxe - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6596483-decouvrez-sass-et-sa-syntaxe)

<Vimeo vimeoId="534188245" />

<br />

Nous avons vu les diffÃ©rents types de prÃ©processeurs et leurs avantages. Parmi eux : Sass. Il est donc temps de dÃ©couvrir plus
en dÃ©tail celui-ci.

### Pour bien dÃ©marrer

Il est temps de se remonter les manches et de plonger les mains dans Sass ! ğŸ’ª

Nous allons commencer par dÃ©couvrir la **syntaxe** de Sass : Ã  quoi elle ressemble et comment lâ€™Ã©crire ; et ce, en pratiquant
avec des exercices au fur et Ã  mesure. Cela vous permettra de vous jeter directement dans **Sass** et de voir les rÃ©sultats en
temps rÃ©el, sans avoir besoin pour le moment dâ€™installer quoi que ce soit sur votre ordinateur ! ğŸŒŸ

Plus tard, vous utiliserez Sass directement sur votre machine : vous allez lâ€™installer et le configurer afin quâ€™il puisse
**compiler** votre code pour vous permettre de voir vos rÃ©sultats de la mÃªme maniÃ¨re : en temps rÃ©el !

:::note ?
Une seconde... compiâ€¦ quoi ? ğŸ¤”
:::

La compilation est un **processus** qui nous permet de **transformer Sass en CSS traditionnel**. Votre navigateur est incapable
de comprendre Sass dans lâ€™Ã©tat. En dâ€™autres termes, il nous faut traduire la syntaxe Sass en CSS pour que votre navigateur puisse
lâ€™utiliser, et câ€™est possible en le compilant.

Mais point de panique, jeune padawan, pour le moment nous allons nous concentrer seulement sur la syntaxe de Sass !

Vous pouvez aussi suivre le cours en utilisant votreÂ **IDE** (_integrated development environment_, soit un traitement de texte
super sophistiquÃ©) et Sass, ou bien utiliser Codepen : une solution en ligne !Â 

#### Deux maniÃ¨res de faire la mÃªme chose

Il existe deux maniÃ¨res dâ€™Ã©crire du Sass ; on les diffÃ©rencie par leur extension de fichier :Â `.sass`Â et`.scss`.

Vous avez dÃ©jÃ  du **code CSS traditionnel** que vous voulez rÃ©utiliser ? Aucun problÃ¨me ! Sass fonctionne trÃ¨s bien avec du CSS.
Copiez votre CSS et collez-le dans un fichier `.sass`, et le tour est jouÃ©. Votre code sera interprÃ©tÃ© et votre CSS sera exÃ©cutÃ©
mais ne sera pas transformÃ© en Sass. Pour utiliser Sass, il est important dâ€™apprendre Ã  maÃ®triser sa **syntaxe**, car elle vous
permet de bÃ©nÃ©ficier de fonctionnalitÃ©s qui vont vous permettre dâ€™Ã©crire du code propre, plus organisÃ© et surtout plus efficace.

Jusquâ€™Ã  prÃ©sent, tous les petits bouts de CSS prÃ©compilÃ©s que vous avez vus prÃ©cÃ©demment dans ce cours ont Ã©tÃ© crÃ©Ã©s en utilisant
la syntaxe Sass `.scss`. Regardez, Ã§a ressemble Ã©normÃ©ment Ã  du CSS normal, on a juste ajoutÃ© un peu de poudre magique Sass
par-dessus et voilÃ  le travail :

```scss
.nav {
    padding-right: 6rem;
    flex: 2 1 auto;
    text-align: right;
    nav__link {
        display: inline;
        font-size: 3rem;
        padding-left: 1.5rem;
        nav__link--active {
            color: #001534;
        }
    }
}
```

La syntaxe `.scss`Â sâ€™appuie sur la syntaxe CSS standard ! Celle-ci Ã©tant trÃ¨s proche du CSS, elle permet aux dÃ©veloppeurs de ne
pas Ãªtre perdus lorsquâ€™ils Ã©crivent du CSS, tout en bÃ©nÃ©ficiant de toutes les fonctionnalitÃ©s Sass, et câ€™est tout lâ€™intÃ©rÃªt !

En CSS, cela donnerait :

```css
.nav {
    padding-right: 6rem;
    flex: 2 1 auto;
    text-align: right;
    }

.nav nav__link {
    display: inline;
    font-size: 3rem;
    padding-left: 1.5rem;
}

.nav nav__link nav__link--active {
    color: #001534;
}
```

Et en `.sass`, ce serait:

```scss
.nav
    padding-right: 6rem;
    flex: 2 1 auto;
    text-align: right;
    nav__link
        display: inline;
        font-size: 3rem;
        padding-left: 1.5rem;
        nav__link--active
            color: #001534;
```

La syntaxe spÃ©cifique Ã  `.scss`Â nâ€™est visible que lorsquâ€™on commence Ã  utiliser les fonctionnalitÃ©s Sass, comme les variables
identifiÃ©es par **le prÃ©fixe dollar** ($) et les fonctions identifiÃ©es avec **lâ€™arobase** (@).

Nous verrons en dÃ©tail comment utiliser ces outils plus tard dans ce cours. Pour le moment, ce qu'il est important de comprendre,
câ€™est que vous pouvez appliquer vos connaissances en Ã©criture CSS directement dans Sass avec la syntaxeÂ `.scss`.

:::note ?
Mais comment faire ? ğŸ§
:::

Commencez par **dÃ©clarer** le **sÃ©lecteur**, quâ€™il sâ€™agisse dâ€™une classe, dâ€™un Ã©lÃ©ment, dâ€™un id, etc., puis ajoutez une paire
dâ€™accolades entre lesquelles vous mettrez les propriÃ©tÃ©s et les valeurs nÃ©cessaires :

```scss
.navbar-content {
    color: white;
    background-color: white;
}
```

:::note ?
Et Ã§a donnerait quoi en syntaxe `.sass`Â ?
:::

Voici ce que cela donne en syntaxe `.sass` :

```scss
.navbar-content
    color: white
    background-color: black
```

LeÂ `.scss`Â ressemble beaucoup Ã  du CSS normal, tandis que leÂ `.sass`Â a une **syntaxe plus condensÃ©e et concise**. En `.sass`,
dites adieu aux accolades et aux points-virgules ! Ã€ la place, elle utilise uniquement des tabulations et des retours Ã  la ligne
pour la mise en forme du code. La syntaxe `.sass`Â produit donc une codebase plus propre, mais surtout plus lisible. Sans compter
quâ€™Ã©viter toute cette ponctuation vous permet aussi dâ€™Ã©crire plus vite.

#### **Essayez par vous-mÃªme !**

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/5E38B12FCE24BF1930909E9EA5C47556" width="100%" height="500" frameborder="0"></iframe>

#### Une mÃªme syntaxe pour tous

Entre nous, il est assez rare que vous tombiez sur du .sass. Quand quelquâ€™un parle de Sass, il parle quasi systÃ©matiquement de
`.scss`. Du coup, vos chances dâ€™Ã©crire du `.scss`Â dans votre vie professionnelles sont nettement plus Ã©levÃ©es. Il est donc
logique que nous utilisions `.scss`Â dans ce cours.

Ã€ partir de maintenant, nous utiliserons Sass comme un synonyme de `.scss`. Ã€ chaque fois que nous en parlerons, il sâ€™agira de
`.scss`Â et de sa syntaxe.

### Utilisez des sÃ©lecteurs Ã  lâ€™intÃ©rieur dâ€™autres sÃ©lecteurs : dÃ©couvrez le nesting !

#### Des sÃ©lecteurs dans des sÃ©lecteurs : Inception

La syntaxe est importante et nous permet dâ€™Ã©crire du code plus organisÃ© ; mais seule, elle nâ€™est pas trÃ¨s efficace et on ne
comprend pas trop lâ€™intÃ©rÃªt dâ€™Ã©crire du CSS dans un fichier `.scss`. Câ€™est ici quâ€™intervient le **nesting** !

De la mÃªme faÃ§on que vous imbriquez des `<li>`Â dans un `<ul>`Â en HTML, dans Sass vous pouvez imbriquer les sÃ©lecteurs ou
autrement dit, les nester.

```scss
ul {
    list-style: none;
    text-align: right;

    li {
        display: inline;
        font-size: 3rem;
        color: #D6FFF5;
    }
}
```

Maintenant vous avez une hiÃ©rarchie de sÃ©lecteurs claire qui reflÃ¨te leur structure HTML. Vos `<li>`Â sont imbriquÃ©s dans le `<ul>`,
exactement comme ils le seraient en HTML.

PlutÃ´t que dâ€™avoir Ã  parcourir un fichier CSS interminable Ã  la recherche dâ€™un sÃ©lecteur particulier et de son ensemble de rÃ¨gles,
ce qui Ã©quivaut Ã  chercher une aiguille dans une botte de foin, vousÂ pouvez vous rÃ©fÃ©rer Ã  un seul endroit dans votre fichier et
voir comment les `<ul>`Â et leurs `<li>`Â enfants sont configurÃ©s. Au final, vous nâ€™aurez Ã  aller quâ€™Ã  un seul et mÃªme endroit pour
faire vos modifications futures.

Plus propre ? ValidÃ©. âœ… Maintenable ? Doublement validÃ©. âœ…

Regardez le CSS qui en rÃ©sulte.

```scss
ul {
    list-style: none;
    text-align: right;
}

ul li {
    display: inline;
    font-size: 3rem;
    color: #D6FFF5;
}
```

LeÂ `<ul>`Â a reÃ§u toutes les rÃ¨gles assignÃ©es en dehors duÂ `<li>`. Et leÂ `<li>` a reÃ§u les rÃ¨gles qui Ã©taient assignÃ©es dans son
sÃ©lecteur imbriquÃ©. Remarquez quâ€™au lieu dâ€™avoir crÃ©Ã© un sÃ©lecteur uniqueÂ `<li>`, nous avons crÃ©Ã© un combinateur descendant (ou
un combinateur parent/enfant).

#### **Essayez par vous-mÃªme !**

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, pratiquez le nesting : placez un sÃ©lecteur dans un autre.

Console de code

<iframe title="codevolve" id="codevolveIframe2" src="https://www.codevolve.com/api/v1/access_token/15520968C926817BFC7AA678BDF552C2" width="100%" height="500" frameborder="0"></iframe>

:::info
Alors ? Avez-vous rÃ©ussi ? [Corrigez-vous avec cette correction](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-1/chapitre-5/exercice-2) !
:::

Nous avons effectuÃ© la forme la plus simple de **nesting** dans Sass : placer un sÃ©lecteur dans un autre sÃ©lecteur. Sass compilera
toujours ceci sous forme de sÃ©lecteurs sÃ©parÃ©s par des espaces, ce qui, en CSS, correspond Ã  un **combinateur descendant**.

Maintenant que vous connaissez les principes de base de Sass et comment lâ€™Ã©crire, et que vous vous Ãªtes initiÃ© au nesting, il est
temps de passer au niveau supÃ©rieur en apprenant Ã  utiliser dâ€™autres combinateurs !

:::info
Si vous voulez en savoir un peu plus sur les combinateurs, lisez **[lâ€™excellente documentation de MDN](https://developer.mozilla.org/fr/docs/Web/CSS/S%C3%A9lecteurs_CSS#Combinators)**.
:::

### En rÃ©sumÃ©

- La syntaxe .scss est trÃ¨s similaire Ã  la syntaxe CSS.
- On peut utiliser du code CSS prÃ©existant dans Sass en lâ€™intÃ©grant dans un fichier .scss.
- La syntaxe .sass est plus concise mais .scssÂ reste plus couramment utilisÃ©e.
- Le nesting permet dâ€™imbriquer les sÃ©lecteurs comme en HTML.Â 

 _La syntaxe Sass et surtout le nesting nous permettent de passer un cap dans lâ€™organisation de notre code, mais il existe aussi
dâ€™autres combinateurs que nous pouvons utiliser pour amÃ©liorer notre code, et câ€™est ce que nous allons dÃ©couvrir dans le chapitre
suivant._

-----

## Utilisez les combinateurs

[Utilisez les combinateurs - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6596489-utilisez-les-combinateurs)

<Vimeo vimeoId="534204277" />

<br />

Dans les chapitres prÃ©cÃ©dents, nous avons vu comment crÃ©er et utiliser les combinateurs descendants. Mais vous pouvez aussi crÃ©er
dâ€™autres combinateurs. Dâ€™ailleurs, Sass vous permet de crÃ©er tous les autres types de combinateurs CSS.

### DÃ©couvrez dâ€™autres types de combinateurs

#### Combinateur parent

```scss
.parent {
    background-color: #15DEA5;
}
```

#### Combinateur descendant

```scss
.parent .descendant {
    color: #fff;
}
```

#### Combinateur parent > enfant

```scss
.parent > .child {
    color: #D6FFF5;
}
```

#### Combinateur adjacent

```scss
.parent + .adjacent {
    color: #001534;
}
```

Ã‡a vous rappelle quelque chose, nâ€™est-ce pas ? RÃ©capitulons :
1. Dans le premier cas, tout ce qui est **reliÃ©** Ã  lâ€™Ã©lÃ©ment parent adoptera la couleur de fond spÃ©cifiÃ©e.
2. Dans le deuxiÃ¨me cas, si le deuxiÃ¨me Ã©lÃ©ment est le **descendant** du premier, alors il adoptera la couleur spÃ©cifiÃ©e.
3. Dans le troisiÃ¨me cas, si le deuxiÃ¨me Ã©lÃ©ment est un **enfant** du premier, alors il adoptera la couleur spÃ©cifiÃ©e.
4. Dans le quatriÃ¨me cas,Â si le deuxiÃ¨me Ã©lÃ©ment est immÃ©diatement **prÃ©cÃ©dÃ©** du premier, alors il adoptera la couleur spÃ©cifiÃ©e.

:::note ?
Une minute, _descendant_ on lâ€™a vu plus tÃ´t, mais câ€™est quoi la diffÃ©rence entre â€œdescendantâ€ et â€œenfantâ€ ? ğŸ¤”
:::

Câ€™est la mÃªme diffÃ©rence quâ€™en franÃ§ais :
- Vous Ãªtes Ã  la fois lâ€™_enfant_ et le _descendant_ de vos parents ;
- Vous nâ€™Ãªtes pas lâ€™_enfant_ de vos grands-parents, en revanche vous Ãªtes leur _descendant_.

Un Ã©lÃ©ment enfant a donc un **lien direct et immÃ©diat** avec son Ã©lÃ©ment parent alors quâ€™un lien descendant, non. Vous avez un
lien direct et immÃ©diat avec vos parent. Par contre, vous Ãªtes le descendant de vos grand-parents : votre lien nâ€™est pas direct
et immÃ©diat.

En ajoutant le bon symbole de combinateur devant un sÃ©lecteur, vous pouvez crÃ©er tous les combinateurs CSS dans Sass :

```scss
.parent {
    background-color: #15DEA5;
    .descendant {
        color: #fff;
    }
    >.child {
        color: #D6FFF5;
    }
    +.adjacent {
        color: #001534;
    }
}
```

Quand vous imbriquez un bloc dans Sass, cela crÃ©e un nouveau sÃ©lecteur CSS avec le sÃ©lecteur parent attachÃ©, sÃ©parÃ© par le
combinateur adaptÃ©.

#### **Essayez par vous-mÃªme !**

![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)

Appliquez vos nouvelles connaissances des combinateurs dans cet exercice.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/9C80DE65A962FE2D51D24FF1D96A4317" width="100%" height="500" frameborder="0"></iframe>

:::info
Et voici [la correction de l'exercice](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-1/chapitre-6/exercice-1)
pour comparer avec votre travail ğŸ˜Š
:::

Mais si lâ€™on ne veut pas de sÃ©paration entre parent et enfant ? ğŸ™…â€â™€ï¸

Dans ce cas-lÃ  on utilise **lâ€™esperluette** (ou _ampersand_ en anglais) !

### Utilisez lâ€™esperluette

Vous avez besoin dâ€™ajouter une **pseudoclasse** `li:hover` Ã  vos `<li>` pour ajouter un peu dâ€™interaction visuelle et amÃ©liorer
lâ€™expÃ©rience utilisateur. Si on **imbrique** le pseudo-sÃ©lecteur dans notre sÃ©lecteur li, cela nous donne :


```scss
ul {
    list-style: none;
    text-align: right;
    li {
        display: inline;
        font-size: 3rem;
        color: #D6FFF5;
        :hover {
            color: #001534;
        }
    }
}
```

Ce qui se compile ainsi :

```scss
ul {
    list-style: none;
    text-align: right;
}

ul li {
    display: inline;
    font-size: 3rem;
    color: #D6FFF5;
}

ul li :hover {
    color: #001534;
}
```

AÃ¯e, Ã§a ne marchera pasâ€¦ ğŸ˜• Souvenez-vous que le nesting dans Sass crÃ©e des combinateurs de lui-mÃªme. Sauf que vous ne voulez pas
dâ€™un combinateur avant votre pseudosÃ©lecteur. Ce nâ€™est pas comme Ã§a quâ€™ils fonctionnent ; vous avez besoin quâ€™il soit
**directement reliÃ© au sÃ©lecteur** pour quâ€™il ait lâ€™effet attendu.

Sass a un signe spÃ©cifique pour concatÃ©ner les sÃ©lecteurs parent et enfant : lâ€™**esperluette (&)** !

:::info
_ConcatÃ©ner_ signifie _relier_. Mettre une esperluette en prÃ©fixe devant un sÃ©lecteur le reliera directement au sÃ©lecteur parent
sans recourir Ã  des combinateurs.
:::

Magie. âœ¨

Ajoutons donc une esperluette avant notre pseudosÃ©lecteur `:hover`Â :

```scss
ul {
    list-style: none;
    text-align: right;
    li {
        display: inline;
        font-size: 3rem;
        color: #D6FFF5;
        &:hover {
            color: #001534;
        }
    }
}
```

Et voici le CSS qui en dÃ©coule :

```scss
ul {
    list-style: none;
    text-align: right;
}

ul li {
    display: inline;
    font-size: 3rem;
    color: #D6FFF5;
    }

ul li:hover {
    color: #001534;
}
```

Beaucoup mieux ! Maintenant, nous avons un :hover qui fonctionne pour nosÂ `<li>`, et tout Ã§a dans un seul bloc de code.

#### **Essayez par vous-mÃªme !**

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, utilisez lâ€™esperluette.

Console de code

<iframe title="codevolve" id="codevolveIframe2" src="https://www.codevolve.com/api/v1/access_token/EB0E7783DF5E5D0EC0A1700ACD537E0F" width="100%" height="500" frameborder="0"></iframe>

:::info
Retrouvez la [correction de l'exercice ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-1/chapitre-6/exercice-2) !
:::

### Nâ€™abusez pas du nesting

Il nâ€™y a pas rÃ©ellement de limite quant Ã  la profondeur du nesting quâ€™on peut opÃ©rer dans Sass. On serait tentÃ© de rÃ©pliquer
intÃ©gralement notre HTML dans Sass, en reproduisant une copie conforme de sa structure.

```scss
.parent-div {
    background-color: #15DEA5;
    .child-div {
        color: #fff;
        .grandchild-div {
            color: #D6FFF5;
        }
    }
}
```

Mais souvenez-vous, quand vous imbriquez des sÃ©lecteurs, vous augmentez la spÃ©cificitÃ© des sÃ©lecteurs compilÃ©s. De ce fait, si
vous les imbriquez trop, vous allez vous retrouver avec des sÃ©lecteurs de trÃ¨s haute spÃ©cificitÃ©, ce qui les rendra extrÃªmement
difficiles Ã  modifier ou outrepasser si besoin.

```scss
.parent-div {
    background-color: #15DEA5;
}

.parent-div .child-div {
    color: #fff;
}

.parent-div .child-div .grandchild-div {
    color: #D6FFF5;
}
```

Essayer dâ€™outrepasser un sÃ©lecteur aussi spÃ©cifique que .parent-div, .child-divÂ ou .grandchild-divÂ nÃ©cessiterait un sÃ©lecteur
encore plus spÃ©cifique. Sans compter que cela nuirait beaucoup Ã  la rÃ©utilisation de votre code. Ã€ moins dâ€™ajouter plus tard un
Ã©lÃ©ment qui corresponde parfaitement Ã  cette hiÃ©rarchie de classes, ce sÃ©lecteur sera complÃ¨tement inutile. Vous vous retrouverez
donc avec du code instable et difficile Ã  maintenir â€“ ce qui va Ã  lâ€™encontre de la raison dâ€™Ãªtre des prÃ©processeurs !

PlutÃ´t que dâ€™essayer de rÃ©pliquer exactement la structure du HTML, il est prÃ©fÃ©rable dâ€™Ã©crire des sÃ©lecteurs imbriquÃ©s qui soient
**uniquement relatifs au sÃ©lecteur racine**. Cela ne reproduira pas la structure HTML aussi clairement, mais permettra de
maintenir une spÃ©cificitÃ© basse dans votre codebase, ainsi quâ€™une certaine flexibilitÃ© et une certaine modularitÃ©.

Par exemple, si vous avez ce code et que vous voulez modifier lâ€™image :

```html
<section class="proj-prev proj-prev--mint">
    <div class="proj-prev__image">
        <img src="/public/img/photography_1280w.jpg" alt="project title goes here" >
    </div>
    <h1 class="proj-prev__heading">
        Project Title
    </h1>
    <p class="proj-prev__byline">
        project keywords would go here
    </p>
</section>
```

vous pourriez juste vous arrÃªter au sÃ©lecteur prÃ©cÃ©dent et avoir seulement votre baliseÂ `img`Â sans la nester dans `proj-prev`
puis `proj-prev image`Â :

```scss
.proj-prev{
    votre code ici
    img {
        color: #fff;
    }
}
```

En pratique, si vous vous retrouvez Ã  imbriquer au-delÃ  de **deux niveaux de profondeur**, arrÃªtez-vous et rÃ©flÃ©chissez Ã  la
faÃ§on dont vous Ãªtes en train de structurer votre bloc. Il y a des chances que vous soyez en train de crÃ©er des sÃ©lecteurs trop
spÃ©cifiques et devriez **refactoriser** votre code en consÃ©quence.

Le nesting dans Sass est un outil trÃ¨s performant qui vous aide Ã  regrouper les sÃ©lecteurs **pertinents** et ainsi bÃ¢tir une
codebase facile Ã  parcourir et Ã  maintenir. Toutefois, cela a pour inconvÃ©nient de crÃ©er une **surenchÃ¨re de spÃ©cificitÃ©**. Du
coup, vous vous dites peut-Ãªtre quâ€™il vaut mieux revenir au systÃ¨me BEM, avec lâ€™organisation et la structure que cela confÃ¨re Ã 
vos sÃ©lecteurs. Vous vous souvenez peut-Ãªtre aussi que BEM **repose sur un principe de basse spÃ©cificitÃ©**. Ce qui est lâ€™inverse
de lâ€™augmentation de spÃ©cificitÃ© gÃ©nÃ©rÃ©e par le nesting. Alors, quâ€™est-ce qui vaut mieux ? BEM ou nesting ?

La rÃ©ponse est : pourquoi pas les deux ! Mais avant de voir ensemble comment faire, rÃ©capitulons un peu ce que nous venons
dâ€™apprendre.

### **En rÃ©sumÃ©**

- Dans Sass, les sÃ©lecteurs peuvent Ãªtre imbriquÃ©s, ou nestÃ©s, dans dâ€™autres sÃ©lecteurs.
- Sass peut crÃ©er tous les combinateurs CSS.
- Utilisez lâ€™esperluette pour lier un sÃ©lecteur imbriquÃ© Ã  un sÃ©lecteur parent sans recourir Ã  un combinateur.
- Attention Ã  ne pas crÃ©er des sÃ©lecteurs trop spÃ©cifiques.

_Dans le chapitre suivant, nous allons combiner la puissance de Sass et lâ€™ordre de BEM pour crÃ©er des sÃ©lecteurs de basse
spÃ©cificitÃ©, tout en gardant la structure du nesting._

-----

## Utilisez des sÃ©lecteurs BEM avec Sass

[Utilisez des sÃ©lecteurs BEM avec Sass - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6596494-utilisez-des-selecteurs-bem-avec-sass)

<Vimeo vimeoId="534216657" />

<br />

Il est temps de fusionner tout ce que nous avons appris jusquâ€™ici ğŸ’ª

### IntÃ©grez les notions apprises

CommenÃ§ons par mettre en application ce que vous avez appris de la mÃ©thodologie BEM et du nesting de Sass. Si vous combinez des
sÃ©lecteurs BEM et le nesting de Sass pour crÃ©er un `block`Â et un `block__element`, vous obtiendrez quelque chose comme ceci :

```scss
.block{
    background-color: #15DEA5;
    .block__element {
        color: #fff;
    }
}
```

Ce qui donne en CSS :

```scss
.block {
    background-color: #15DEA5;
}

.block .block__element {
    color: #fff;
}
```

On se retrouve avec un sÃ©lecteur `block`Â ayant une spÃ©cificitÃ© de 0/0/1/0 et un sÃ©lecteur `block__element`Â avec une spÃ©cificitÃ©
de 0/0/2/0. Ce nâ€™est pas idÃ©al, mais tout fonctionnera comme vous le voulez, sans rÃ¨gles contradictoires.

Mais admettons que vous ayez Ã  prÃ©sent besoin de crÃ©er une **variation** de votre `block__element`Â pour changer sa couleur de
fond. Ceci implique de crÃ©er un sÃ©lecteur `block__element--modifier`, mais puisque vous avez augmentÃ© la spÃ©cificitÃ© de votre
Ã©lÃ©ment, vous devez aussi vous assurer que vous augmentez celle de vos modificateurs dâ€™au moins autant, sinon ils nâ€™auront pas
dâ€™effet.


<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
.block{
    background-color: #15DEA5;
    .block__element {
        color: #fff;
    }
    .block__element--modifier {
        background-color: #001534;
    }
}


```

</div>
<div style={{width:'49%'}}>

```css title="css"
.block {
    background-color: #15DEA5;
}

.block .block__element {
    color: #fff;
}

.block .block__element--modifier {
    background-color: #001534;
}
```

</div>
</div>

<br />

Les petites incohÃ©rences de spÃ©cificitÃ© entre sÃ©lecteurs crÃ©ent des **bugs** et des **comportements** **imprÃ©visibles**. Des
modificateurs et des Ã©lÃ©ments ayant des degrÃ©s de spÃ©cificitÃ© variables peuvent se retrouver **dÃ©pareillÃ©s**, et les rÃ¨gles que
vous vouliez outrepasser Ã  certains endroits ne le seront pas, ou alors elles seront outrepassÃ©es lÃ  oÃ¹ vous ne le vouliez pas.

Ce quâ€™il vous faut, câ€™est un moyen de **nester** dans Sass sans aller Ã  lâ€™encontre des principes BEM. Vous vous rappelez du
nesting avec des **esperluettes** ? Quand vous imbriquez avec une esperluette, cela relie le parent et lâ€™enfant dans le CSS
compilÃ©. Mais lâ€™enfant nâ€™a pas besoin dâ€™Ãªtre un sÃ©lecteur, il peut aussi sâ€™agir de simple texte !

Dans notre nest pour `block__element`, remplaÃ§ons la partie â€œblocâ€ par une esperluette :

```scss
.block{
    background-color: #15DEA5;
    &__element {
        color: #fff;
    }
}
```

Il en rÃ©sulte un sÃ©lecteur dâ€™Ã©lÃ©ment BEM identique dans son comportement aux sÃ©lecteurs dâ€™Ã©lÃ©ments que nous avons Ã©crits
manuellement dans le troisiÃ¨me chapitre, mais avec le bÃ©nÃ©fice supplÃ©mentaire de nâ€™avoir Ã  Ã©crire â€œblocâ€ quâ€™une fois et de
pouvoir profiter des formidables fonctionnalitÃ©s de structure et de regroupement offertes par Sass.

```scss
.block {
    background-color: #15DEA5;
}

.block__element {
    color: #fff;
}
```

Maintenant, nous avons un sÃ©lecteur dâ€™Ã©lÃ©ment avec une spÃ©cificitÃ© basse de 0/0/1/0, comme nous le voulions.

Retournons Ã  notre `block__element--modifier`Â et recrÃ©ons-le en utilisant les mÃªmes principes que pour crÃ©er le `block__element` :

```scss
.block{
    background-color: #15DEA5;
    &__element {
        color: #fff;
        &--modifier {
            background-color: #001534;
        }
    }
}
```

Nous obtenons un CSS compilÃ© parfaitement conforme avec ce que nous voulions :

```scss
.block {
    background-color: #15DEA5;
}

.block__element {
    color: #fff;
}

.block__element--modifier {
    background-color: #001534;
}
```

#### **Essayez par vous-mÃªme !**

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, utilisez le refactoring sur un ancien exercice tout en faisant attention Ã  la spÃ©cificitÃ©.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/03CD6231588682860589CDBEAE4212A7" width="100%" height="500" frameborder="0"></iframe>

:::info
Avez-vous rÃ©alisÃ© l'exercice ? [Comparez votre travail avec la correction](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-1/chapitre-7/exercice-1).
:::

Vous avez crÃ©Ã© des **sÃ©lecteurs BEM** en utilisant la **structure Ã©purÃ©e** de Sass, ce qui vous permettra de vous assurer que
votre code demeure bien organisÃ© et facile Ã  modifier. De plus, vous vous Ãªtes Ã©pargnÃ© le travail de devoir taper le nom du bloc
encore et encore et encoreâ€¦

Vous avez Ã©chappÃ© Ã  bien des tendinites au poignet ! ğŸ™ŒÂ  Et tous vos sÃ©lecteurs ont la spÃ©cificitÃ© la plus basse qui soit :
**0/0/1/0** !

Je sais, je saisâ€¦ Je vous vois dâ€™ici lever les yeux au ciel. ğŸ™„ SpÃ©cificitÃ© plate, spÃ©cificitÃ© basseâ€¦ Je suis obsÃ©dÃ©e.ğŸ¤“ Câ€™est
possible.

Mais il y a une raison Ã  cela. Comme pour tout dans la vie, il y a un temps et un lieu pour chaque chose.

### Utilisez les spÃ©cificitÃ©s lÃ  oÃ¹ vous en avez besoin

Juste parce que nous avons Ã©vitÃ© jusquâ€™Ã  prÃ©sent dâ€™augmenter la **spÃ©cificitÃ©**Â ne veut pas nÃ©cessairement dire que nous ne le
ferons jamais. La spÃ©cificitÃ© nâ€™est pas mauvaise en soi, mais il y a un temps et un lieu pour sâ€™en servir. En maintenant la
spÃ©cificitÃ© au minimum, il devient beaucoup plus simple de crÃ©er un **modificateur** capable dâ€™outrepasser les propriÃ©tÃ©s
souhaitÃ©es.

Disons que nous avons crÃ©Ã© un bouton avec un fond uni et un bouton modifiÃ© avec un fond transparent et un contour, ainsi :

```scss
.btn {
    display: inline-block;
    margin: 0 auto;
    background: #15DEA5;
    padding: 1rem;
    &--outline {
        background: transparent;
        border: 2px solid #15DEA5;
    }
}
```

Pour reprÃ©senter un **bouton dÃ©sactivÃ©**, il faut le griser, ce qui implique de crÃ©er un autre modificateur. Dans le cas dâ€™un
bouton standard, cela veut dire mettre un fond gris, et dans le cas du bouton avec contour, rendre ce contour gris. Vous pourriez
donc crÃ©er deux nouveaux modificateurs, un pour chaque bouton, mais cela voudrait dire encore des noms de sÃ©lecteurs Ã  retenir,
sans compter que Ã§a ajouterait du dÃ©sordre dans votre code.

Devinez ce qui simplifierait beaucoup tout Ã§aâ€¦ Mais oui, **augmenter la spÃ©cificitÃ©** !

Nous allons donc Ã©crire deux nouveaux modificateurs, un pour chaque instance du bouton, mais nous utiliserons le mÃªme nom pour
les deux. Pour les diffÃ©rencier, nous allons compter sur le **nesting** dans Sass, afin de crÃ©er des **sÃ©lecteurs spÃ©cifiques**
pour chaque type de bouton.

```scss
.btn {
    display: inline-block;
    margin: 0 auto;
    background: #15DEA5;
    padding: 1rem;
    &--disabled {
        background: grey;
    }
    &--outline {
        background: transparent;
        border: 2px solid #15DEA5;
        &.btn--disabled{
            border: 2px solid grey;
        }
    }
}
```

Nous utilisons lâ€™esperluette pour crÃ©er deux sÃ©lecteurs distincts. Le premier est un **modificateur** **standard**,
`btn--disabled`, qui outrepassera la couleur de fond de `.btn`Â pour la mettre en gris. Le second est un **sÃ©lecteur** avec deux
classes, `.btn--outline`Â etÂ `.btn--disabled`, ce qui signifie que les deux classes doivent Ãªtre appliquÃ©es afin que les rÃ¨gles
que comporte ce sÃ©lecteur entrent en vigueur pour changer la couleur du contour en gris.

```scss
.btn {
    display: inline-block;
    margin: 0 auto;
    background: #15DEA5;
    padding: 1rem;
}

.btn--disabled {
    background: grey;
}

.btn--outline {
    background: transparent;
    border: 2px solid #15DEA5;
}

.btn--outline.btn--disabled {
    border: 2px solid grey;
}
```

Vous vous retrouvez avec quatre sÃ©lecteurs diffÃ©rents :
1. Le bouton : `.btn`
2. Le modificateur pour le contour du bouton : `.btn--outline`
3. Le modificateur qui rend le bouton gris : `.btn-disabled`
4. Le modificateur qui rend le contour du bouton gris : `.btn--outline.btn--disabled`

Techniquement, le quatriÃ¨me de ces sÃ©lecteurs a une spÃ©cificitÃ© de deux, maisÂ `.btn--disabled`Â marche aussi sans `.btn--outline`,
ce qui en fait un systÃ¨me modulaire et rÃ©utilisable, pour lequel vous pouvez ajouter ou retirer la classe : lâ€™Ã©lÃ©ment se
comportera toujours comme souhaitÃ©.

#### **Essayez par vous-mÃªme !**

![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)

Dans cet exercice, crÃ©ez plusieurs sÃ©lecteurs et augmentez la spÃ©cificitÃ©.

Console de code

<iframe title="codevolve" id="codevolveIframe2" src="https://www.codevolve.com/api/v1/access_token/9425E5E8358847296184B64C917FF788" width="100%" height="500" frameborder="0"></iframe>

Retrouvez ici, [la correction de l'exercice](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-1/chapitre-7/exercice-2).

### Ajoutez des sÃ©lecteurs spÃ©cifiques Ã  votre HTML

Mettons ces sÃ©lecteurs en application en les intÃ©grant dans du HTML. PremiÃ¨rement, crÃ©ons deux boutons, un avec contour et un
sans :

```html
<div class="container">
    <div class="btn">Solid Button</div>
    <div class="btn btn--outline">Outline Button</div>
</div>
```

![Image d'un bouton avec contour et d'un bouton sans contour](https://user.oc-static.com/upload/2019/10/22/15717522549903_image10.png)

Un bouton avec contour et un bouton sans contour

Ã€ prÃ©sent, dÃ©sactivons-les tous les deux en appliquant nos deux sÃ©lecteurs restants :

```html
<div class="container">
    <div class="btn btn--disabled">Solid Button</div>
    <div class="btn btn--outline btn--disabled">Outline Button</div>
</div>
```

![Image d'un bouton vide et d'un bouton rempli dÃ©sactivÃ©s](https://user.oc-static.com/upload/2019/10/22/15717523887269_image5.png)

Un bouton vide et un bouton rempli dÃ©sactivÃ©s

Disons que vous voulez que votre premier bouton ait un fond transparent et un contour, comme le second. Tout ce que vous avez Ã 
faire, câ€™est appliquer le modificateur concernÃ© :

```html
<div class="container">
    <div class="btn btn--disabled btn--outline">Solid Button</div>
    <div class="btn btn--outline btn--disabled">Outline Button</div>
</div>
```

![Images de boutons avec un fond transparent](https://user.oc-static.com/upload/2019/10/22/15717524348464_image1.png)

DesÂ boutons avec un fond transparent

GrÃ¢ce Ã  la **spÃ©cificitÃ© accrue** de la combinaison dÃ©tourÃ©/dÃ©sactivÃ©, ajouter la mÃªme classe dans deux situations diffÃ©rentes
produit deux rÃ©sultats diffÃ©rents mais prÃ©visibles. Pas besoin de vous soucier de retenir tout un tas de sÃ©lecteurs trÃ¨s
spÃ©cifiques, ni de vous inquiÃ©ter du fait que si vous supprimez un modificateur, un autre risque dâ€™avoir un comportement
imprÃ©visible.

En utilisant la spÃ©cificitÃ© accrue seulement lÃ  oÃ¹ câ€™est nÃ©cessaire, vous pouvez crÃ©er un systÃ¨me de sÃ©lecteurs qui est non
seulement propre et maintenable, mais aussi stable et prÃ©visible.

### En rÃ©sumÃ©

Pas de panique si votre cerveau frise la surchauffe. Ã‡a veut dire que vous Ãªtes en train dâ€™apprendre. Et pas quâ€™un peu ! Nous
avons branchÃ© votre cerveau sur la matrice et vous venez de tÃ©lÃ©charger lâ€™Ã©quivalent de lâ€™art du kung fu en matiÃ¨re de CSS.

Focalisez-vous plutÃ´t sur les points clÃ© :
- **les incohÃ©rences de spÃ©cificitÃ©** entre diffÃ©rents sÃ©lecteurs crÃ©eront des bugs et des comportements imprÃ©visibles ;
- utilisez **les esperluettes pour un nesting** efficace dans Sass sans froisser les principes BEM ;
- utilisez le nesting et la spÃ©cificitÃ© pour crÃ©er **un systÃ¨me de sÃ©lecteurs maintenable** dans Sass.

_Et maintenant, revenons sur tout ce que vous avez appris avec le quiz de fin de section ! Une fois que vous avez fini de rÃ©viser,
je vous retrouve dans la section suivante et nous apprendrons encore des tas de trucs Sass magiques._

-----

## Quiz : Structurez et organisez votre code

[Structurez et organisez votre code - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/exercises/3705)

#### CompÃ©tences Ã©valuÃ©es

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Structurer et organiser son code

-----

#### Description

Ã€ vous de jouer en rÃ©pondant aux questions de ce quiz !

Bonne chance !

#### Question 1 : Quelle est la bonne faÃ§on de nommer un modificateur ?
    
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
.block--modifier {...}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block__modifier {...}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block .modifier {...}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block-modifier {...}
```

*Lorsque vous nommez vos modificateurs, vous utilisez toujours le nom du bloc ou de lâ€™Ã©lÃ©ment modifiÃ©, suivi de deux tirets puis
de la faÃ§on dont vous le modifiez. Pour nommer un modificateur qui passe le fond du `.btn`Â en vert, vous Ã©crivez donc :
`.btn--green`*

-----

#### Question 2 : Avec le HTML suivant :

```html
<div id="header" class="header">
    Header Content!
</div>
```

**et le CSS suivant :**

```scss
#header {
    background-color: blue;
}

.header {
    background-color: green;
}
```

**de quelle couleur sera le fond de la `<div>` ?**
    
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Bleue (blue)<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Verte (green)<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Les deux<br />
<br />

*Le sÃ©lecteur `#header`Â a une plus forte spÃ©cificitÃ© car les id ont une plus haute spÃ©cificitÃ© que les sÃ©lecteurs classes.*

*Regardez,Â `#header`Â a une spÃ©cificitÃ© de :*

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 1 | 0 | 0 |

*et le sÃ©lecteur `.header`Â a une spÃ©cificitÃ© de :*

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | 1 | 0 |

*Quand il y a des propriÃ©tÃ©s CSS contradictoires entre deux sÃ©lecteurs, le navigateur passe en revue le tableau de spÃ©cificitÃ© de
gauche Ã  droite, jusquâ€™Ã  ce quâ€™il trouve un gagnant. Dans notre cas,Â `#header`Â lâ€™emporte avec un score de 1 contre 0 pour
`.header`. Le navigateur utilisera donc la couleur de `#header`, soit blue !*

-----

#### Question 3 : Un sÃ©lecteur nommÃ© `.recipe-card`Â appartient Ã  quelle catÃ©gorie BEM ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Bloc<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Ã‰lÃ©ment<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Modificateur<br />
<br />

*Les noms que vous donnez aux blocs doivent dÃ©crire leur fonction ou rÃ´le dans le site, par exemple une recette de cuisine comme
ici. Notre sÃ©lecteur ne contient pas de double underscore : ce nâ€™est pas un Ã©lÃ©ment ; pas de double tiret : ce nâ€™est pas un
modificateur ; il sâ€™agit donc dâ€™un sÃ©lecteur de bloc !*

-----

#### Question 4 : Parmi les extraits suivants, lesquels utilisent le nesting ?

*Attention, plusieurs rÃ©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> 

```scss
.block {
    background-color: #15dea5;
}
.div {
    margin: 1rem;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> 

```scss
.block {
    background-color: #15dea5;
    div {
        margin: 1rem;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> 

```scss
.block {
    background-color: #15dea5;
    &__element{
        background-color: #de15d0;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> 

```scss
.block {
    background-color: #15dea5;
}
.block div {
    margin: 1rem;
}
```

*Le nesting est le fait dâ€™imbriquer les sÃ©lecteurs dans dâ€™autres sÃ©lecteurs entre des accolades en utilisant des combinateurs ou
une esperluette, et ainsi de reproduire une architecture en CSS comme en HTML.*

-----

#### Question 5 : En partant avec ce HTML :

```html
<div class="header">
    <div class="content">
        <p>Je suis un paragraphe de la div content et mon background est blanc</p>
    </div>
</div>
```

et avec le CSS suivant :

```scss
.header {
    background-color: red;
}
```

**quels combinateurs pouvez-vous appliquer Ã Â `.header`Â pour faire en sorte que le background deÂ `.content`Â soit en rouge ?**

*Attention, plusieurs rÃ©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Descendant<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Parent > Enfant<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> Adjacent<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> Parent<br />
<br />

*Pour obtenir unÂ  background de couleur rouge pour `.content`Â juste en appliquant un combinateur Ã  `.header`, vous pouvez
utiliser le combinateur descendant :*

```scss
.header .content {
    background-color: red;
}
```

*et parent enfant :*

```scss
.header >.content {
    background-color: red;
}
```

-----

#### Question 6 : Dans Sass, sous quelle forme se compile le symbole esperluette (&) ?
    
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Lâ€™esperluette (&)<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Le combinateur frÃ¨re adjacent<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Le parent du sÃ©lecteur dans la hiÃ©rarchie<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Le sÃ©lecteur racine dans la hiÃ©rarchie<br />
<br />

*Dans Sass, lâ€™esperluette se compile en tant que sÃ©lecteur parent, ce qui facilite la construction et la maintenance de
nomenclatures complexes telles que BEM, ou de pseudosÃ©lecteurs tels que `:hover`.*

-----

#### Question 7 :

```scss
.block {
    &__element {
        background-color: #15dea5;
    }
}
```

**Le morceau de Sass ci-dessus serait compilÃ© en CSS sous laquelle de ces formes ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block&__element {
    background-color: #15dea5;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> 

```scss
.block__element {
    background-color: #15dea5;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block .__element {s
    background-color: #15dea5;
}
```

*Quand vous faites du nesting dans Sass, lâ€™esperluette est remplacÃ©e par le nom du parent quand elle est compilÃ©e en CSS. Le
prÃ©fixe â€˜&â€™ dans le bout de code de la question est donc remplacÃ© par `.block`Â une fois compilÃ©, ce qui crÃ©e un sÃ©lecteur nommÃ©
`.block__element`.*

-----

#### Question 8 : Lequel de ces morceaux de Sass gÃ©nÃ¨re le sÃ©lecteur CSS le plus spÃ©cifique ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>


```scss
.block {
    &__element {
        color: #fff;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> 

```scss
.block {
    .element {
        color: #fff;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block {
    &__element {
        div {
            color: #fff;
        }
    }
}
```

*Le sÃ©lecteur de la premiÃ¨re rÃ©ponse se compilerait en `.block__element {...}`Â et aurait une spÃ©cificitÃ© de :

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | 1 | 0 |

*Le sÃ©lecteur de la deuxiÃ¨me rÃ©ponse se compilerait en `.block .element {...}`Â et aurait une spÃ©cificitÃ© de :

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | 2 | 0 |

*Le sÃ©lecteur de la troisiÃ¨me rÃ©ponse se compilerait en `.block__element div {...}`Â et aurait une spÃ©cificitÃ© de :

| Inline | ID | Class | Element |
|:------:|:--:|:-----:|:-------:|
| 0 | 0 | 1 | 1 |

*La deuxiÃ¨me rÃ©ponse a la spÃ©cificitÃ© la plus Ã©levÃ©e des trois : elle a un score de classe de 2, contre 1 pour les premiÃ¨re et
troisiÃ¨me rÃ©ponses.*

*Quand on procÃ¨de au nesting sans esperluette ni autre combinateur CSS, le CSS se compile sous forme de combinateur descendant,
ce qui concatÃ¨ne le nom du parent avant le nom quâ€™on a donnÃ© au sÃ©lecteur imbriquÃ© ; ce qui nâ€™est pas le cas quand on utilise une
esperluette.*

-----

#### Question 9 : Lequel de ces bouts de Sass donnerait le code CSS suivant :

```scss
.block {
    background-color: #15dea5;
}
.block__element {
    background-color: #de15d0;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block {
    background-color: #15dea5;
    &-element {
        background-color: #de15d0;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block {
    background-color: #15dea5;
    .element {
        background-color: #de15d0;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.block {
    background-color: #15dea5;
    __element {
        background-color: #de15d0;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> 

```scss
.block {
    background-color: #15dea5;
    &__element {
        background-color: #de15d0;
    }
}
```

*Pour obtenir un sÃ©lecteur imbriquÃ© qui se compile en `.block__element`, vous devez avoir un sÃ©lecteur parent nommÃ© `.block`Â et
un sÃ©lecteur enfant qui utilise lâ€™esperluette pour se relier au nom du parent en utilisant le prÃ©fixe requis, `__element`.*

*La rÃ©ponse nÂ° 1 se compilerait ainsi :*

```scss
.block {
    background-color: #15dea5;
}
.block-element {
    background-color: #de15d0;
}
```

*La rÃ©ponse nÂ° 2 se compilerait ainsi :*

```scss
.block {
    background-color: #15dea5;
}
.block .element {
    background-color: #de15d0;
}
```

*La rÃ©ponse nÂ° 3 se compilerait en un CSS non valide :*

```scss
.block {
    background-color: #15dea5;
}
.block __element {
    background-color: #de15d0;
}
```

*Et la rÃ©ponse nÂ° 4 se compilerait sous la forme indiquÃ©e dans la question :*

```scss
.block {
    background-color: #15dea5;
}
.block__element {
    background-color: #de15d0;
}
```

*La syntaxe `.scss`Â de Sass est basÃ©e sur la syntaxe standardisÃ©e de CSS. Les fonctionnalitÃ©s avancÃ©es offertes par Sass telles
que le nesting nÃ©cessitent des maniÃ¨res supplÃ©mentaires de mettre en forme le code. Mais du code CSS valide reste parfaitement
valide en `.scss`.*

-----

#### Question 10 : Vous voulez crÃ©er deux nouveaux boutons, un dont les bords seront ronds et un dont la couleur de fond est #185730, tout en conservant les propriÃ©tÃ©s de votre premier bouton ci-dessous.

```scss
.btn {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
}
```

**En appliquant le principe du DRY, quel rÃ©sultat pourrait-on obtenir ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 

```scss
.btn-first {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
}
.btn-green {
    background-color: #185730;
    color: #fff;
    padding: 1.5rem;
}
.btn-rounded {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
    border-radius: 25px;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 

```scss
.btn {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
    border-radius: 25px;
}
.btn-green {
    background-color: #185730;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> 

```scss
.btn {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
}
.btn-green {
    background-color: #185730;
}
.btn-rounded {
    border-radius: 25px;
}
```

*Le principe du DRY est de ne pas se rÃ©pÃ©ter, afin dâ€™avoir un code facilement maintenable et modulable.*

*Dans cet exercice, il vous faut avoir un bouton que vous utiliserez comme base pour vos prochains boutons, et ainsi crÃ©er une
classe seulement pour une propriÃ©tÃ© spÃ©cifique.*

*La premiÃ¨re rÃ©ponse vous permet dâ€™avoir trois boutons comme la consigne le demande, mais elle contient beaucoup trop de
rÃ©pÃ©titions : les propriÃ©tÃ©s de votre bouton de base sont rÃ©pÃ©tÃ©es plusieurs fois dans tous les sÃ©lecteurs.*

```scss
.btn-first {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
}
.btn-green {
    background-color: #185730;
    color: #fff;
    padding: 1.5rem;
}
.btn-rounded {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
    border-radius: 25px;
}
```

*Pour la deuxiÃ¨me, vous Ãªtes sur la bonne voie : vous avez un bouton de base, et une classe qui rend votre bouton vert ; mais
votre bouton de base rendra tous vos boutons avec des bords carrÃ©s, alors quâ€™on vous demande un bouton aux bords arrondis.*

```scss
.btn {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
    border-radius: 25px;
}
.btn-green {
    background-color: #185730;
}
```

*La troisiÃ¨me rÃ©ponse est la bonne. Vous avez un bouton de base, puis une classe pour chacune des propriÃ©tÃ©s que vous pourrez
appliquer dans votreÂ HTML Ã  vos boutons. Pas de rÃ©pÃ©titions, et un code maintenable facilement !*

```scss
.btn {
    background-color: #001534;
    color: #fff;
    padding: 1.5rem;
}
.btn-green {
    background-color: #185730;
}
.btn-rounded {
    border-radius: 25px;
}
```

