---
sidebar_position: 3
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# CrÃ©ez du code maintenable grÃ¢ce aux techniques Sass intermÃ©diaires

## AmÃ©liorez la maintenabilitÃ© du code avec les variables Sass

[AmÃ©liorez la maintenabilitÃ© du code avec les variables Sass - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6597580-ameliorez-la-maintenabilite-du-code-avec-les-variables-sass)

<Vimeo vimeoId="534354241" />

<br />

### Tirez parti de la force de Sass

Quand jâ€™Ã©tais ado, jâ€™Ã©tais obsÃ©dÃ©e par le surf.Â Je passais mes Ã©tÃ©s au bord de lâ€™ocÃ©an Ã  regarder les surfeurs. Jâ€™ai voulu faire
comme eux ; alors aprÃ¨s un cours je prends une planche grande et assez large pour que ce soit plus facile et je pars Ã  lâ€™eau.
Impossible de me lever, pourtant jâ€™observe les surfers et jâ€™essaie jâ€™essaie, je lance mes jambes sur le cÃ´tÃ©, jâ€™essaie de sauter
sur la planche, je me dis que jâ€™ai une planche stable et que je devrais rÃ©ussir, et pourtant rien ne fonctionne.

Au bout dâ€™un moment, une surfeuse passe prÃ¨s de moi et je lui demande conseil en lui expliquant que je nâ€™arrive pas Ã  poser mes
pieds sur la planche assez rapidement et Ã  rester debout. Elle me regarde faire, sâ€™approche, me montre comment positionner mes
pieds et mâ€™explique pendant un moment. Puis elle me dit de mâ€™Ã©lancer sur la planche, sans rÃ©flÃ©chir, de pousser sur mes bras et de
ramener mes jambes au-dessous de mes hanches. Et lÃ , je me suis levÃ©e ! Bon, et je suis tombÃ©e juste aprÃ¨s, certes.

La morale de cette histoireÂ est que la question nâ€™est pas de choisir la bonne planche, câ€™est aussi de savoir lâ€™utiliser. Et câ€™est
pareil avec Sass.

#### Travailler mieux, pas plus dur.

Le plus important, ce nâ€™est pas seulement de choisir le bon outil, mais de bien savoir lâ€™utiliser. ğŸ’ª

GrÃ¢ce aux outils de Sass, vous allez rendre votre vie de dÃ©veloppeur CSS beaucoup plus facile, Ã  la fois en rÃ©duisant la quantitÃ©
de code Ã  Ã©crire et en le rendant plus simple Ã  modifier et Ã  maintenir Ã  lâ€™avenir.

### Utilisez des variables pour gÃ©rer les couleurs

Notre site nâ€™utilise quâ€™une poignÃ©e de couleurs, certes, mais nous les utilisons sans arrÃªt. Entre nous, retenir les couleurs par
leur **codes couleur hexadÃ©cimaux** tels que #16FFBD etÂ #001534 et savoir quelles couleurs ils reprÃ©sentent, câ€™est compliquÃ© et
pas franchement trÃ¨s pratique. Pour y remÃ©dier, je nâ€™ai pour le moment quâ€™une solution : parcourir mon fichier, chercher une autre
instance de cette couleur, et la copier-coller. Mais câ€™est une sacrÃ©e perte de temps et cela peut devenir rapidement **pÃ©nible**
et surtout **dangereux**.

:::note ?
PÃ©nible je comprends, mais pourquoi dangereux ?
:::

Le client pourrait demander un **changement** de couleur sans prÃ©venir, et vous allez devoir repasser en revue touuuuuut le
fichier pour modifier les valeurs Ã  la main, une par une. Câ€™est souvent comme Ã§a que les erreurs apparaissent.

Juste en jetant un coup dâ€™Å“il Ã  notre bloc `.form`, vous pouvez voir que nous avons systÃ©matiquement rÃ©pÃ©tÃ© les quatre mÃªmes
valeurs hexadÃ©cimales (#15DEA5, #D6FFF5,Â  #001534, #fff) :

```scss
.form {
    width: 100%;
    padding-bottom: 1.5rem;
}
.form__heading {
    width: 100%;
    color: #fff;
    text-shadow: 0.55rem 0.55rem #11af82;
    background: #15DEA5;
    line-height: 5rem;
    padding: 1.5rem;
}
.form__field label {
    color: #D6FFF5;
    display: block;
    font-size: 2rem;
    line-height: 2rem;
    padding-top: 1.5rem;
}
.form__field input {
    width: 100%;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    padding: 1.5rem;
    color: #D6FFF5;
}
.form__field textarea {
    width: 100%;
    color: #15DEA5;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    outline: none;
    padding: 1.5rem;
    margin-bottom: 0.75rem;
}
```

Comment pourrions-nous rendre ce code plus **lisible** et **organisÃ©** ? Mmmh... si on pouvait dÃ©finir une couleur **une seule
fois** et la **rÃ©fÃ©rencer** Ã  chaque fois quâ€™on en a besoin, ce serait vraiment pratique. Eh bien, heureusement pour nous, il
existe bien une solution pour le faire, et câ€™est une **variable** ! ğŸ™Œ

Les variables sont comme des **boÃ®tes**. On les remplit avec quelque chose, dans notre cas des valeurs de couleurs (ou des amandes)
et on y colle une **Ã©tiquette** pour savoir ce quâ€™il y a dedans. Ainsi, votre collÃ¨gue Anna sait que ce sont vos amandes, dans le
placard, et nâ€™y touche pas (je tâ€™ai Ã  lâ€™Å“il, Anna). Et en plus, vous savez exactement ce quâ€™il y a dedans grÃ¢ce Ã  lâ€™Ã©tiquette.

Maintenant, vous pouvez emmener cette boÃ®te partout avec vous. Non, parce quâ€™avec Anna, on nâ€™est jamais trop prudent (je rigole ğŸ˜).
Quand jâ€™ai besoin du contenu du tupperware, pour dÃ©finir la couleur dâ€™un texte par exemple, il me suffit de lâ€™ouvrir. Bon appÃ©tit ! ğŸ¤¤

:::info
Anna est lâ€™objet dâ€™une mÃ©taphore servant Ã  illustrer le concept de variable. Toute ressemblance avec des personnes rÃ©elles,
vivantes ou mortes, ne saurait Ãªtre que purement fortuite.
:::

En programmation, lâ€™Ã©quivalentÂ deÂ _remplir son tupperware de nourriture_ sâ€™appelle **dÃ©clarer une variable**. Pour dÃ©clarer une
variable dans Sass, il vous suffit de taper un **symbole dollar ($)** suivi de son nom, puis deux points et enfin la valeur que
vous souhaitez lui donner :

```scss
$mint: #15DEA5;
```

Ã€ prÃ©sent, si vous regardez le CSS compilÃ©, vous verrezâ€¦ absolument rien du tout.

Câ€™est parce que lorsque Sass compile les variables en CSS, il remplace **lâ€™instance de la variable** directement par sa valeur, et
comme vous nâ€™avez pas encore utilisÃ© cette variable, il nâ€™y a absolument rien Ã  compiler.

OK, utilisons cette **variable** ! ğŸ’ª Modifions Ã  prÃ©sent les couleurs vert menthe (#15DEA5) de notre `.form`Â pour utiliser notre
nouvelle variable. Pour implÃ©menter une variable dans Sass, tapez le nom de la variable Ã  lâ€™endroit oÃ¹ vous auriez normalement
insÃ©rÃ© la valeur correspondante. Dans notre cas pour remplacer #15DEA5Â par notre variable $mint , Ã§a nous donne :

```scss
$mint: #15DEA5;
.form {
    width: 100%;
    padding-bottom: 1.5rem;
}
.form__heading {
    width: 100%;
    color: #fff;
    text-shadow: 0.55rem 0.55rem #11af82;
    background: $mint;
    line-height: 5rem;
    padding: 1.5rem;
}
.form__field label {
    color: #D6FFF5;
    display: block;
    font-size: 2rem;
    line-height: 2rem;
    padding-top: 1.5rem;
}
.form__field input {
    width: 100%;
    background: #001534;
    border: 0.1rem solid $mint;
    padding: 1.5rem;
    color: #D6FFF5;
}
.form__field textarea {
    width: 100%;
    color: $mint;
    background: #001534;
    border: 0.1rem solid $mint;
    outline: none;
    padding: 1.5rem;
    margin-bottom: 0.75rem;
}
```

On peut voir que nous avons des instances de notre variable $mint partout oÃ¹ nous avions auparavant utilisÃ© notre valeur hex vert
menthe #15DEA5.

Maintenant, quand vous regardez le CSS compilÃ©, vous voyez bien que Sass a remplacÃ© le nom de la variable par la **valeur
correspondante** :

```scss
.form {
    width: 100%;
    padding-bottom: 1.5rem;
}
.form__heading {
    width: 100%;
    color: #fff;
    text-shadow: 0.55rem 0.55rem #11af82;
    background: #15DEA5;
    line-height: 5rem;
    padding: 1.5rem;
}
.form__field label {
    color: #D6FFF5;
    display: block;
    font-size: 2rem;
    line-height: 2rem;
    padding-top: 1.5rem;
}
.form__field input {
    width: 100%;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    padding: 1.5rem;
    color: #D6FFF5;
}
.form__field textarea {
    width: 100%;
    color: #15DEA5;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    outline: none;
    padding: 1.5rem;
    margin-bottom: 0.75rem;
}
```

:::info
Notez que le **CSS standard** a lui aussi des variables quâ€™on appelle "**custom properties**" et qui fonctionnent de la mÃªme
maniÃ¨re que les variables Sass. La plupart du temps, il nâ€™y a pas de vÃ©ritable avantage Ã  utiliser des custom properties plutÃ´t
que des variables Sass, surtout que leur syntaxe est bien plus compliquÃ©e. On optera donc **sans hÃ©siter** pour les variables Sass.
:::

Puisquâ€™il y aura forcÃ©ment des changements, ne soyez pas trop spÃ©cifique lorsque vous nommez vos variables. $mint fonctionne trÃ¨s
bien pour un vert menthe câ€™est sÃ»r, mais imaginons que le client se lasse du vert et veuille du rose. Super simple : on a juste Ã 
modifier la valeur hex :

```scss
$mint: #ffa7c2;
```

Sauf quâ€™Ã  prÃ©sent, $mint nâ€™a plus aucun sens, comme nous avons une couleur rose Ã  la place. Le problÃ¨me, câ€™est que nous
lâ€™utilisons un paquet de fois dans notre codebase et Ã§a peut porter Ã  confusion, si un jour unÂ autre dÃ©veloppeur rÃ©cupÃ¨re votre
code : il ou elle pensera en voyant le nom que la couleur est vert menthe et non rose. Deux solutions sâ€™offrent Ã  nous : soit on
garde $mint comme nom de variable et on fait avec (mauvaise idÃ©e), soit on donne un nouveau nom plus adÃ©quat Ã  la variable :

```scss
$pink:#ffa7c2;
```

![Image illustrant une erreur dans le code](https://user.oc-static.com/upload/2019/10/09/15706289362303_image5.jpg)

Il y a une erreur dans le code

Aaaaaargh ! Quâ€™est-ce qui sâ€™est passÃ© ? On a cassÃ© Internet (ou du moins notre fichier Sass) ! ğŸ˜¨ Lâ€™erreur stipule "Undefined
variable..." (ou _variable non dÃ©finie_ en franÃ§ais).

Tout notre code utilise encore la **variable** $mint, sauf quâ€™elle nâ€™existe plus. Quand nous avons changÃ© son nom en $pink, $mint
a cessÃ© dâ€™exister, sauf que nous lâ€™utilisons encore dans toute notre codebase. Ooooooops. Pour que Ã§a fonctionne, on doit
remplacer tous les $mint par des $pink.

Une meilleure idÃ©e pour Ã©viter ce genre de soucis serait de **nommer la variable en fonction de son rÃ´le** plutÃ´t que son contenu.
Par exemple, les mains dâ€™Anna sont remplies de mes amandes aujourdâ€™hui, mais demain elles pourraient Ãªtre remplies de mes noisettes.
Il serait donc plus logique de lui donner le nom de â€œvoleuse de grainesâ€, parce que visiblement elle nâ€™a pas lâ€™intention de
sâ€™arrÃªter.

Au lieu de $mint/$pink, il est prÃ©fÃ©rable dâ€™opter pour quelque chose comme **$color-primary** (_couleur principale_ en anglais).
Le nom de la variable vous indique que son rÃ´le est de stocker la couleur principale de votre site, quâ€™il sâ€™agisse de vert menthe,
de rose ou de jaune fluo. LÃ  oÃ¹ Ã§a devient intÃ©ressant, câ€™est que lorsque vous vous replongerez dans votre code dâ€™ici quelques
mois ou quelques annÃ©es, le nom $color-primaryÂ  vous dira toujours quelque chose. Une variable appelÃ©e $mint qui contient du rose
vous donnera certainement une sacrÃ©e migraine...

#### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, remplacez les couleurs dans le code par des variables que vous allez crÃ©er.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/32AC0A152BF6C46A6EF79C81A91D454E" width="100%" height="500" frameborder="0"></iframe>

:::info
[Retrouvez la correction de l'exercice ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-1/exercice-1) !
:::

Et les variables, ce nâ€™est pas que pour les couleurs ! Il y a huit types de donnÃ©es en tout dans Sass :
- **les couleurs :** on vient dâ€™en parler ;
- **les chaÃ®nes de caractÃ¨res (strings) :** terme de programmation signifiant du texte ;
- **les nombres :** oui, des nombres ;
- **les listes et maps :** des collections de nâ€™importe quels Ã©lÃ©ments ci-dessus. On en parlera plus tard ;
- et trois autres que vous pouvez laisser de cÃ´tÃ© pour le moment : les **boolÃ©ens (boolean),** les **nulls** et les **fonctions**.

:::info
Dans ce cours, nous aborderons seulement les cinq premiers Ã©lÃ©ments de cette liste, mais pour votre culture gÃ©nÃ©rale, sachez juste
que les trois autres existent. Je vous recommande de vous renseigner dessus en lisant la **[documentation Sass](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#data_types)**.
:::

### En rÃ©sumÃ©

- Les variables stockent des valeurs que vous pouvez rÃ©utiliser dans tout votre codebase.
- Pour dÃ©finir une variable, tapez le signe dollar ($) puis le nom de la variable : $variable-name.
- Quand vous modifiez la valeur de la variable, cela modifiera cette valeur partout oÃ¹ la variable a Ã©tÃ© utilisÃ©e.
- Les variables peuvent stocker tous les types de donnÃ©es de Sass : couleur, taille et listes de valeurs.

_Les variables nous permettent de stocker des valeurs que lâ€™on peut rÃ©utiliser dans notre codebase, mais serait-il possible dâ€™y
stocker un ensemble de rÃ¨gles ? La rÃ©ponse est non. Mais il existe bien quelque chose pour nous sauver de ce pÃ©trin : les mixins.
Et on en parle justement dans le prochain chapitre ğŸ˜‰._

-----

## Utilisez les mixins Sass avec des arguments

[Utilisez les mixins Sass avec des arguments - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6598201-utilisez-les-mixins-sass-avec-des-arguments)

<Vimeo vimeoId="534390635" />

<br />

Allons encore plus loin pour structurer notre code avec les mixins.

### DÃ©couvrez les mixins avec Sass

:::note ?
Attends attends deux secondes, on dit _un_ ou _une_ mixin ?
:::

En programmation objet, on dit **un ensemble de rÃ¨gles**, donc un mixin ; mais une rÃ¨gle, câ€™est une mixin. Ici on parlera de la
mixin en tant que rÃ¨gle (entre nous, en anglais on ne donne pas de genre, donc bon, on va pas chipoter ğŸ˜‰).

Dans notre CSS, nous utilisons beaucoup de **texte ombrÃ©**. Et avec tous les diffÃ©rents arguments auxquels on doit lâ€™appliquer,
on obtient un bon paquet deÂ  rÃ©pÃ©titions : alerte aux rÃ©pÃ©titioooooons ! ğŸš¨

```scss
.heading__header {
    text-shadow: 0.55rem 0.55rem #fff;
}
.form__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
.about__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
.project__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
```

ğŸ‘†Vous voyez que text-shadow est dupliquÃ© dans tous les sÃ©lecteurs oÃ¹ on en a besoin.

Rappelez vous : ce que lâ€™on veut, câ€™est du code plus simple et mieux organisÃ©Â !

```scss
.heading__header {
    text-shadow: 0.55rem 0.55rem #fff;
}
.form__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
.about__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
.project__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
```

Si on reprend notre code : alerte aux rÃ©pÃ©titions ! ğŸš¨ La solution la plus simple serait de tout caser dans une variable, non ?

```scss
$heading-shadow: text-shadow: 0.55rem 0.55rem #15DEA5;
```

Malheureusement non, les variables ne peuvent stocker que des valeurs. ğŸ˜“ Mais pas dâ€™inquiÃ©tude ! Sass a donnÃ© aux variables une
grande sÅ“ur, et elle est parfaitement adaptÃ©e Ã  la situation : la **@mixin** Sass !

### GÃ©rez les paramÃ¨tres du mixin

PlutÃ´t que dâ€™Ãªtre limitÃ©s Ã  des valeurs, **les mixins stockent des blocs entiers de code**. ğŸ¤˜ Vous pouvez les utiliser pour
stocker des ensembles de rÃ¨gles CSS que vous utilisez frÃ©quemment, comme avec une variable :

```scss
@mixin mixin-name {
    css-property: value;
}
```

Ã‡a ressemble beaucoup au fait d'Ã©crire un bloc CSS standard, non ? Sauf peut-Ãªtre pour le **nom**. LÃ  encore, il vaut mieux Ã©viter
dâ€™Ãªtre trop spÃ©cifique quand on donne un nom Ã  une mixin, faites plutÃ´t rÃ©fÃ©rence Ã  **son rÃ´le**. Puisque tous les Ã©lÃ©ments sur
lesquels on met une ombre sont des headers, nommez-le _heading-shadow_ (ombre du heading).

```scss
@mixin heading-shadow
```

Ã€ partir de lÃ , câ€™est la mÃªme chose que dâ€™Ã©crire un bloc CSS normal. Utilisez des **accolades** pour entourer ce que vous voulez
mettre dans votre ensemble de rÃ¨gles. Dans le cas de la mixin heading-shadow, il sâ€™agit de la propriÃ©tÃ© text-shadows et de ses
paramÃ¨tres :

```scss
@mixin heading-shadow {
    text-shadow: .55rem .55rem #15DEA5;
}
```

Et voilÃ  votre premiÃ¨re mixin Sass ! ğŸ‘ Cependant, comme pour les variables, votre heading-shadow ne fera pas grand-chose tant que
vous ne lâ€™aurez pas **inclus** dans le bloc CSS oÃ¹ vous voulez quâ€™il y ait une ombre.

Dans le cas prÃ©sent, nous voulons ajouter une ombre dans notre sÃ©lecteur `.form__heading`, ce que nous faisons en tapant
**@include** suivi dâ€™un espace et du nom de notre mixin :

```scss
.form {
    &__heading {
        @include heading-shadow;
    }
}
```

Et lorsque Sass compile cela en CSS, il place lâ€™ensemble de rÃ¨gles issues de la mixin directement dans le bloc dans lequel nous
lâ€™avons inclus :

```scss
.form__heading {
    text-shadow: .55rem .55rem #15DEA5;
}
```

Tant quâ€™on y est, remplaÃ§ons Ã  prÃ©sent les autres instances dâ€™ombres :

```scss
.heading {
    &__header {
        text-shadow: 0.55rem 0.55rem #fff;
    }
}
.form {
    &__heading {
        @include heading-shadow;
    }
}
.about{
    &__heading {
        @include heading-shadow;
    }
}
.project{
    &__heading{
        @include heading-shadow;
    }
}
```

Et voilÃ , des ombres en veux-tu en voilÃ  :

```scss
.heading__header {
    text-shadow: 0.55rem 0.55rem #fff;
}
.form__heading {
    text-shadow: .55rem .55rem #15DEA5;
}
    .about__heading {
    text-shadow: .55rem .55rem #15DEA5;
}
.project__heading {
    text-shadow: .55rem .55rem #15DEA5;
}
```

### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, pratiquez et crÃ©ez une mixin qui contiendra les rÃ¨gles des bordures.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/E7F7DF29B8FFC65D2E83CF928CF979B0" width="100%" height="500" frameborder="0"></iframe>

:::info
Retrouvez ici [la correction de l'exercice](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-2/exercice-1) !
:::

### Customisez la valeur par dÃ©faut de la mixin

VoilÃ , vous avez remplacÃ© tous les textes ombrÃ©s grÃ¢ce Ã  votre mixin. Enfin, pas tout Ã  fait. Il reste un texte ombrÃ© : lâ€™en-tÃªte
dans votre header qui utilise aussi un **text-shadow**, mais la couleur nâ€™est pas la mÃªme que dans votre mixin heading-shadow ;
vous ne pouvez donc pas lâ€™utiliser.

```scss
.heading__header {
    text-shadow: 0.55rem 0.55rem #fff;
}
```

Enfin, pas encoreâ€¦

![Lâ€™en-tÃªte dans votre header doit avoir un texte ombrÃ© blanc et non vert](https://user.oc-static.com/upload/2019/10/09/15706295321934_image6.png)

Lâ€™en-tÃªte dans votre header doit avoir un texte ombrÃ© blanc et non vert

```scss
.heading {
    &__header {
    // This shadow has a white colour, not mint!
    text-shadow: 0.55rem 0.55rem #fff;
    }
}
```

Ã‡a ne vaut pas le coup de crÃ©er une mixin juste pour une seule instance. Rappelez-vous : travaillez mieux, pas plus. Au lieu de
Ã§a, vous pouvez **modifier**Â votre mixin pour quâ€™il se comporte diffÃ©remment selon ses **inputs**.

:::note ?
Vous avez dit _inputs_ ? ğŸ¤”
:::

Absolument ! Si vous placez des **parenthÃ¨ses** aprÃ¨s le nom de votre mixin mais avant les accolades, et quâ€™entre ces parenthÃ¨ses
vous mettez un **argument** (ou plusieurs), votre mixin devient **customisable** ğŸ¤© :

```scss
@mixin heading-shadow($colour) {
    text-shadow: .55rem .55rem #15DEA5;
}
```

$colour ressemble fort Ã  une variable, non ? Câ€™est lâ€™**argument**. Voyez les arguments comme des variables vides qui ne vivent
que dans la mixin. Vous fixez leur valeur Ã  chaque fois que vous placez la mixin dans votre code, et cette valeur est utilisÃ©e
dans le bloc du mixin quand il est compilÃ© en CSS :

```scss
@mixin heading-shadow($colour) {
    text-shadow: .55rem .55rem $colour;
}
```

Sass remplacera la variable $colour au sein de la mixin avec la valeur de couleur que vous indiquez, crÃ©ant ainsi une ombre de la
couleur voulue pour le header de lâ€™en-tÃªte.

```scss
.heading {
    &__header {
        @include heading-shadow(#fff);
    }
}
```

Et quand vous regardez le code CSS compilÃ©, le header de lâ€™en-tÃªte a bien une ombre blanche !

```scss
.heading__header {
    text-shadow: 0.55rem 0.55rem #fff;
}
```

#### DÃ©finissez une valeur

DÃ©sormais, vous pouvez utiliser text-shadows avec la couleur que vous voulez et ce, en customisant la couleur une seule fois.

Pour toutes les autres instances, le $colour-primaryÂ originel aurait trÃ¨s bien fait lâ€™affaire.

PlutÃ´t que de renseigner une valeur de couleur chaque fois que vous utilisez votre **mixin heading-shadow**, vous pouvez rÃ©gler
la **valeur par dÃ©faut** de lâ€™argument. Si vous dÃ©cidez de ne pas customiser la couleur de lâ€™ombre, câ€™est la couleur par dÃ©faut
qui sera utilisÃ©e. Vous pouvez le faire en dÃ©finissant sa valeur de la mÃªme maniÃ¨re que pour une variable dÃ©clarÃ©e normalement :

```scss
@mixin heading-shadow($colour: $colour-primary) {
    text-shadow: .55rem .55rem $colour;
}
```

Du coup, si vous oubliez dâ€™ajouter lâ€™argument ou dâ€™assigner une couleur Ã  la variable quand vous lâ€™incluez, Sass en dÃ©duira que
vous voulez que lâ€™ombre soit celle de la **couleur par dÃ©faut**, dans notre cas $colour-primary.

Dans le cas oÃ¹ vous nâ€™auriez pas dÃ©fini de valeur par dÃ©faut pour $colour, vous auriez dÃ» aller ajouter dans les arguments toutes
les autres inclusions de heading-shadow. Mais plus besoin de vous inquiÃ©ter, grÃ¢ce Ã  la couleur par dÃ©faut, vous pouvez les
laisser tels quels :

```scss
.heading {
    &__header {
        @include heading-shadow($colour-white);
    }
}
.form {
    &__heading {
        @include heading-shadow;
    }
}
.about {
    &__heading {
        @include heading-shadow;
    }
}
.project{
    &__heading {
        @include heading-shadow;
    }
}
```

Ce qui donne une fois compilÃ© :


```scss
.heading__header {
    text-shadow: 0.55rem 0.55rem #fff;
}
.form__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
.about__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
.project__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
```

Parfait ! Vous avez transformÃ© votre mixin heading-shadow en un bloc de code qui sâ€™adapte aux besoins de votre codebase. ğŸ™Œ

### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Ã€ prÃ©sent, nous allons reprendre notre mixin du dernier exercice tout en lâ€™amÃ©liorant pour quâ€™elle puisse Ãªtre utilisÃ©e, peu
importe la couleur de la bordure que lâ€™on souhaite appliquer.

Console de code

<iframe title="codevolve" id="codevolveIframe2" src="https://www.codevolve.com/api/v1/access_token/A88AFB0F6A4922BFC85431937BFD6B65" width="100%" height="500" frameborder="0"></iframe>

:::info
Vous avez terminÃ© ? VÃ©rifiez votre travail avec [la correction de l'exercice](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-2/exercice-2).
:::

### Allez plus loin en sophistiquant vos mixins

Votre mixin a une bonne tÃªte. Vous pouvez customiser la couleur au grÃ© de vos besoins ou la laisser telle quelle pour que ce soit
la valeur par dÃ©faut qui soit utilisÃ©e. Mais il y a encore quelques petites choses que vous pouvez faire pour amÃ©liorer tout Ã§a.
IdÃ©alement, les valeurs de couleur et de taille doivent Ãªtre contenues dans des variables, pour quâ€™elles soient faciles Ã  trouver
et Ã  modifier si nÃ©cessaire. Mais la mixin utilise des **valeurs fixes** pour la taille de lâ€™ombre sur le texte. RemÃ©dions Ã  cela
en dÃ©clarant une variable $heading-shadow-size :

```scss
$heading-shadow-size: 0.55rem;
```

Mais plutÃ´t que de simplement remplacer les tailles dâ€™ombres dans la mixin, mettons en application un argument $shadow-size et
dÃ©finissons $heading-shadow-size en tant que rÃ©glage par dÃ©faut :

```scss
$heading-shadow-size: 0.55rem;
@mixin heading-shadow($colour: $colour-primary, $shadow-size: $heading-shadow-size) {
    text-shadow: $shadow-size $shadow-size $colour;
}
```

Ã€ prÃ©sent, votre mixin est aussi solide quâ€™un roc. Elle est **maintenable** grÃ¢ce Ã  ses variables et a un effet prÃ©visible mais
customisable, grÃ¢ce Ã  lâ€™implÃ©mentation dâ€™arguments et de valeurs par dÃ©faut.

### En rÃ©sumÃ©

- Les mixins sont trÃ¨s similaires aux variables, mais au lieu de ne stocker que des valeurs, ils stockent des blocs de code
entiers.
- On utilise le mot clÃ© `@mixin`Â pour dÃ©clarer une mixin.
- On utilise le mot clÃ© `@include`Â pour placer une instance du mixin dans son code.
- Lorsque Sass compile les instances dâ€™une mixin, il remplace le mixin par les rÃ¨gles quâ€™il contient.
- Pour rendre les mixins plus adaptables et rÃ©utilisables, vous pouvez inclure des arguments lorsque vous les dÃ©clarez.
- Les arguments peuvent changer lâ€™effet du code compilÃ©, par exemple dÃ©finir des couleurs ou tailles customisÃ©es.

_Dans le chapitre suivant, nous allons voir un autre ensemble dâ€™outils Sass servant Ã  gÃ©rer les modules de code qui se rÃ©pÃ¨tent :
les extensions._

-----

## Ã‰crivez du code plus propre grÃ¢ce aux extensions Sass

[Ã‰crivez du code plus propre grÃ¢ce aux extensions Sass - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6598331-ecrivez-du-code-plus-propre-grace-aux-extensions-sass)

<Vimeo vimeoId="534402807" />

<br />

### ApprÃ©hendez les points faibles des mixins pour mieux les contourner.

Les mixins sont utiles, certes, mais elles ont aussi quelques inconvÃ©nients. En effet, chaque mixin crÃ©e une **duplication de
lâ€™ensemble de rÃ¨gles** dans notre CSS compilÃ© :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
.form {
    &__heading {
        @include heading-shadow;
    }
}
.about {
    &__heading {
        @include heading-shadow;
    }
}
.project {
    &__heading {
        @include heading-shadow;
    }
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.form__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
.about__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}
.project__heading {
    text-shadow: 0.55rem 0.55rem #15DEA5;
}






```

</div>
</div>

<br />

Alerte aux rÃ©pÃ©titions ! ğŸš¨Et la mixin heading-shadow contient le strict minimum : une **propriÃ©tÃ©**. Mais ce nâ€™est pas toujours
le cas. Par exemple, si on crÃ©e une mixin pour un ensemble de rÃ¨gles, on en obtient beaucoup plus :

```scss
@mixin .typography {
    color: $colour-primary;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
```

Et il pourrait y en avoir encore plus : `font-kerning`,Â `line-height`, `text-transfor`, etc., etc. Maintenant, supposons quâ€™on
inclue plusieurs fois cette **mixin typography**. Quand on regarde notre Sass, il paraÃ®t plutÃ´t correct :

```scss
@mixin .typography {
    color: $colour-primary;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
h1 {
    @include .typography;
}
textarea {
    @include .typography;
}
button {
    @include .typography;
}
input {
    @include .typography;
}
```

Mais quand on jette un Å“il au CSS compilÃ©, on voit quâ€™il contient beaucoup de **code rÃ©pÃ©titif** (alerte, alerte ! ğŸš¨) :

```scss
h1 {
    color: #15dea5;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
textarea {
    color: #15dea5;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
button {
    color: #15dea5;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
input {
    color: #15dea5;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
```

Trouver un bout de code prÃ©cis devient un enfer au vu des multiples **rÃ©pÃ©titions**.Â Il sera dâ€™autant plus difficile de le
trouver au milieu de tous les blocs qui se ressemblent. Et le doigt qui vous sert Ã  scroller aimerait autant ne pas Ãªtre trop
surexploitÃ©.*

:::caution !
*Ceci est un message de la FÃ©dÃ©ration Unitaire des Doigts Scrolleurs.ğŸ–
:::

Je vous entends venir, vous pourriez transformer votre mixin de changement typographique en un sÃ©lecteurÂ `.typography`Â et
lâ€™assigner aux Ã©lÃ©ments qui en ont besoin dans le HTML :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
.typography {
    color: $colour-primary;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
```
</div>
<div style={{width:'49%'}}>

```css title="css"
<h1 class="heading__header typography">
    Heading Goes Here
</h1>
...
<button class="btn typography">Click Me!</button>
...
```

</div>
</div>

<br />

Mais cela met complÃ¨tement en lâ€™air les **conventions de nomenclature BEM**. Reprenons, une mixin produit de grandes quantitÃ©s
de codes rÃ©pÃ©titifs, et un sÃ©lecteur normal ne sera pas compatible avec BEM. Un sacrÃ© dilemmeâ€¦ Eh bien, pas forcÃ©ment : on peut
trouver un juste milieu grÃ¢ce *roulements de tambours* aux **extensions Sass**.

### Utilisez les extensions Sass

Les **extensions** sont trÃ¨s similaires aux mixins. Vous Ã©crivez un bloc de code et vous comptez sur Sass pour le rÃ©utiliser, ce
qui nous Ã©pargne la tÃ¢che de devoir le retaper indÃ©finiment. Mais contrairement aux mixins, pas besoin de les **dÃ©clarer** avec
un **identifiant** **spÃ©cifique** â€“ il suffit de les Ã©crire comme un simple sÃ©lecteur :

```scss
.typography {
    color: #15dea5;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
```

Ensuite, pour Ã©tendre un sÃ©lecteur Ã  `.typography`, tapez @extend suivi du nom du sÃ©lecteur, `.typography`Â :

```scss
.typography {
    color: $colour-primary;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
h1 {
    @extend .typography;
}
```

### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, reprenez ce que vous avez vu dans ce chapitre en unifiant la typographie de deux blocs grÃ¢ce aux extensions.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/A85E701C4EA94CFBFD1F302F02509F4B" width="100%" height="500" frameborder="0"></iframe>


:::info
Retrouvez la [correction de l'exercice ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-3/exercice-1).
:::

### Utilisez les placeholders

Vous avez remarquÃ© que jâ€™ai dit â€œÃ©tendre Ã â€ et pas juste â€œÃ©tendreâ€ dans le paragraphe ci-dessus ? Câ€™est parce que vous nâ€™Ãªtes
pas en train dâ€™Ã©tendre le sÃ©lecteur `.typography-content`Â ! Vous Ãªtes en train dâ€™Ã©tendre le sÃ©lecteur h1 au sÃ©lecteur
`.typography`.

:::note ?
Ok, mais Ã§a veut dire quoi, au juste ? ğŸ˜§
:::

Regardons le CSS compilÃ© pour y voir un peu plus clair :

```scss
.typography, h1 {
    color: #15dea5;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
```

Notez que vous ne voyez pas de code issu de lâ€™extension au sein du sÃ©lecteur h1, mais que Sass a ajoutÃ© h1 Ã  la liste des
sÃ©lecteurs pour lâ€™ensemble de rÃ¨gles.

Avec les mixins, Sass inclut le contenu du mixin partout oÃ¹ il est appelÃ©, ce qui a pour consÃ©quence un tas de rÃ©pÃ©titions. Mais
si vous utilisez **@extend** sur h1, vous dites Ã  Sass que plutÃ´t que de dupliquer les propriÃ©tÃ©s au sein de h1, vous voulez que
h1 utilise lâ€™ensemble de rÃ¨gles issu dâ€™un autre sÃ©lecteur â€“ dans le cas prÃ©sent, `.typography`. Du coup, Sass â€œÃ©tendâ€ h1 aux
rÃ¨gles deÂ .typography dans toute la feuille de style et lâ€™ajoute Ã  la liste.

:::info
Mixin duplique un ensemble de rÃ¨gles alors que **@extend duplique le sÃ©lecteur**.
:::

Si vous dÃ©ployez @extendÂ `.typography`Â dans plein dâ€™autres sÃ©lecteurs, vous ne vous retrouverez pas avec des tas de **rÃ¨gles
dupliquÃ©es**. Ã€ la place, tous les sÃ©lecteurs concernÃ©s seront ajoutÃ©s Ã  la liste aux cÃ´tÃ©s de `.typography`Â :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
.typography {
    color: $colour-primary;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
h1 {
    @extend .typography;
}
textarea {
    @extend .typography;
}
button {
    @extend .typography;
}
input {
    @extend .typography;
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.typography, h1, textarea, button, input {
    color: #15dea5;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}












```

</div>
</div>

<br />

Quand vous regardez la **liste des sÃ©lecteurs** qui suiventÂ `.typography`, vous voyez beaucoup dâ€™Ã©lÃ©ments que nous utilisons
dÃ©jÃ  un peu partout dans notre code mais pas `.typography`. Câ€™est parce que son but nâ€™est pas de **modifier** un Ã©lÃ©ment, mais
plutÃ´t de **servir de placeholder** (ou de terrain de base, si on veut) pour dâ€™autres sÃ©lecteurs auxquels il doit Ãªtre Ã©tendu.

Okay ; donc, en suivant cette logique on pourrait dÃ©cider de renommerÂ `.typography`Â parÂ `.placeholder-typography`,Â **mais avoir
dans son CSS des sÃ©lecteurs qui ne sont utilisÃ©s nulle part est une mauvaise idÃ©e ğŸ”¥**. Les sÃ©lecteurs inutilisÃ©s augmentent la
taille de votre fichier et ajoutent de la **confusion** inutilement. Ce nâ€™est pas notre but. En plus, ils pourraient sÃ©rieusement
vous compliquer la tÃ¢che le jour oÃ¹ vous aurez besoin de dÃ©chiffrer ce qui se passe.

Nâ€™oublions pas que nous essayons de faire en sorte que votre futur vous soit content, ne serait-ce que pour lui Ã©viter de
construire une machine Ã  voyager dans le temps pour revenir se venger, et ce au risque de crÃ©er une faille spatio-temporelle qui
aurait pour inÃ©vitable consÃ©quence dâ€™annihiler le reste de lâ€™humanitÃ©.

Lâ€™humanitÃ© vous remercie donc pour vos efforts.

Comment faire pour utiliser `.typography`Â et pour lâ€™Ã©tendre aux autres classes sans le dÃ©clarer comme un sÃ©lecteur ? Sass Ã  la
rescousse ! ğŸ‹ï¸â€â™€ï¸ Sass a un placeholder intÃ©grÃ© prÃªt Ã  lâ€™emploi, que vous pouvez utiliser pour contenir votre ensemble de rÃ¨gles et
garder un code propre et ordonnÃ© plutÃ´t que dâ€™utiliser un sÃ©lecteur standard ; il se matÃ©rialise avec le prÃ©fixeÂ %Â :

```scss
%typography {
    color: $colour-primary;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
```

Lorsque vous utilisez le **prÃ©fixe pourcentage (%)** devant votre sÃ©lecteur plutÃ´t que le point quâ€™on utilise dâ€™habitude pour
les classes, Sass crÃ©e un **placeholder**.

On peut crÃ©er des **extensions** aux placeholders Sass, aussi appelÃ©s â€œclasses silencieusesâ€, de la mÃªme faÃ§on quâ€™on le fait avec
les sÃ©lecteurs. On peut rÃ©utiliser nos placeholders partout dans le code, comme on le ferait avec des sÃ©lecteurs.

```scss
%typography {
    color: $colour-primary;
    font-size: 2rem;
    font-weight: 100;
    line-height: 1.7;
}
h1 {
    @extend %typography;
}
textarea {
    @extend %typography;
}
button {
    @extend %typography;
}
input {
    @extend %typography;
}
```

En nâ€™appliquant que les sÃ©lecteurs qui sâ€™Ã©tendent au **placeholder**, votre CSS devient plus propre et plus explicite. Aucune
confusion et pas de code dupliquÃ© : jackpot ! ğŸ™Œ

### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, crÃ©ez et utilisez les placeholders.

Console de code

<iframe title="codevolve" id="codevolveIframe2" src="https://www.codevolve.com/api/v1/access_token/116E8D3CD84F4537FC536B88EF7B9C43" width="100%" height="500" frameborder="0"></iframe>

:::info
Avez-vous rÃ©alisÃ© l'exercice ? [Retrouvez la correction ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-3/exercice-2).
:::

### En rÃ©sumÃ©

- Les extensions ont une fonction similaire aux mixins : tous deux vous Ã©pargnent dâ€™Ã©crire de nombreuses lignes de code
rÃ©pÃ©titives.
- Alors que les mixins se compilent en ensembles de rÃ¨gles dupliquÃ©s, les extensions se compilent en sÃ©lecteurs dupliquÃ©s.
- Pour Ã©viter la prÃ©sence de sÃ©lecteurs inutilisÃ©s dans votre codebase, vous pouvez utiliser des placeholders dâ€™ensembles de
rÃ¨gles en prÃ©fixant leur nom dâ€™un symbole pourcent (%) : `%extend-placeholder`.

_Pas mal, non ? Mais quand faut-il utiliser des mixins plutÃ´t que des extensions et vice versa ? Dans le chapitre suivant, nous
allons voir et essayer de comprendre ensemble les similitudes et les diffÃ©rences entre les deux._

-----

## Choisissez quand utiliser des mixins ou des extensions

[Choisissez quand utiliser des mixins ou des extensions - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6598436-choisissez-quand-utiliser-des-mixins-ou-des-extensions)

<Vimeo vimeoId="534427374" />

<br />

Allons plus loin dans notre analyse des mixins et des extensions.

### MixinsÂ vs extensions

Sur le principe, les mixins et les extensions sont trÃ¨s **semblables**. Pour discerner leurs diffÃ©rentes fonctions, il faut
prÃªter attention au **code compilÃ©**, ce qui complique la tÃ¢che pour dÃ©terminer la situation dans laquelle utiliser lâ€™un ou
lâ€™autre.

Il nâ€™y aura aucun doute possible pour un cas prÃ©cis : si vous voulez que votre bloc de code utilise ou non **des arguments**. Si
vous avez besoin dâ€™avoir recours Ã  un argument, utilisez des mixins â€“ vous nâ€™avez pas dâ€™autre choix.

Les extensions ne tolÃ¨rent pas les arguments : puisquâ€™il nâ€™y a quâ€™un ensemble de rÃ¨gles compilÃ©, utiliser des arguments pour
modifier ses rÃ©sultats pour un sÃ©lecteur les modifierait pour tous les sÃ©lecteurs.

Mis Ã  part les arguments, la diffÃ©rence principale entre les mixins et les extensions est quâ€™avec les mixins vous obtenez des
**rÃ¨gles dupliquÃ©es**, alors quâ€™avec les extensions, vous obtenez des **sÃ©lecteurs dupliquÃ©s**.

:::note ?
Du coup, lequel faut-il utiliser ? ğŸ˜§
:::

Pour avoir une rÃ©ponse, regardons les sÃ©lecteurs dupliquÃ©s de l'**extend**. Si vous scrollez dans votre CSS compilÃ© jusquâ€™au
bloc h1 dans le CSS compilÃ©, tout ce quâ€™il y a Ã  savoir sur votre bloc h1 sâ€™y trouve. Tout ? Pas vraiment. Vous ne verrez pas
ses propriÃ©tÃ©s **typographiques** (les fonts, la taille de texte, etc.). Pour connaÃ®tre ses propriÃ©tÃ©s typographiques, cherchez
au hasard jusquâ€™Ã  ce que vous les trouviez dans une liste aux cÃ´tÃ©s dâ€™autres sÃ©lecteurs. Le souci, câ€™est qu'en les trouvant au
hasard, vous risquez dâ€™avoir oubliÃ© que vous lâ€™aviez Ã©tendu avant. Et puisque rien nâ€™indique que vous aviez dÃ©fini des propriÃ©tÃ©s
typographiques pour h1, que ce soit dans les extensions ou nâ€™importe oÃ¹ ailleurs, vous risquez de vous retrouver perdu et frustrÃ©.

### Verdict : mixins ou extensions ?

Eh bien en fait, posÃ© comme Ã§a, la rÃ©ponse est plutÃ´t simple : **nâ€™utilisez pas dâ€™extensions**.

Je sais, je sais. Les mixins gÃ©nÃ¨rent des tas de code qui se rÃ©pÃ¨tent ! Oui, câ€™est vrai. Mais ils nâ€™affectent pas lâ€™organisation
de votre CSS. Les extensions dÃ©molissent lâ€™ordre et la prÃ©dictibilitÃ© de votre codebase et ce, juste pour vous Ã©pargner du code
rÃ©pÃ©titif. Le jeu nâ€™en vaut pas la chandelle.

Tenez-vous-en donc aux mixins. Le code que vous obtiendrez sera plus propre et plus simple Ã  maintenir, mÃªme sâ€™il est un peu plus
volumineux.

Mais, maisâ€¦ pourquoi ? Pourquoi est-ce quâ€™on vient de passer tout ce temps sur les extensions ? ğŸ˜«

Souvenez-vous, tout au dÃ©but de ce cours, jâ€™ai dit que le CSS Ã©tait dÃ©licat car il nâ€™y a **pas de rÃ¨gles concrÃ¨tes pour son
architecture**. Ce qui veut dire que dâ€™autres gens auront construit leur Ã©cosystÃ¨me CSS diffÃ©remment du vÃ´tre, et cela inclut
lâ€™utilisation dâ€™extensions.

ÃŠtre dÃ©veloppeur, ce nâ€™est pas seulement Ã©crire son propre code, câ€™est aussi Ãªtre capable de lire le code des autres et
travailler avec.

Vous tomberez **forcÃ©ment** sur des extensions Sass un jour ou lâ€™autre. MÃªme si vous nâ€™en Ã©crivez pas vous-mÃªme, les connaÃ®tre
et savoir comment elles fonctionnent est vital pour un dÃ©veloppeur Sass. Donc par pitiÃ©, ne construisez pas une machine Ã  remonter
le temps pour venir vous dÃ©fouler sur moi au moment oÃ¹ jâ€™Ã©cris ce cours ; lâ€™annihilation de lâ€™humanitÃ©, tout Ã§a, vous vous
rappelez ? Ce ne vaut pas le coup, merci. ğŸ™ğŸ¼

### En rÃ©sumÃ©

- Les mixins tolÃ¨rent les arguments mais gÃ©nÃ¨rent du code rÃ©pÃ©titif.
- Les extensions ne tolÃ¨rent pas les arguments et gÃ©nÃ¨rent des sÃ©lecteurs dupliquÃ©s.Â 
- Vous tomberez sur des extensions dans du code Ã©crit par dâ€™autres, mais pour que le vÃ´tre reste propre, tenez-vous-en aux mixins.

_Maintenant que nous avons tirÃ© tout Ã§a au clair, et puisquâ€™on a dÃ©cidÃ© de sâ€™en tenir aux mixins, passons Ã  la vitesse supÃ©rieure.
Dans le chapitre suivant, nous allons utiliser des fonctionnalitÃ©s propres Ã  Sass pour passer notre code Ã  un tout autre niveau._

-----

## AmÃ©liorez les mixins avec les fonctions Sass

[AmÃ©liorez les mixins avec les fonctions Sass - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6598491-ameliorez-les-mixins-avec-les-fonctions-sass)

<Vimeo vimeoId="534427460" />

<br />

Passons Ã  la vitesse supÃ©rieure avec nos mixins grÃ¢ce aux fonctions Sass

### Utilisez la bonne fonction

Si vous regardez plus attentivement la maquette de la page de contact, vous verrez que la couleur de lâ€™ombre du texte nâ€™est pas
du mÃªme vert menthe queÂ $colour-primary. Elle est mÃªme un peu plus foncÃ©e :

![Image montrant que l'ombre de contactez-moi est un vert plus foncÃ©e que $colour-primary](https://user.oc-static.com/upload/2019/10/09/15706305647486_image4.png)

Lâ€™ombre de contactez-moi est d'un vert plus foncÃ© que $colour-primary

Cela signifie que le mixin heading-shadow doit utiliser **une valeur de couleur plus foncÃ©e**. OK, remontons donc en haut du
document pour crÃ©er une nouvelle variable pour la coulâ€¦ stooooooop. Il doit y avoir un moyen plus simple, non ? Au final, câ€™est
presque la mÃªme couleur, juste un poil plus foncÃ©e.

CrÃ©er une toute nouvelle variable pour lâ€™ombre voudrait dire quâ€™on aurait une couleur de plus Ã  garder en tÃªte. Et si
$colour-primary Ã©tait changÃ©e Ã  lâ€™avenir, il ne faudrait pas oublier de modifier la couleur de lâ€™ombre en fonction. Bref, encore
du travail supplÃ©mentaire et du code encombrant, aucun intÃ©rÃªt. On va trouver une autre solution. ğŸ’ª

Rappelez-vous : mieux travailler, pas plusâ€¦

Il se trouve que Sass a une boÃ®te Ã  outils consÃ©quente, pleine dâ€™outils qui peuvent vous aider Ã  faire ce genre de choses. Pas
seulement une petite caisse Ã  outils mais une grande, genre dernier cri, pleine de compartiments et de tiroirs avec tout ce
quâ€™il faut dedans. ğŸ› ğŸ”©âš™ï¸â› Si vous y jetez un Å“il, vous dÃ©couvrirez quâ€™il y a un tiroir entier dâ€™outils uniquement dÃ©diÃ©s aux
couleursÂ ! ğŸ‰

On appelle ces outils des **_fonctions_**. Les fonctions sont des **bouts de code prÃ©fabriquÃ©s** qui effectuent des tÃ¢ches,
comme par exemple prendre un argument, le modifier et renvoyer la nouvelle valeur sans que vous nâ€™ayez Ã  le faire vous-mÃªme.
Sass a des fonctions pour dÃ©saturer, inverser et mÃªme foncer les couleurs (et bien dâ€™autres encore, la liste est longue).

La fonction nommÃ©e judicieusement **â€œdarkenâ€** (_assombrir_, en anglais) prend deux arguments : une **valeur de couleur**, et
une valeur qui indique Ã  quel point vous voulez assombrir votre valeur. Pour assombrir $colour-primary pour notre ombre de texte,
utilisez la fonction Ã  lâ€™endroit oÃ¹ vous auriez placÃ© une valeur de couleur en temps normal :

```scss
@mixin heading-shadow($colour:$colour-primary, $size: $heading-shadow-size) {
    text-shadow: $size $size darken($colour, 10%);
}
```

Nous avons remplacÃ© $colour dans les **arguments** de text-shadow par la fonction `darken()`Â et avons passÃ© $colour en premier
argument, et la proportion dans laquelle nous voulons la rendre plus foncÃ©e en deuxiÃ¨me argument : ici 10 %.

Quand vous regardez le CSS compilÃ©, vous voyez que le mixin heading-shadow produit une ombre ayant la valeur hexÂ #11af82, soit
une version 10 % plus foncÃ©e que $colour-primary (#15dea5) :

```scss
.form__heading {
    text-shadow: 0.55rem 0.55rem #11af82;
}
```

Maintenant, plus besoin de vous souvenir de mettre Ã  jour la couleur plus foncÃ©e pour le mixin heading-shadow. DÃ¨s que vous
modifiez votre $colour-primary, votre mixin gÃ©nÃ©rera automatiquement lâ€™ombre correspondante.

:::info
Pour rafraÃ®chir votre mÃ©moire sur les couleurs en CSS, vous pouvez revoir le chapitre "[Ajoutez de la couleur et un fond](https://openclassrooms.com/fr/courses/1603881-apprenez-a-creer-votre-site-web-avec-html5-et-css3/1605551-ajoutez-de-la-couleur-et-un-fond)"
du cours "[Apprenez Ã  crÃ©er votre site web avec HTML5 et CSS3](https://openclassrooms.com/fr/courses/1603881-apprenez-a-creer-votre-site-web-avec-html5-et-css3)".
:::

PlutÃ´t stylÃ©, non ?

:::note ?
Mais pourquoi seulement 10 % ? Et comment je sais quâ€™il faut une couleur 10 % plus foncÃ©e ? Quâ€™est-ce que Ã§a signifie ? ğŸ˜¶
:::

Câ€™est prÃ©cisÃ©ment le sujet de notre prochain point !

### DÃ©couvrez dâ€™autres mÃ©thodes pour manipuler les couleurs

La valeur de $colour-primary est #15dea5, qui est lâ€™Ã©quivalent de vert menthe en hexadÃ©cimal, mais qui peut aussi sâ€™Ã©crire
(21,222,165) en RGB. Les valeurs hexadÃ©cimales (ou hex) sont en rÃ©alitÃ© composÃ©es de trois paires de valeurs qui se traduisent
en canaux rouge, vert et bleu dans les couleurs **RBG**Â ; en dâ€™autres termes, câ€™est juste une faÃ§on plus brÃ¨ve dâ€™Ã©crire les
valeurs `rgb()`.

![Image montrant une couleur exprimÃ©e de deux faÃ§on diffÃ©rentes](https://user.oc-static.com/upload/2019/10/09/15706310032811_image3.jpg)

Des valeurs de couleurs exprimÃ©es de deux faÃ§ons diffÃ©rentesÂ 

Mais il existe un autre moyen dâ€™exprimer les couleurs dans CSS et Sass : `hsl()`, Lâ€™abrÃ©viation de **_hue_**, **_saturation_**
et **_lightness_** (teinte, saturation et clartÃ©). Alors queÂ `rgb()`Â se rapporte aux proportions de rouge, vert et bleu dans une
couleur,Â `hsl()`Â mesure oÃ¹ se situe la couleur dans le nuancier et Ã  quel point elle est vive et claire :

![Image illustrant la mesure hsl](https://user.oc-static.com/upload/2019/10/09/15706311553171_image7.jpg)

La mesure hslÂ 

$colour-primary a des valeurs de **teinte**, **saturation** et **clartÃ©** de hsl(163, 83%, 48%), ce qui signifie que sa teinte
se situe Ã  163Â° dans le spectre, que sa saturation est de 83% et sa clartÃ© de 48%. Pour obtenir une couleur 10% plus foncÃ©e, il
faut **diminuer** la valeur de clartÃ© de 10%, ce qui donne une valeur de hsl(163, 83%, 38%).

Et câ€™est exactement ce que fait la fonction `darken()`Â en arriÃ¨re-plan. Elle prend une couleur et, par le biais dâ€™une magie
obscure, la convertit enÂ `hsl()`. Ensuite, elle prend la quantitÃ© de changement demandÃ© sur la clartÃ© et fait le calcul. Enfin,
elle prend la valeur `hsl()`Â obtenue et la retourne sous forme de valeur hex Ã  compiler dans le document CSS.

Quand une fonction donne une valeur, par exemple une nouvelle couleur, on dit que **la fonction retourne cette valeur**. Nous
verrons de plus prÃ¨s comment marchent les fonctions et le mot clÃ© **@return** trÃ¨s rapidement !

:::note ?
Mais attends, câ€™est suuuper compliquÃ© ! ğŸ¤¯
:::

Ici, je vous explique juste comment fonctionne la fonction darken et ce quâ€™elle fait exactement, afin que vous compreniez ce qui
se passe quand vous lâ€™utilisez, sans forcÃ©ment voir toutes les Ã©tapes. Le but des fonctions est de vous faciliter la vie et
d'Ã©crire une codebase propre et flexible. Et ceci, en crÃ©ant des valeurs de faÃ§on dynamique, ce qui vous permet de les inclure
dans des modules qui sont rÃ©utilisables partout dans votre code.

:::info
Il existe bien plus de fonctions prÃ©installÃ©es dans Sass que nous nâ€™avons guÃ¨re le temps de couvrir, mais bon nombre dâ€™entre
elles pourraient vous Ãªtre utiles pour un projet. Je vous recommande donc de lire **[la page sur les fonctions dans la documentation Sass](http://sass-lang.com/documentation/Sass/Script/Functions)**
si vous voulez en savoir plus.
:::

### **Essayez par vous-mÃªme !**

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Apprenez Ã  utiliser les fonctions avec un cas prÃ©cis : en gÃ©nÃ©rant une couleur en fonction dâ€™une autre.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/FBD7463616E3F8CFA217E3762ECC0603" width="100%" height="500" frameborder="0"></iframe>

:::info
Comparez votre travail avecÂ la [correction de l'exercice](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-5/exercice-1)Â ğŸ˜‰
:::

Notre mixin heading-shadow crÃ©e dÃ©sormais par elle-mÃªme des valeurs de couleurs plus foncÃ©es selon les paramÃ¨tres que nous avons
prÃ©cisÃ©s, diminuant notre charge de travail... Mais que se passerait-il si on remplaÃ§ait $colour-primary par quelque chose de
beaucoup plus foncÃ© ? Dans ce cas, peut-Ãªtre quâ€™on voudrait rendre la couleur de lâ€™ombre plus claire, et pas plus foncÃ©e.

### En rÃ©sumÃ©

- Les fonctions sont des bouts de code rÃ©utilisables qui effectuent des tÃ¢ches prÃ©dÃ©finies.
- Sass fournit tout un tas de fonctions prÃªtes Ã  lâ€™emploi que vous pouvez utiliser pour manipuler des valeurs et rendre votre
code mieux organisÃ© et du coup plus facile Ã  maintenir.
- Les valeurs de couleurs peuvent Ãªtre manipulÃ©es Ã  travers les couleursÂ rouge, vert et bleu, mais aussi Ã  travers les teintes,
saturations et clartÃ©s.

_Dans le chapitre suivant, nous vous apprendrons comment faire pour que votre mixin rÃ©agisse complÃ¨tement diffÃ©remment en
fonction des situations._

-----

## Optimisez les mixins grÃ¢ce aux conditions dans Sass

[Optimisez les mixins grÃ¢ce aux conditions dans Sass - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6598606-optimisez-les-mixins-grace-aux-conditions-dans-sass)

<Vimeo vimeoId="534427557" />

<br />

Notre code nâ€™est pas trÃ¨s dynamique, par lÃ  jâ€™entends quâ€™il nâ€™est pas modulable, quâ€™il ne sâ€™adapte pas en fonction des situations.
Comment faire si on veut que la couleur sâ€™adapte si lâ€™ombre est plus ou moins foncÃ©e, par exemple ? ğŸ¤”

### DÃ©couvrez les conditions

Notre mixin heading-shadow fonctionne trÃ¨s bien en lâ€™Ã©tat, sauf si bien sÃ»r on emploie une couleur trÃ¨s trÃ¨s foncÃ©e. Lâ€™Å“il
humain distingue mal les **couleurs sombres**, câ€™estÂ pour cela qu'une diffÃ©rence de luminositÃ© de 10% entre deux couleurs claires
sera beaucoup plus visible que la mÃªme diffÃ©rence entre deux couleurs sombres.

Au-delÃ  dâ€™un certain seuil, quand la couleur de lâ€™ombre est rendue plus foncÃ©e, il serait logique de la rendre plus claire Ã  la
place, ou sinon nous ne pourrions plus distinguer le texte de lâ€™ombre. Fixons ce seuil Ã  25% : toute couleur ayant une luminositÃ©
de moins de 25% sera Ã©claircie. Sinon, si elle garde un pourcentage de luminositÃ© de plus de 25%, dans ce cas elle sera foncÃ©e.

En programmation, on appelle cela une **_structure conditionnelle_**, ou plus simplement **_condition_** (â€œif/elseâ€ en anglais) :
**si** la couleur a moins de 25% de luminositÃ©, lâ€™Ã©claircir ; **sinon**, lâ€™assombrir :

![Illustration de la boucle conditionnelle](https://user.oc-static.com/upload/2019/10/23/15718150509774_image6.png)

Une boucle conditionnelle

:::note ?
OK, jusquâ€™ici câ€™est compris, mais comment faire Ã§a techniquement ? ğŸ¤”
:::

Commencez par taper **@if**... Poursuivez en mettant entre **accolades** le contenu de votre **condition** : le pourcentage de
luminositÃ© est infÃ©rieur Ã  25%. Pour obtenir la luminositÃ© de $colour, on utilise la fonctionÂ lightness() de Sass, qui retourne
la valeur de luminositÃ© dâ€™une couleur :

```scss
@if ( lightness($colour) < 25% ) {...}
```

La condition est prise en compte comme une **question vrai/faux**. Si la rÃ©ponse est vraie, faire ceci ; si elle est fausse,
faire autre chose.

RÃ©pondre Ã  la question câ€™est bien, mais il nous faut plus. Si votre condition est vraie, vous voulez que la couleur soit
**Ã©claircie**Â ; et pour spÃ©cifier cela vous devez indiquer entre les accolades ce que vous voulez quâ€™il se passe. Dans notre cas,
nous utilisons la fonction `lighten()`Â de Sass, qui Ã©claircira la couleur et modifiera donc $colour avec cette nouvelle valeur :

```scss
@if ( lightness($colour) < 25% ) {
    $colour: lighten($colour, 10%);
}
```

Si la condition est vraie, Sass lira ce quâ€™il y a entre les accolades et **exÃ©cutera** le code. Mais si la rÃ©ponse est fausse
(le pourcentage de luminositÃ© de la couleur en question est Ã©gal ou supÃ©rieur Ã  25%), Sass **ignorera** le contenu de la
premiÃ¨re paire dâ€™accolades et ira directement Ã  la prochaine portion de code, qui est celle oÃ¹ nous indiquons lâ€™instruction
â€œalorsâ€. Tapez **@else** pour la crÃ©er, suivi des accolades contenant ce quâ€™il faut faire si la rÃ©ponse est fausse :

```scss
@if ( lightness($colour) < 25% ) {
    $colour: lighten($colour, 10%);
} @else {
    $colour: darken($colour, 10%);
}
```

Du coup, si la condition est vraie et que la luminositÃ© de $colour estÂ infÃ©rieureÂ Ã  25%, on veut utiliser la fonction `lighten()`
pour lâ€™Ã©claircir de 10%. Mais si lâ€™instruction est fausse, alors on veut utiliser la fonction `darken()` pour lâ€™assombrir de 10%.

IntÃ©grons Ã  prÃ©sent notre nouvelle condition si/alors dans notre mixin heading-shadowÂ  :

```scss
@mixin heading-shadow($colour: $colour-primary, $size: $heading-shadow-size) {
    @if ( lightness($colour) < 25% ) {
        $colour: lighten($colour, 10%);
    } @else {
        $colour: darken($colour, 10%);
    }
    text-shadow: $size $size $colour;
}
```

Et maintenant, mettons $colour-secondary, dont la valeur de #001534 a une luminositÃ© de 10%. Puisque 10% est infÃ©rieur Ã  25%,
Sass devrait interprÃ©ter la condition comme Ã©tant vraie et retourner #002a67, la couleur qui est 10% plus claire :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
.form {
    &__heading {
        @include heading-shadow($colour-secondary);
    }
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.form__heading {
    text-shadow: 0.55rem 0.55rem #002a67;
}


```

</div>
</div>

<br />

Woooohooooo, victoire ! ğŸ™Œ

Testons un peu plus notre nouvelle fonction avec une couleur beaucoup plus claire pour voir ce qui se passe, prenons blanc par
exemple â€“ entre nous, difficile de faire plus clair ğŸ™„ :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
.form {
    &__heading {
        @include heading-shadow($colour-white);
    }
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.form__heading {
    text-shadow: 0.55rem 0.55rem #e6e6e6;
}


```

</div>
</div>

<br />

#E6E6E6 a une luminositÃ© de 90%, notre mixin lâ€™a donc assombrie de 10%, exactement comme nous le voulions. Parfait. ğŸ‘Œ

:::info
Un moyen rapide dâ€™afficher les valeurs hex dâ€™une couleur sous dâ€™autres formats tels que HSL est de taper les valeurs hex dans
Google et de cliquer sur le menu dÃ©roulant â€œAfficher les valeurs de couleurâ€.
:::

Les **conditions** vous aident Ã  rendre votre codebase **flexible** et **maintenable** en adaptant automatiquement les blocs de
code avec les donnÃ©es que vous avez renseignÃ©es. Flexible et maintenable : deux qualitÃ©s au poil !

### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, ajustez la couleur dâ€™un bouton en utilisant les conditions.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/BAE4D1BE44599AA5A9C0A7D01F447A19" width="100%" height="500" frameborder="0"></iframe>

:::info
Avez-vous rÃ©alisÃ© l'exercice ? VÃ©rifiez votre travail avec cette [correction de l'exercice](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-6/exercice-1).
:::

### Dans quelle condition se trouve ma conditionÂ ?

Penchons-nous dâ€™un peu plus prÃ¨s sur notre condition :

```scss
( lightness($colour) < 25% )
```

Ã€ gauche, la valeur que vous voulez comparer, en lâ€™occurrence la luminositÃ© de $colour. Ã€ droite, la valeur Ã  laquelle vous
voulez la comparer, qui est 25%. Le symbole â€œinfÃ©rieur Ã â€ ( < )au milieu est ce quâ€™on appelleÂ  un **_opÃ©rateur de comparaison_**.

Un opÃ©rateur de comparaison est la faÃ§on dont vous comparez les valeurs : est-ce que x est infÃ©rieur Ã  y ? SupÃ©rieur ? Ã‰gal ? Il
existe six opÃ©rateurs de comparaison au total :

| OpÃ©rateur | Condition | RÃ©sultat |
|-----------|-----------|----------|
| == | x==y | Vrai si x est Ã©gal Ã  y |
| != | x!=y | Vrai si x nâ€™est pas Ã©gal Ã  y |
| > | x>y | Vrai si x est supÃ©rieur Ã  y |
| < | x<y | Vrai si x est infÃ©rieur Ã  y |
| >= | x>=y | Vrai si x est supÃ©rieur ou Ã©gal Ã  y |
| <= | x<=y | Vrai si x est infÃ©rieur ou Ã©gal Ã  y |

Et vous nâ€™Ãªtes pas limitÃ© Ã  une seule condition.Â Par exemple, si vous voulez que votre condition soit vraie si $colour est
infÃ©rieure Ã  25%, mais aussi supÃ©rieure Ã  10% ?

Eh bien, câ€™est possible ! Vous pouvez enchaÃ®ner deux conditions en utilisant `and`Â pour les lier :

```scss
@if ( lightness($colour) < 25% ) and ( lightness($colour) > 10% ) {...}
```

En utilisant cet **opÃ©rateur logique** â€œetâ€, vous exigez que les deux conditions soient vraies pour que le bloc â€œsiâ€ soit exÃ©cutÃ©.

Vous pouvez aussi utiliser lâ€™opÃ©rateur logiqueÂ `or`, auquel cas le rÃ©sultat sera vrai si **nâ€™importe laquelle** des conditions
est vraie :

```scss
@if ( lightness($colour) < 25% ) or ( saturation($colour) > 10% ) {...}
```

En utilisant _or_, tout ce qui se trouve dans les accolades sera exÃ©cutÃ© si la couleur a moins de 25% de luminositÃ© ou plus de
10% de saturation.

Vous pouvez aussi utiliser les conditions toutes seules. **Lâ€™instruction â€œ_**else**_â€ nâ€™est pas obligatoire**. Il arrive que
vous ayez besoin que du code soit exÃ©cutÃ© si une condition est remplie, mais que si elle est fausse, vous nâ€™ayez pas besoin de
faire quoi que ce soit ; dans ce cas, ne mettez pas dâ€™instruction _@else_.

Souvenez-vous, quand une condition est jugÃ©e fausse, le contenu des accolades est tout simplement **ignorÃ©** et câ€™est le bout de
code suivant qui sera pris en compte. Il peut sâ€™agir dâ€™un bloc @else, mais Ã§a peut Ãªtre tout simplement la suite de votre code :

```scss
@if ( saturation($colour) < 50% ) {
    $colour: saturation($colour, 50%);
}
background-color: $colour;
```

Regardons ensemble. Ici la condition vÃ©rifie si la **saturation** de $colourÂ est strictement infÃ©rieure Ã  50%. Si le rÃ©sultat est
vrai, alors la saturation de la couleur sera fixÃ©e Ã  50% grÃ¢ce Ã  la fonction saturation() de Sass, puis on attribuera $colour
comme couleur de fond.

Pour simplifier :Â il y a un minimum Ã  atteindre concernant la saturation de la couleur de fond. Si elle est infÃ©rieure Ã  50%, il
faut la porter Ã  50%, mais si elle est dÃ©jÃ  dâ€™au moins 50% voire plus, on peut directement passer Ã  la suite du code qui Ã©tablit
$colour en tant que couleur de fond.

:::note ?
Une seconde. Je ne suis toujours pas sÃ»r de saisir la diffÃ©rence. On peut essayer avec un autre exemple ? âœ‹
:::

Prenons un autre exemple. Avec des conditions **if/else**, câ€™est comme si vous partiez du principe que si vous Ãªtes un sorcier,
alors vous irez Ã  Poudlard, et si vous Ãªtes un moldu, vous nâ€™irez pas. Selon que vous Ãªtes un moldu ou un sorcier, vous irez ou
non Ã  Poudlard ; sauf que dans cette logique, si vous Ãªtes un moldu vous vous retrouvez sans Ã©cole, ce qui est un peu triste pour
nous autres pauvres moldus.

Avec **les instructions â€œsiâ€ toutes seules**, vous pouvez prÃ©ciser que si lâ€™Ã©tudiant est sorcier (et quâ€™il a reÃ§u sa lettre
lettre ğŸ¤­) alors il ira Ã  Poudlard ; les autres iront forcÃ©ment dans lâ€™Ã©cole la plus proche.

### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Reprenez le code de lâ€™exercice prÃ©cÃ©dent et allez plus loin avec les conditions et les arguments.

Console de code

<iframe title="codevolve" id="codevolveIframe2" src="https://www.codevolve.com/api/v1/access_token/99DFEA009319BFF81AA5A4CAD0041588" width="100%" height="500" frameborder="0"></iframe>

:::info
Et si vous compariez votre exercice avec la [correction](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-6/exercice-2)Â ?
:::

Vous avez maintenant du code qui fonctionne. Youhou ! PlutÃ´t que de regarder une couleur vous-mÃªme et de dÃ©cider si elle doit
Ãªtre plus claire ou plus foncÃ©e, vous avez dÃ©lÃ©guÃ© cette dÃ©cision en indiquant dans votre code les conditions nÃ©cessaires afin de
le laisser travailler Ã  votre place (et vous la couler douce au soleil) â˜€ï¸. Les **instructions â€œsi/alorsâ€** sont des instructions
Ã©tape par Ã©tape pour rÃ©soudre un problÃ¨me : si câ€™est comme ceci, faire cela, puis cela ; ou alors si câ€™est comme ci, faire Ã§a.

Le terme technique pour ces petites suites dâ€™instructions est **_algorithme_**. Eh oui, vous venez dâ€™Ã©crire votre premier
algorithme, fÃ©licitations ! ğŸ’ª

On pense souvent (et Ã  tort) que les algorithmes sont des morceaux de code extrÃªmement complexes et obscurs (coucou Matrix), et
câ€™est vrai quâ€™ils peuvent lâ€™Ãªtre. Lâ€™algorithme du newsfeed de Facebook est suffisamment compliquÃ© pour Ãªtre brevetÃ© ! Mais sur un
niveau plus basique, un algorithme nâ€™est rien dâ€™autre quâ€™une condition qui indique au programme comment procÃ©der.

Apprendre Ã  utiliser les conditions pour **contrÃ´ler le dÃ©roulÃ© dâ€™un programme**, ou comment exÃ©cuter les instructions et dans
quel ordre, est une Ã©tape super importante pour apprendre Ã  crÃ©er un code flexible et maintenable.

### En rÃ©sumÃ©

- Les instructions `@if`Â / `@else`Â disent au code comment se comporter en fonction de conditions qui sont vraies ou fausses.
- Elles comparent deux valeurs avec une condition et exÃ©cutent un ensemble dâ€™instructions si elle est vraie, et un autre si elle
est fausse.
- Elles rendent le code plus flexible en lui permettant de sâ€™adapter aux changements.
- Les instructions `@if` peuvent Ãªtre utilisÃ©es seules, sans `@else`.

_Dans le chapitre suivant, nous allons rÃ©organiser notre condition en lâ€™enveloppant dans sa propre petite fonction._

-----

## CrÃ©ez et utilisez des fonctions

[CrÃ©ez et utilisez des fonctions - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6599091-creez-et-utilisez-des-fonctions)

<Vimeo vimeoId="534427725" />

<br />

GrÃ¢ce aux conditions, notre code est devenu plus modulable et il peut sâ€™adapter en fonction des situations. Mais on peut aller
encore plus loin, avec les fonctions !

### Utilisez des fonctions

Ã€ lâ€™heure actuelle, la mixin heading-shadow possÃ¨de une logique qui gÃ¨re la faÃ§on dont une couleur est modifiÃ©e en fonction de
ses valeurs.

Tout fonctionne comme prÃ©vu... sauf quâ€™en fait, non.

:::note ?
Mais... mais quoi encore ?! ğŸ™„
:::

Notre mixin ajuste toujours $colour, quâ€™il sâ€™agisse de la **couleur par dÃ©faut** ou dâ€™une couleur tapÃ©e manuellement. Sauf que,
si vous tapez une couleur, câ€™est probablement quâ€™il sâ€™agit dâ€™une couleur que vous avez dÃ©jÃ  choisie, nâ€™est-ce pas ? Ce que vous
voulez vraiment ici, câ€™est ajuster automatiquement la valeur de la couleur par dÃ©faut de votre mixin, en fonction de
$colour-primary.

![On veut ajuster la couleur de la valeur par dÃ©faut](https://user.oc-static.com/upload/2019/10/09/1570633852543_image1.png)

On veut ajuster la couleur de la valeur par dÃ©faut

Pour maÃ®triser la **luminositÃ©/obscuritÃ©** de la couleur par dÃ©faut sans avoir Ã  la renseigner manuellement, vous devez modifier
sa valeur au sein de la dÃ©claration de variable dans lâ€™argument. Pour ce faire, vous devez dÃ©placer le bloc de code if/else au
sein mÃªme de lâ€™argument pour $colour :

```scss
@mixin heading-shadow($colour: @if ( lightness($colour) < 25% ) {
    $colour: lighten($colour, 10%);
    } @else {
        $colour: darken($colour, 10%);
    }, $size: $heading-shadow-size) {
    text-shadow: $size $size $colour;
}
```

:::note ?
On veut bien, mais câ€™est un peu leÂ bazar lÃ , non ?
:::

Exactement ! Câ€™est tout ce quâ€™il ne faut pas faire : ce nâ€™est pas du tout clair quand on regarde le code. OÃ¹ est-ce que les
arguments de la mixin sâ€™arrÃªtent ? OÃ¹ commence le code ? ğŸ¤¯ Toutes ces accolades rendent lâ€™ensemble trop confus. Et de toute
faÃ§on, vous ne pouvez pas faire Ã§a mÃªme si vous en avez envie : Sass vous **renverra une erreur pour syntaxe invalide.** ğŸ¤­

Au lieu dâ€™essayer de mettre un gros tas de codeÂ dans vos arguments, vous devez plutÃ´t emballer le tout et le ranger dans son
propre conteneur, ensuite vous allez pouvoir brancher facilement votre code Ã  lâ€™argument. Câ€™est ce quâ€™on appelle une **fonction**.
Vous aviez commencÃ© Ã  les utiliser quelques chapitres plus haut pour manipuler les couleurs, mais nous ne nous Ã©tions pas plongÃ©s
dedans en dÃ©tail.

PrÃ©parez vos chaudrons chers sorciers, il est temps de crÃ©er nos propres fonctions !

### CrÃ©ez des fonctions

Une fonction est un bout de code qui **effectue une tÃ¢che** lorsquâ€™elle est exÃ©cutÃ©e, comme par exemple assombrir une couleur,
indiquer sa clartÃ© ou convertir ses valeurs RBG en hexadÃ©cimal : rgb(21, 222,165). Eh oui, Ã  chaque fois que vous Ã©crivez vos
couleurs sous forme de rgb() dans .scss, vous faites appel Ã  une **fonction**. Vous les utilisez depuis le dÃ©but sans le savoir !
Cool, non ? ğŸ’«

Allez, câ€™est parti : prenons la condition de votre mixin et transformons-la en fonction !

```scss
@function lightness-shift() {
}
```

On commence par dÃ©finir une fonction en utilisant le mot clÃ© **@function** suivi de son nom. Ensuite on y ajoute une **paire de
parenthÃ¨ses** dans lesquelles on ajoutera les arguments et une **paire dâ€™accolades** pour accueillir votre code. Câ€™est un peu
comme si vous Ã©tiez en cours de potion : vous prenez une fiole (une fonction), vous y ajoutez une Ã©tiquette (un nom), puis vous
ouvrez le bouchon (accolades) pour y placer une potion (votre code) et vous refermez le bouchon (accolades).

La maniÃ¨re pour dÃ©finir une fonction et une mixin sont trÃ¨s similaires, sauf quâ€™au lieu dâ€™utiliser le mot clÃ© @mixin, on utilise
**@function**.

Et, comme pour les mixins, on peut inclure des **arguments**. PourÂ `lightness-shift()`, il vous faut un argument avec lequel la
fonction va pouvoir travailler ; ici vous voulez inclure en argument la couleur que vous voulez modifier :

```scss
@function lightness-shift($colour){
}

Et voilÃ , il nous manque juste le code ! Copiez la condition, et collez-la entre les accolades :

@function lightness-shift($colour) {
    @if ( lightness($colour) < 25% ) {
        $colour: lighten($colour, 10%);
    } @else {
        $colour: darken($colour, 10%);
    }
}
```

Votre premiÃ¨re fonction est Ã©crite Ã  99 %. Il vous manque une seule petite chose : **retourner une valeur**. Vous avez besoin
que votre fonction produise une nouvelle valeur de couleur que vous pourrez utiliser en tant que couleur par dÃ©faut pour lâ€™ombre.
Pour le moment, la fonction modifie seulement $colour avec une valeur plus claire ou plus foncÃ©e. Mais en code, vous voulez que
la fonction retourne, ou vous rende, une nouvelle valeur de couleur.

Pour que `lightness-shift()`Â retourne une valeur, vous devez indiquer Ã  la fonction ce que vous voulez quâ€™elle retourne quand
elle est exÃ©cutÃ©e. PlutÃ´t que de modifier $colour, faites en sorte que la fonction retourne la nouvelle valeur de couleur
directement. Pour faire cela, vous pouvez utiliser @return :

```scss
@function lightness-shift($colour) {
    @if ( lightness($colour) < 25% ) {
        @return lighten($colour, 10%);
    } @else {
        @return darken($colour, 10%);
    }
}
```

Lorsque vous ajoutez **@return**, vous indiquez Ã  Sass la valeur retournÃ©e que vous voulez lorsque vous appelez la fonction.
Donc, **si** la luminositÃ© est infÃ©rieure Ã  25%, vous voulez _retourner_ une couleur qui soit 10% plus claire, **sinon** vous
voulez _retourner_ une couleur qui soit 10% plus foncÃ©e.

Votre fonction est maintenant prÃªte ! IntÃ©grons-la dans votre mixin, comme lorsque vous faites appel Ã  lâ€™une des fonctions
intÃ©grÃ©es de Sass :

```scss
@mixin heading-shadow($colour: lightness-shift($colour-primary), $size: $heading-shadow-size) {
    color: $colour;
    text-shadow: $size $size $colour;
}
```

En intÃ©grant la condition dans une fonction, nous avons rendu notre code beaucoup beaucoup **plus propre et facile Ã  lire**. Et
plus facile Ã  maintenir en bonus. Nous avons rÃ©uni toute notre logique dans un seul bloc, ce qui facilite beaucoup la lecture,
la comprÃ©hension et la modification du code Ã  lâ€™avenir.

### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, entraÃ®nez-vous aux fonctions en crÃ©ant une fonction qui change une couleur en une couleur pastel, avec le code fourni dans lâ€™exercice.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/09594EFF87E368822015E82829C4E038" width="100%" height="500" frameborder="0"></iframe>

:::info
Avez-vous rÃ©ussi ? VÃ©rifiez votre travail avec la [correction de l'exercice](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-2/chapitre-7/exercice-1).
:::

FÃ©licitations ! ğŸ‘Â  Ã‰crire votre propre fonction est une sacrÃ©e Ã©tape et un aspect important de la programmation. MÃªme si la
syntaxe peut varier dâ€™un langage Ã  lâ€™autre, la logique pour dÃ©finir une fonction est identique Ã  ce que vous venez dâ€™apprendre.
Vous pouvez appliquer les techniques apprises dans les prÃ©cÃ©dents chapitres Ã  tous les langages : Ruby, JavaScript, Python, etc.

Vous pensiez juste apprendre Ã  construire des pages web, mais en rÃ©alitÃ©, vous Ãªtes en train de devenir un programmeur accompli
spÃ©cialisÃ© dans le dÃ©veloppement front-end.

PlutÃ´t cool, hein ? ğŸ˜‰

### En rÃ©sumÃ©

- Les fonctions sont des bouts de code qui effectuent une tÃ¢che lorsquâ€™elles sont exÃ©cutÃ©es.
- Elles permettent dâ€™encapsuler un bloc logique dans un module rÃ©utilisable, afin dâ€™obtenir une codebase plus propre et plus
maintenable.
- On dÃ©finit une fonction en utilisant le mot clÃ© `@function`.
- Si vous voulez quâ€™une fonction retourne une valeur, vous devez le spÃ©cifier en utilisant le mot clÃ© `@return`.

-----

## Quiz : RÃ©visez les techniques intermÃ©diaires et outils de Sass

[RÃ©visez les techniques intermÃ©diaires et outils de Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/exercises/3706)

#### CompÃ©tences Ã©valuÃ©es

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> CrÃ©er du code maintenable grÃ¢ce aux techniques Sass intermÃ©diaires

-----

#### Description

Ã€ vous de jouer en rÃ©pondant aux questions de ce quiz !

Bonne chance !

#### Question 1

```scss
.btn {
    color: #0c2461;
    font-size: 2rem;
}
.article {
    color: #0c2461;
    background-color: #fff;
}
```

**Vous souhaitez refactoriser le code ci-dessus, pour cela vous voulez stocker la couleur `#0c2461`Â dans une variable pour
pouvoir la rÃ©utiliser plusieurs fois dans votre code. Quâ€™allez-vous Ã©crire ?**
    
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> $blue = #0c2461;<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> $colour = b;<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> pink = $#0c2461;<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> $blue: #0c2461;<br />
<br />

*Les variables permettent de stocker des valeurs afin de pouvoir les rÃ©utiliser partout dans le code. Pour dÃ©clarer une variable :
`$nom_de_la_variable: valeur;`*

*Dans notre cas, la bonne rÃ©ponse est la rÃ©ponse 4 : $blue: #0c2461;*


-----

#### Question 2 :

```scss
$blue-border: border: solid 5px #0c2461;
```

**En partant du code ci-dessus, que se passe-t-il si je dÃ©clare une variable comme celle-ci pour stocker border et lâ€™appliquer
sur un sÃ©lecteur `.btn`Â ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Une erreur de compilation<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Le bouton aura une bordure bleue<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Le bouton nâ€™aura pas de bordure<br />
<br />

*Les variables permettent de stocker des valeurs mais pas un ensemble de rÃ¨gles. Le code ne fonctionnera pas et dÃ©clenchera une
erreur. Cependant il est possible de stocker les valeurs de la propriÃ©tÃ© `border`Â comme suit :*

```scss
$blue-border: solid 5px #0c2461;
```

-----

#### Question 3 : En reprenant le code de lâ€™exercice prÃ©cÃ©dent :

```scss
$blue-border: border: solid 5px #0c2461;
```

**Si vous crÃ©ez la mixin appropriÃ©e pour contenir `border`Â et que vous lâ€™appelez `blue-border`, quelle serait la bonne Ã©criture
parmi les suivantes ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
$blue-border: border: solid 5px #0c2461;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>


```scss
@mixin $blue-border: border: solid 5px #0c2461;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
@mixin blue-border {
    border: solid 5px #0c2461;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
@mixin $blue-border {
    border: solid 5px #0c2461;
}
```

*Pour dÃ©clarer une mixin, il faut quâ€™elle soit sous cette forme :*


```scss
@mixin mixin-name {
    css-property: value;
}
```

*Les deux premiÃ¨res rÃ©ponses vous donneront une erreur de compilation, cette syntaxe nâ€™est pas valide.*

*La rÃ©ponse 4 a un $ en trop. On dÃ©clare le nom dâ€™une variable avec le symbole $, pour une mixin `@mixin`Â + le nom de la mixin
suffit. Câ€™est donc la rÃ©ponse 3 qui est la bonne.*


-----

#### Question 4 : Vous avez crÃ©Ã© votre mixin `blue-border`. Il est temps de lâ€™utiliser dans vos sÃ©lecteurs. Si vous deviez utiliser votre nouvelle mixin dans le sÃ©lecteur de classe `.article`Â suivant :

```scss
.article {
    display: flex;
    padding: 5px 10px;
    color: black;
    background-color: $white;
    // insÃ©rez votre code ici
}
```

**Quelle forme prendrait-ilÂ ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> @include $blue-border;<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> @mixin blue-border;<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> @include blue-border;<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> @extend %blue-border;<br />
<br />

*Pour utiliser une mixin, il faut lâ€™inclure de cette maniÃ¨re : `@include`Â + nom_de_la_mixin.*

*La premiÃ¨re ne peut fonctionner car il y a un $ devant blue-border. Rappel : un $ permet de dÃ©clarer une variable.*

*La rÃ©ponseÂ 2 ne fonctionnera pas car `@mixin`Â sert Ã  dÃ©clarer une mixin et non Ã  lâ€™utiliser.*

*Enfin `@extend %blue-border;`Â est correct en termes de syntaxe, mais cela sert Ã  utiliser un placeholder et non une mixin.*

-----

#### Question 5 : Quelle est la diffÃ©rence entre les mixins et les extensions ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Il n'y a aucune diffÃ©rence<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Les mixins dupliquent les sÃ©lecteurs et les extensions dupliquent les rÃ¨gles<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Les mixins dupliquent les rÃ¨gles et les extensions dupliquent les sÃ©lecteurs<br />
<br />

*La diffÃ©rence principale entre les mixins et les extensions est quâ€™avec les mixins vous obtenez des **rÃ¨gles dupliquÃ©es**, alors
quâ€™avec les extensions, vous obtenez des **sÃ©lecteurs dupliquÃ©s**.*


-----

#### Question 6 : Si vous deviezÂ nommer un placeholder pour remplacer le sÃ©lecteur de classeÂ `.content-colour`, comment feriez-vous ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> $content-colour<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> %content-colour<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> .content-colour<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> &content-colour<br />
<br />

*PourÂ nommer un placeholder, il faut taper le symbole % suivi du nom du placeholder. Dans notre cas,Â `%content-colour`.*

-----

#### Question 7

```scss
.content-colour {
    color: blue;
    font-size: 2rem;
}
h1 {
    @extend .content-colour;
}
textarea {
    @extend .content-colour;
}
```

**En partant du code ci-dessus,Â sous quelle forme sera compilÃ© votre code ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
textarea {
    color: blue;
    font-size: 2rem;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.content-colour {
    color: blue;
    font-size: 2rem;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.content-colour {
    color: blue;
    font-size: 2rem;
}
h1 {
    color: blue;
    font-size: 2rem;
}
textarea {
    color: blue;
    font-size: 2rem;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
.content-colour, h1, textarea {
    color: blue;
    font-size: 2rem;
}
```

*Rappelez-vous, avec les extensions vous obtenez des **sÃ©lecteurs dupliquÃ©s**. Les rÃ©ponses 1 et 2 appliquent le rÃ©sultat sur un
seul sÃ©lecteur, aucun signe dâ€™une quelconque extension.*

*La rÃ©ponse 3 montre que les rÃ¨gles ont Ã©tÃ© dupliquÃ©es, ce serait plutÃ´t le rÃ©sultat dâ€™une mixin.*

*La bonne rÃ©ponse est donc la 4.*

-----

#### Question 8

```scss
.btn {
    border: 5px solid blue;
}
```

**Quelle serait la mixin appropriÃ©e pour obtenir le rÃ©sultat compilÃ© ci-dessus ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
mixin border-colour {
    border: 5px solid blue;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
@mixin border-colour {
    border: 5px solid blue;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
@include border-colour {
    border: 5px solid blue;
}
```

*On dÃ©clare une mixin comme ceci :*

```scss
@mixin mixin-name {
    css-property: value;
}
```

*La premiÃ¨re rÃ©ponse nâ€™a pas dâ€™@ devant mixin et ne se compilera pas, vous aurez une erreur. La troisiÃ¨me rÃ©ponse a bien un @
mais est suivi de include ; @include est utilisÃ© pour appeler votre mixin dans votre sÃ©lecteur et non pas pour la dÃ©clarer. Dans
notre cas, si on devait utiliser notre mixin, cela donnerait quelque chose de ce genre :*

```scss
.btn {
    @include border-colour;
}
```

*La bonne rÃ©ponse est donc la 2 !*

-----

#### Question 9

```scss
$white: #fff;
$pastel-blue: #0097e6;
$dark-blue: #192a56;

@mixin border-colour($colour) {
    @if ( lightness($colour) \> 25% ) {
        $colour: darken($colour, 30%);
    } @else {
        $colour: lighten($colour, 30%);
    }
    border: 5px solid $colour;
}
.article {
    display: flex;
    padding: 5px 10px;
    color: black;
    background-color: $white;
    @include border-colour($dark-blue);
}
```

```html
<div class="article">Je suis le contenu dâ€™un article, lis moi !</div>
```

**En partant du code ci dessus, de quelle couleur sera la bordure de .article si vous remplacez $dark-blue par $pastel-blue ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Blanc<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Noir<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Bleu foncÃ©<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Bleu clair<br />
<br />

*Reprenons ensemble le code de notre mixin :Â **si** la luminositÃ© de la couleur passÃ©e en paramÃ¨tre est supÃ©rieure Ã  25%, alors
on lâ€™assombrit de 30%, **sinon** on l'Ã©claircit de 30%. Si on passe en paramÃ¨tre le bleu clair, sa luminositÃ© est supÃ©rieure Ã 
25%, donc on lâ€™assombrit et la mixin applique ces changement directement dans `border`. Vous pouvez changer les valeurs dans ce
[Codepen](https://codepen.io/kadaaran-the-selector/pen/RwwWPyd) pour vous en rendre compte !*

-----

#### Question 10

```scss
$white: #fff;
$pastel-blue: #0097e6;
$text-color: #192a56;

@function background($text-color) {
    @if ( $text-color \== $white ) {
        @return $pastel-blue;
    } @else {
        @return $white;
    }
}
.btn {
    color: $text-color;
    background-color: background($text-color);
}
```

**En partant du code ci-dessus, de quelle couleur sera le `background-color`Â de `.btn`Â ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Rien, il y aura une erreur de syntaxe<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> #0097e6<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> #fff<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> #192a56<br />
<br />

*La fonction que lâ€™on applique Ã  `background-color`Â indique que si `$text-color`Â (la couleur du texte) est Ã©gale Ã  ce que
contient la variable `$white`Â (#fff qui est du blanc), alors on retourne la valeurÂ `$pastel-blue`Â (bleu pastel). Ensuite, si la
couleur duÂ texte nâ€™est pas blanche, alors on retourne la valeur `$white`Â (blanc).*

*Dans notre cas, la couleur de notre texte nâ€™est pas blanche mais bleu foncÃ© (`#192a56`), donc la fonction retourne la valeur
`$white`Â (blanc) !*

*Dans notre CSS, on indique que le rÃ©sultat de `background($text-colour)`Â sera la couleur de fond, ici ce sera donc le blanc.*

