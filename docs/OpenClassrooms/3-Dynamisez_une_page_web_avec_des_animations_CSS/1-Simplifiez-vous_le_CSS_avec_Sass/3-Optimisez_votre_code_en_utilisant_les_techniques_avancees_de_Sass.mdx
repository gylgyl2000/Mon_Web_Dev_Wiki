---
sidebar_position: 4
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# Optimisez votre code en utilisant les techniques avancÃ©es de Sass

## Utilisez le systÃ¨me 7-1 pour une codebase plus simple Ã  gÃ©rer

[Utilisez le systÃ¨me 7-1 pour une codebase plus simple Ã  gÃ©rer - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6599201-utilisez-le-systeme-7-1-pour-une-codebase-plus-simple-a-gerer)

<Vimeo vimeoId="534802603" />

<br />

Est-ce que comme moi Ã§a vous arrive dâ€™Ãªtre tellement occupÃ© que lorsque vous avez enfin un moment pour souffler, vous regardez
autour de vous et vous rendez compte quâ€™il y a pas mal de bazar ?

Yep yep, câ€™est lâ€™heure de faire le mÃ©nage. Personne nâ€™aime Ã§a, mais prendre du recul et ranger un peu est vital pour maintenir
une codebase propre et saine.

### Organisez et structurez votre code

Jusquâ€™Ã  prÃ©sent, vous avez beaucoup appris, et Ã©crit du code par la mÃªme occasion. Vos fichiers Sass sont bien **ordonnÃ©s**, avec
des **variables groupÃ©es** et des composants Ã©crits sous forme de **blocs BEM** bien **rangÃ©s** et **propres**. Mais vous devez
aussi parcourir des mixins, fonctions et autres bouts de code pour pouvoir trouver un Ã©lÃ©ment en particulier.

Fort heureusement, Sass vous permet de sÃ©parer votre code en fichiers sÃ©parÃ©s pour le **catÃ©goriser** et lâ€™**organiser**. Vous
pouvez mettre toutes vos variables dans un fichier et tous vos mixins dans un autre. Pareil pour les feuilles de style et les
composants. Pouvoir ouvrir un fichier prÃ©cis et trouver facilement un morceau de code vous Ã©vitera des migraines et vous fera
gagner beaucoup de temps.

### DÃ©couvrez le modÃ¨le 7-1

Pour ordonner tous ces nouveaux fichiers, vous allez utiliser ce qui sâ€™appelle le **systÃ¨me de fichiers 7-1**. Le â€œ7â€, ce sont
les sept **directories** thÃ©matiques (des dossiers, en langage de dÃ©veloppeur) pour ranger vos fichiers, qui sont regroupÃ©s dans
le â€œ1â€ : un fichier .scss unique se compilant sous forme de feuilles de style CSS pour votre site.

Câ€™est parti ! CrÃ©ons donc les sept directories suivants dans notre directory Sass, chacun dâ€™entre eux reprÃ©sentant une catÃ©gorie
de code Sass :
1. Base.
2. Utils.
3. Layout (mise en page).
4. Composants.
5. Pages.
6. Themes.
7. Vendors (tiers).

Un moyen rapide de crÃ©er des directories est dâ€™utiliser le **terminal** dans VS Code et la **commande** **mkdir** suivie du nom
du directory que vous souhaitez crÃ©er. Vous pouvez crÃ©er plusieurs directories simultanÃ©ment en les listant lâ€™un aprÃ¨s lâ€™autre :

:::info
Vous souhaitez en savoir plus sur les lignes de commande ? Rendez-vous sur le cours [Apprenez Ã  utiliser la ligne de commande dans un terminal](https://openclassrooms.com/fr/courses/6173491-apprenez-a-utiliser-la-ligne-de-commande-dans-un-terminal).
:::

Maintenant que vous avez crÃ©Ã© vos sept directories pour y stocker votre code, on va voir Ã  quoi sert chacun dâ€™entre eux :
- le directory **base/** contient les fichiers qui dÃ©finissent les fondations de votre site, par exemple la police de caractÃ¨res
et les normes que vous voulez appliquer sur tout votre site, telles que le box-sizing ;
- dans **utils/**, vous rangez vos variables, fonctions, mixins et lesÂ %placeholders pour les extensions (si vous en utilisez) ;
- **layouts/** est le dossier oÃ¹ vous mettez vos blocs BEM qui contiennent ce qui est rÃ©utilisable, par exemple un header pour
les mises en page de grande taille ou un footer ;
- **components/** est utilisÃ© pour ranger les blocs BEM qui sont plus indÃ©pendants, comme les boutons.

Alors que les layouts peuvent utiliser dâ€™autres composants pour gÃ©nÃ©rer leurs contenus, les **composants**,Â eux, sont plus
Ã©lÃ©mentaires. Par exemple, un formulaire doit Ãªtre considÃ©rÃ© comme un layout : la mise en page est une fonction vitale du bloc et
il utilise dâ€™autres blocs pour fonctionner,Â comme des boutons. En revanche, le bouton lui-mÃªme est un composant car il nâ€™a besoin
dâ€™aucun autre composant pour remplir sa fonction ;

- **pages/** contient les blocs de code qui ne sâ€™appliquent quâ€™Ã  une seule page. Vous utilisez des boutons dans tout votre site,
en revanche votre page dâ€™accueil comporte une section Citation et une grille de projets qui ne sont employÃ©s nulle part ailleurs.
En dâ€™autres termes, pages/ contient des rÃ¨gles spÃ©cifiques Ã  une seule page qui ne seront pas rÃ©utilisÃ©es ailleurs ;
- **themes/**, câ€™est ici que vous stockez le code thÃ©matique, par exemple un style customisÃ© pour NoÃ«l ou pour lâ€™Ã©tÃ©. On ne
lâ€™utilisera pas dans notre site ;
- **vendors/**Â est un directory pour des feuilles de style externes comme Bootstrap ou jQuery UI. En gros, il sâ€™utilise pour tout
CSS venant de lâ€™extÃ©rieur. Utiliser des frameworks comme Bootstrap permet dâ€™accÃ©lÃ©rer le dÃ©veloppement dâ€™un site, car ils
contiennent des feuilles de style prÃ©dÃ©finies pour des choses comme les formulaires ou des boutons.

#### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, entraÃ®nez-vous et crÃ©ez les sept directories du 7-1 pattern via le terminal ou via le panneau de navigation.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/A7A011CDB32BF49CF5658FAC6A75F446" width="100%" height="500" frameborder="0"></iframe>

Retrouvez la [correction de l'exercice ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-3/chapitre-1/exercice-1) !

### Nettoyez et rÃ©organisez vos fichiers

Maintenant que vous avez tous ces directories sous la main, quâ€™est-ce que vous pouvez bien en faire ? CommenÃ§ons par ranger un
peu en mettant toutes les variables dans leur fichier attitrÃ©. Pour cela, crÃ©ez un fichier dans le dossier Utils, nommÃ©
`_variables.scss`Â :

![Image illustrant la crÃ©ation d'un fichier](https://user.oc-static.com/upload/2019/10/09/15706344888741_image1.jpg)

CrÃ©ation d'un fichier

Vous avez maintenant un fichier pour vos variables imbriquÃ©es dans le **directory utils/**. Son titre est logique : un fichier
nommÃ© â€œvariablesâ€ pour ranger des variables.

:::note ?
Mais pourquoi cet underscore ? ğŸ¤”
:::

Lorsque vous sÃ©parez votre code, les fichiers individuels font tous **partie dâ€™une codebase globale**, du coup Sass les appelle
des **partiels**. Pour indiquer Ã  Sass quâ€™un fichier est un partiel, vous devez lui ajouter le prÃ©fixe **underscore (_)**.

Tous les partiels commencent par un underscore (_), suivi de son nom (ici variables) puis de lâ€™extension de fichier `.scss`
ğŸ‘‰ğŸ¼ `_variables.scss`.

Nous avons un fichier pour nos variables ; Ã  prÃ©sent nous pouvons couper nos variables de notre fichier scss principal pour les
coller dans notre nouveau fichier `_variables.scss`Â :

![Image illustrant le fichier variables Ã  couper](https://user.oc-static.com/upload/2019/10/09/15706345944107_image15.jpg)

Le fichier Variables Ã  couper

Ahâ€¦ regardez le CSS compilÃ©, vous voyez une erreur !

```scss
error sass/main.scss (Line 16: Undefined variable: "$colour-secondary".)
```

Sass vous indique que vous utilisez des **variables non dÃ©finies** dans le code. Nous avons dÃ©placÃ© nos variables dans leur
propre partiel, mais nous nâ€™avons pas dit au fichier main.scss oÃ¹ les trouver ! Avant de pouvoir utiliser du code qui a Ã©tÃ©
dÃ©coupÃ© en partiels, vous devez prÃ©ciser dans votre codebase oÃ¹ importer ces nouvelles variables. Comment ? En utilisant le mot
clÃ© **@import**.

```scss
@import "./utils/variables";
```

Pour importer les variables, vous devez taper @import suivi dâ€™une paire de guillemets. Entre les guillemets, renseignez le chemin
vers le partiel des variables.

:::info
Le chemin traduit lâ€™endroit oÃ¹ se situe votre fichier par rapport Ã  votre point de dÃ©part.
:::

Le point (.) indique Ã  Sass que pour arriver jusque _variables_, le chemin commence dans le mÃªme dossier que main.scss. Ensuite,
/utils/ mÃ¨ne Sass au directory _utils_ dans lequel il trouvera le partiel _variables_.

:::info
Notez quâ€™on nâ€™utilise pas dâ€™underscore ni dâ€™extension de fichier lorsquâ€™on indique dans le chemin le **nom du fichier du partiel**.
Lors de lâ€™importation dâ€™un partiel, Sass sait quâ€™il lui faut chercher un fichier commenÃ§ant par un underscore et quâ€™il sâ€™agit dâ€™un
fichier Sass, pas besoin de le prÃ©ciser.
:::

Et si vous jetez un Å“il au CSS compilÃ©, vous verrez que les variables se comportent comme si elles se trouvaient encore dans le
fichier main.scss :

```scss
body {
    box-sizing: border-box;
    background: #001534;
}
```

Parfait ! Nous avons rendu notre code plus propre en regroupant toutes nos variables de couleurs au mÃªme endroit.ğŸ‘Œ

#### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice, regroupez les couleurs dans un nouveau fichier.

Console de code

<iframe title="codevolve" id="codevolveIframe2" src="https://www.codevolve.com/api/v1/access_token/B27B46A1F3FD3807BB10AF652D338413" width="100%" height="500" frameborder="0"></iframe>

Avez-vous essayÃ© l'exercice ? Retrouvez la [correction ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-3/chapitre-1/exercice-2) !

**Faites de lâ€™ordre dans le bloc formulaire**

Maintenant que vous lâ€™avez fait pour les couleurs, on ne va pas sâ€™arrÃªter en si bon chemin. Attaquons-nous au bloc du formulaire !
Dans layouts/, crÃ©ez un nouveau partiel nommÃ© _form.scss, puis coupez-collez le bloc formulaire depuis main.scss. Pourquoi le
directory layout ? Parce que le formulaire est un grand composant, qui en contient plusieurs et quâ€™il peut Ãªtre rÃ©utilisÃ©.

```scss
.form {
    width: 100%;
    padding-bottom: $grid-gutter;
    &__heading {
        width: 100%;
        color: $colour-white;
        @include heading-shadow;
        background: $colour-primary;
        line-height: 5rem;
        padding: $grid-gutter;
    }
    &__field {
        & label {
            color: $colour-accent;
            display: block;
            font-size: map-get($txt-size, label);
            line-height: map-get($txt-size, label);
            padding-top: $grid-gutter;
        }
        & input {
            width: 100%;
            background: $colour-secondary;
            @include border;
            padding: $grid-gutter;
            color: $colour-accent;
        }
        & textarea {
            width: 100%;
            color: $colour-primary;
            background: $colour-secondary;
            @include border;
            outline: none;
            padding: $grid-gutter;
            margin-bottom: $grid-gutter\*0.5;
            &:active, &:focus {
                color: $colour-accent;
            }
        }
    }
}
```

Maintenant que le bloc formulaire est dans son propre partiel, nous devons lâ€™importer dans notre fichier principal pour pouvoir
lâ€™utiliser, comme avec _variables_ :

```scss
@import "./utils/variables";
@import "./layouts/form";
```

Notez que nous avons placÃ© lâ€™import du formulaire _aprÃ¨s_ les variables. **Lâ€™ordre dans lequel vous importez vos partiels dans
le fichier principal est lâ€™ordre dans lequel Sass compilera tout ce quâ€™ils contiennent**. Si on importait le partiel du formulaire
avant les variables, on aurait une erreur de compilation, car les variables utilisÃ©es dans le formulaire nâ€™auraient pas encore
Ã©tÃ© dÃ©finies !

Dâ€™une maniÃ¨re gÃ©nÃ©rale, pour Ã©viter les erreurs, faites en sorte dâ€™importer vos fichiers dans lâ€™ordre suivant :

1. **Utils** :
    1. Variables.
    2. Fonctions.
    3. Mixins.
    4. Placeholders.
2. **Feuilles de style de tiers (vendors)** (si vous en avez).
3. **Base.**
4. **Composants.**
5. **Layout.**
6. **Pages.**
7. **ThÃ¨mes.**

Vous nâ€™aurez sans doute pas besoin de tous ces dossiers pour chaque site sur lesquels vous travaillerez. Le site que nous
construisons dans ce cours nâ€™utilise pas de feuilles de styles externes, ni de thÃ¨mes, par exemple. Mais il est important que
vous les connaissiez ğŸ‘Œ.

Une fois que lâ€™ensemble du code a bien Ã©tÃ© sÃ©parÃ© en partiels et importÃ©, le fichier main.scss ne doit contenir que des imports.
Les ensembles de rÃ¨gles sont eux aussi rangÃ©s dans leurs propres partiels :

```scss
@import "./utils/variables";
@import "./utils/functions";
@import "./utils/mixins";
@import "./utils/extensions";
@import "./base/base";
@import "./base/typography";
@import "./components/buttons";
@import "./layouts/header";
@import "./layouts/nav";
@import "./layouts/container";
@import "./layouts/form";
@import "./pages/work";
@import "./pages/about";
@import "./pages/project";
```

Ã€ prÃ©sent, pour trouver un bout de code, câ€™est aussi simple que de regarder votre fichier main.scss pour voir oÃ¹ il est rangÃ© !
Facile Ã  lire, Ã  Ã©crire et Ã  maintenir. Les rÃ¨gles dâ€™or du code sont honorÃ©es ! ğŸ™Œ

### En rÃ©sumÃ©

- Le systÃ¨me de fichiers 7-1 se compose de sept dossiers thÃ©matiques qui sont regroupÃ©s dans un fichier .scss.
- Les 7 directories thÃ©matiques sont :
    - Base ;
    - Utils ;
    - Layout (mise en page) ;
    - Composants ;
    - Pages ;
    - ThÃ¨mes ;
    - Vendors (tiers).
- Dans Sass, les diffÃ©rents fichiers sâ€™appellent des partiels. Ils commencent par un underscore.
- On importe les partiels dans le fichier principal `.scss`Â en utilisant le mot clÃ© `@import`.
- Dans Sass, les partiels sont compilÃ©s dans le mÃªme ordre que celui dans lequel ils sont importÃ©s.

_Dans le chapitre suivant, nous allons installer Sass sur votre ordinateur !_

-----

## Installez Sass sur votre machine

[Installez Sass sur votre machine - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6599386-installez-sass-sur-votre-machine)

<Vimeo vimeoId="534814848" />

<br />

GrÃ¢ce au systÃ¨me 7-1, nous avons sÃ©parÃ© notre Sass en **morceaux logiques** ce qui facilite la tÃ¢che pour trouver et maintenir
des Ã©lÃ©ments. Mais vous ne pouvez pas juste vous asseoir devant votre ordinateur et commencer Ã  travailler. Pour le moment, le
projet se trouve entiÃ¨rement dans le **cloud**. Vous devez donc ouvrir un navigateur, naviguer, vous connecter, puis charger le
projet. Il vous faut aussi une connexion internet pour pouvoir continuer Ã  travailler et sauvegarder votre travail.

### TÃ©lÃ©chargez les fichiers du projet

Et si vous voulez travailler dans lâ€™avion ? Ou quand vous nâ€™avez quâ€™une connexion wifi mÃ©diocre ? Ou si vous voulez juste lâ€™avoir
dans votre ordinateur ? La solution est de **tÃ©lÃ©charger** tous les fichiers source et d'**installer Sass** sur votre machine,
ce qui vous permettra de recompiler votre Sass en CSS Ã  chaque fois que vous faites des changements.

Il existe de nombreuses maniÃ¨res pour installer Sass sur votre machine, nous allons en voir juste une pour des raisons de
simplicitÃ©. Mais avant de commencer, vous devez transfÃ©rer les fichiers du site sur votre ordinateur pour que vous ayez de quoi
travailler.

:::info
Si vous suivez ce cours en ligne, vous pouvez dâ€™ores et dÃ©jÃ  tÃ©lÃ©chargerÂ vos fichiers. Sinon, vous pouvez tÃ©lÃ©charger
**[le fichier zip ici](https://s3-eu-west-1.amazonaws.com/course.oc-static.com/courses/5625786/Maintainable-CSS-with-SASS-pt04ch02_start+(4).zip)**.
:::

Une fois que vous avez tÃ©lÃ©chargÃ© les fichiers, il faut les **extraire** et les placer dans le dossier oÃ¹ vous voulez que votre
projet soit rangÃ©. En ce qui me concerne, jâ€™ai un dossier nommÃ© openclassrooms-coursesÂ dans lequel jâ€™ai extrait mon projet
`writing-sass`. Tous les fichiers pour notre site sont situÃ©s dans mon dossier `writing-sass`.

Lancez VS Code et ouvrez le dossier du projet en sÃ©lectionnant â€œOuvrir le dossierâ€ (Open Folder) dans le menu Fichier :

![Illustration de l'onglet open folder](https://user.oc-static.com/upload/2019/10/09/15706351658794_image21.jpg)

L'onglet Open Folder

En allant dans votre dossier et en sÃ©lectionnant le **directory** de votre projet, vous verrez les fichiers du projet dans le
panneau de navigation de gauche dans VS Code :

![Illustration du panneau de navigation](https://user.oc-static.com/upload/2019/10/09/15706352709479_image11.jpg)

Le panneau de navigation

Si vous vous baladez, vous verrez que tous vos fichiers HTML, CSS et `.scss`Â sont bien lÃ  oÃ¹ ils doivent Ãªtre. Notre site est
dÃ©sormais dans votre ordinateur ! Maintenant que votre site est sur votre ordinateur, il ne vous reste plus quâ€™Ã  installer Sass.

### Installez et lancez Sass en 4 Ã©tapes

#### 1. Installez NodeJS surÂ votre ordinateur

Pour installer Sass, vous allez avoir besoin dâ€™installer NodeJS.<br />
Et oui, câ€™est assez frÃ©quent en informatique de devoir faire des installations en chaÃ®ne et quâ€™un programme dÃ©pende dâ€™un autre
pour sâ€™exÃ©cuter ![:)](https://openclassrooms.com/bundles/common/images/smiley/smile.png). Cela dit, rassurez-vous, câ€™est trÃ¨s
rapide et trÃ¨s simple.

:::info
Si vous ne souhaitez pas encore procÃ©der Ã  cette installation,Â retrouvezÂ un peu plus bas comment passer par une **extension
VsCode** pour ne pas avoir Ã  tÃ©lÃ©charger et installer NodeJS et Sass.
:::

##### Installation de Sass sur Windows

Rendez-vous sur la [page dâ€™installation de NodeJS](https://nodejs.org/) et tÃ©lÃ©chargez la LTS (actuellement la 14.16.1).

![Capture d'Ã©cran des boutons de tÃ©lÃ©chargement de NodeJS](https://user.oc-static.com/upload/2021/04/14/16183870576618_image3.png)

Cliquez sur le bouton de tÃ©lÃ©chargement de la version LTS

Une fois le tÃ©lÃ©chargement rÃ©alisÃ©, exÃ©cutez le .exe et lancez lâ€™installation.

:::caution !
Lors de lâ€™installation de NodeJS, il est important de laisser â€œnpm packager managerâ€ et â€œAdd to PATHâ€ cochÃ©s.
:::

![Capture d'Ã©cran de la fenÃªtre d'installation oÃ¹ l'on apparaÃ®t bein npm packer manager et Add to PATH.](https://user.oc-static.com/upload/2021/04/14/1618387225824_image4.png)

La fenÃªtre d'installation de NodeJS

Une fois lâ€™installation terminÃ©e, je vous invite Ã  lancer lâ€™invite de commandes windows :

![Capture d'Ã©cran de la fenÃªtre d'invite de commande de Windows](https://user.oc-static.com/upload/2021/04/14/16183873536546_image5.png)

La fenÃªtre d'invite de commande de Windows

Une fois, sur lâ€™invite de commandes, entrez la commande : `node -v`Â puis la commande `npm -v`.

Ces deux commandes vous permettront de vÃ©rifier si :
- Node est bien installÃ© et de connaitre sa version.
- Npm est bien installÃ© et de connaitre sa version.

Vous pouvez maintenant installer Sass avec la commande `npm -g install sass`.

##### Installation de Sass sous MacOS

Sous MacOS, les Ã©tapes sont les mÃªmes niveau installation. Rendez-vous sur [nodejs.org](https://nodejs.org/) et tÃ©lÃ©chargez la
LTS de NodeJS. Installez-le ensuite en cliquant sur le programme tÃ©lÃ©chargÃ©.  
  
Une fois installÃ©, ouvrez votre terminal et tapez les commandes suivantes :
- `node -v`
- `npm -v`

![Capture d'Ã©cran du terminal de commande affichant les versions de Node et npm](https://user.oc-static.com/upload/2021/04/14/16183876507006_image2.png)

Le terminal de commande affichant les versions de Node et Npm

:::info
Vous pouvez maintenant procÃ©der Ã  lâ€™installation de Sass avec la commande `npm -g install sass`.
:::

##### Installation de Sass avec VsCode

Voici un petitÂ plus pour les utilisateurs de VsCode ! Il existe une excellente extension qui va vous permettre dâ€™utiliser Sass
simplement, sans l'installer ni mÃªme NodeJS.

Cette extension sâ€™appelleÂ **[Live Sass Compiler](https://marketplace.visualstudio.com/items?itemName=ritwickdey.live-sass)**.
Pour lâ€™installer, lancez lâ€™onglet â€œextensionâ€ de VsCode.

![Capture d'Ã©cran reprÃ©sentant l'onglet extension de VsCode](https://user.oc-static.com/upload/2021/04/14/16183880456963_image1.png)

L'onglet extension de VsCode

Puis recherchez lâ€™extension Live Sass Compiler et installez-lÃ .

![Capture d'Ã©cran de tÃ©lÃ©chargement de l'extension Live Sass Compiler](https://user.oc-static.com/upload/2021/04/14/16183880942109_image7.png)

L'extension Live Sass Compiler

:::info
Vous pourrez maintenant lancer facilement la compilation de fichiers Sass.

Si vous avez installÃ© l'extension, je vous invite Ã  vous rendre directement Ã  la section suivante "Comment on allume ce truc" ?
:::

#### 2. Ouvrez une ligne de commande sur VsCode

Tout dâ€™abord, il vous faut une ligne de commande pour que la magie puisse commencer. Dans VS Code, allez dans Vue, puis
choisissez Terminal ou utilisez le raccourci clavier Ctrl + ` :

![Image montrant comment sÃ©lectionner Terminal](https://user.oc-static.com/upload/2019/10/09/15706353317957_image10.jpg)

SÃ©lection de Terminal

La partie infÃ©rieure de VS Code laisse dÃ©sormais place Ã  une fenÃªtre avec un terminal !

![Image montrant la fenÃªtre de terminal window](https://user.oc-static.com/upload/2019/10/09/1570635400214_image19.jpg)

FenÃªtre de terminal Windows

PremiÃ¨re Ã©tape : ouvrir une ligne de commande. Check. âœ…

#### 3. Initialisez un fichier npm package.json

Vous Ãªtes maintenant prÃªt pour la deuxiÃ¨me Ã©tape : initialiser un fichierÂ `npm package.json`.

:::note ?
Euh, un quoi ? ğŸ˜°
:::

`package.json`Â est un fichier qui **stocke** les informations sur votre projet : nom, numÃ©ro de version, auteur, info de licence,
dÃ©pendances externes, et, encore plus important, des petits bouts de code Ã  exÃ©cuter (que nous appellerons dorÃ©navant des
**_scripts_**). Dites-vous que le `package.json`Â est un manuel dâ€™utilisation pour que `npm`Â puisse rÃ©assembler et faire
fonctionner votre site.

:::info
LeÂ `package.json`Â liste les **packages** nÃ©cessaires pour faire marcher votre propre code, qui sont appelÃ©s des **dÃ©pendances**.
Aussi appelÃ©s **_librairies_**, ce sont des collections de code que vous pouvez utiliser pour exÃ©cuter votre propre code. Au lieu
dâ€™Ã©crire toutes vos fonctions vous-mÃªme, vous pouvez aussi installer celles dâ€™autres personnes, ce qui vous Ã©pargne de devoir
Ã©crire de grandes quantitÃ©s de code et vous facilite la vie.
:::

CrÃ©ons un fichier package en tapant npm init :

```shell
npm init
```

La ligne de commande vous demande Ã  prÃ©sent un tas dâ€™infos sur votre projet. Si vous taper _Entrer_ sans remplir les champs
demandÃ©s, `npm`Â les remplira avec la valeur par dÃ©faut affichÃ©e entre parenthÃ¨ses. Sâ€™il nâ€™y a pas de parenthÃ¨ses, tapez juste
_Entrer_ et le champ sera vide :

![Illustration du champ vide](https://user.oc-static.com/upload/2019/10/09/1570635652089_image5.jpg)

Le champ est videÂ 

Ã€ vous de jouer, remplissez les champs comme vous le souhaitez. Ne vous inquiÃ©tez pas du _repository git_ pour le moment. Une
fois que tous les champs sont remplis, la ligne de commande vous montrera un aperÃ§u de votre package.json et vous demandera si
cela vous convient. Tapez _Entrer_ pour accepter.

![Illustration de la fenÃªtre de terminal](https://user.oc-static.com/upload/2019/10/09/15706357314077_image14.jpg)

Le terminal

Un fichier `package.json`Â est apparu dans le panneau de navigation sur la gauche de VS Code. Cliquez dessus et regardez ce quâ€™on
y trouve !

```json
{
"name": "writting-sass",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
"test": "echo \\"Error: no test specified\\" && exit 1"
},
"author": "",
"license": "ISC"
}
```

Ce que vous avez lÃ  est un **objet JSON** contenant toutes les donnÃ©es que vous venez de renseigner. Ã€ mesure que vous installez
des packages (ou _librairies_), ils apparaÃ®tront parmi les objets dÃ©pendances, ce qui donnera si on ajoute bootstrap par exemple :

```json
"dependencies": {
"bootstrap": "4.2.1",
}
```

OK, initialiser un package npm : validÃ© ! âœ…

Et pour finir, la troisiÃ¨me et derniÃ¨re Ã©tape : installer Sass. Enfin ! ğŸ™Œ

#### 4. Installez Sass

Dans la ligne de commande, tapez npm install sass -g.

```shell
npm install -g sass
```

OK, alors on va dÃ©cortiquer cette ligne de commande ensemble pour mieux la comprendre. Tout dâ€™abord, lorsque vous tapez _npm_,
cela indique que vous allez exÃ©cuter une commande npmÂ ; _install_ est la **commande npm** que vous Ãªtes en train dâ€™exÃ©cuter :
elle tÃ©lÃ©chargera et installera les packages indiquÃ©s. Dans le cas prÃ©sent, câ€™est le package Sass qui sera installÃ©, ainsi que
toutes ses Ã©ventuelles dÃ©pendances. _-g_Â sâ€™appelle un **_flag_ (ou _drapeau_ en franÃ§ais)**. Cela indique Ã  nmp dâ€™installer le
package globalement, câ€™est-Ã -dire sur lâ€™ensemble de votre machine, plutÃ´t que de lâ€™installer seulement pour votre projet. Vous
nâ€™aurez plus jamais Ã  installer Sass !

:::info
Npm est une interface de ligne de commande qui est intÃ©grÃ©e dans le framework du serveur node.js. Il installe des packages et
vous permet dâ€™exÃ©cuter des scripts et de gÃ©rer les dÃ©pendances. Si vous nâ€™avez pas encore installÃ© Node, allez voir notre cours
sur lâ€™installation des environnements de production.
:::

Pour vÃ©rifier que vous avez bien installÃ© Sass dans votre systÃ¨me, tapezÂ sass --versionÂ dans le terminal :

```shell
sass --version
```

La ligne de commande vous rÃ©pond en vous indiquant quelle version de Sass est installÃ©e. Si par malheur vous aviez fait une
erreur et que Sass nâ€™Ã©tait pas installÃ©, pas de panique vous auriez eu un message dâ€™erreur vous indiquant que Sass nâ€™est pas
reconnu :

![Illustration du message d'erreur](https://user.oc-static.com/upload/2019/10/09/15706359406906_image7.jpg)

Le message d'erreur

Si vous voyez Sass et une version affichÃ©e, ici : Sass 3.5.1 câ€™est tout bon.

QuatriÃ¨meÂ Ã©tape : installer Sass. EffectuÃ©e ! âœ…

ğŸ‰ğŸ‰ğŸ‰

### Comment on allume ce truc ?

Okay. Vous avez installÃ© Sass, maintenant comment est-ce quâ€™on le fait fonctionner ?

Vous avez installÃ© Sass via `npm`, que vous pouvez utiliser pour faire fonctionner Sass et compiler votre CSS. Si on revient au
fichier `package.json`Â crÃ©Ã© il y a peu de temps, vous avez peut-Ãªtre remarquÃ© un objet â€œscriptsâ€ :

```json
{
"name": "writting-sass",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
"test": "echo \\"Error: no test specified\\" && exit 1"
},
"author": "",
"license": "ISC"
}
```

Câ€™est ici que vous allez mettre votre **script** pour pouvoir faire **fonctionner** Sass. Nous nâ€™allons pas faire de test, vous
pouvez donc vous dÃ©barrasser du script de test et le remplacer par un nouveau script : sass, suivi de deux points et dâ€™une paire
de guillemets :

```json
{
"name": "writting-sass",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
"sass": ""
},
"author": "",
"license": "ISC",
}
```

Vous avez maintenant dÃ©fini un script `npm`Â nommÃ© _sass_, mais il est vide. Si vous essayez de le faire fonctionner, il ne se
passera rien. On va y remÃ©dier ! Entre les **guillemets**, tapez ceci : `sass --watch ./sass/main.scss:./public/css/style.css`.

```json
{
"name": "writting-sass",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
"sass": "sass --watch ./sass/main.scss:.public/css/style.css"
},
"author": "",
"license": "ISC",
}
```

:::note ?
Une suite de points et de tirets incomprÃ©hensibles... Qu'est-ce que Ã§a veut dire ?
:::

Pas de panique ! DÃ©taillons ensemble ce que vous venez dâ€™Ã©crire :
- _sass_Â indique Ã  `npm`Â oÃ¹ trouver le script Ã  exÃ©cuter ;
- `--watch`Â (_observer_, en anglais) est un flag (ou une option) que npm utilise pour trouver dâ€™Ã©ventuels changements dans le
fichier Sass. En dâ€™autres termes, il observe si un changement opÃ¨re et sâ€™il en voit, il recompilera et mettra Ã  jour le fichier
CSS. Sans le flag watch, il vous faudrait faire tourner le script Ã  chaque fois que vous sauvegardez votre fichier. Mais grÃ¢ce Ã 
lui, la mise Ã  jour se fera automatiquement tant que le script tourne dans votre terminal ;
- `./sass/main.scss`Â indique au script situÃ© dans node-sass oÃ¹ trouver le fichier Sass Ã  compiler ;
- les deux pointsÂ sÃ©parent le chemin source du chemin de destination ;
- `./css/style.css`Â indique au script lâ€™endroit oÃ¹ compiler le CSS et comment le nommer.

Vous avez Ã©crit un script, maintenant il est lâ€™heure dâ€™enregistrer le fichier `package.json`Â et de lancer Sass ! ğŸš€

Dans le terminal, tapez â€œnpm run sassâ€ :

```shell
npm run sass
```

Câ€™est exactement comme la fois oÃ¹ vous avez initialisÃ© le fichier package : _npm_ indique Ã  la ligne de commande que vous voulez
exÃ©cuter une commande npm. La commande, câ€™est _run_. Et _sass_, câ€™est le nom du script que vous voulez exÃ©cuter.

Juste aprÃ¨s, la ligne de commande indique le contenu du script, puis compile votre `main.scss`Â en CSS :

![Illustration du code qui compile](https://user.oc-static.com/upload/2019/10/09/15706362981507_image3.jpg)

Le code compile

Ã‡a y est, vous Ãªtes fin prÃªt !

Tant que vous nâ€™interrompez pas le processus, soit en tapant Ctrl+C dans le terminal, soit en cliquant sur la corbeille, le
script attendra et sera Ã  l'affÃ»t de tout changement Ã  compiler. On va vÃ©rifier Ã§a en changeant la couleur dans lâ€™une de nos
variables, puis en sauvegardant.

Si tout a fonctionnÃ© comme prÃ©vu, la ligne de commande va repÃ©rer le changement puis nous indiquera quâ€™elle a recompilÃ© le CSS
en vert :

![Illustration du code recompilÃ©](https://user.oc-static.com/upload/2019/10/09/15706363384504_image6.jpg)

Le code recompilÃ©

Ã‡a marche !

Mais si vous faites une erreur, par exemple en tapant une faute de frappe intentionnelle, Sass enverra une erreur Ã  la ligne de
commande :

![Illustration d'une erreur dans le code](https://user.oc-static.com/upload/2019/10/09/15706364557812_image13.jpg)

Une erreur dans le code

Oooooops on dirait quâ€™on a oubliÃ© le â€œyâ€ de $colour-primary . Hop, on corrigeÂ !

![Illustration du code qui compile Ã  nouveau](https://user.oc-static.com/upload/2019/10/09/15706364855752_image12.jpg)

Le code qui compile Ã  nouveau

Sass voit que nous avons modifiÃ© le fichier et tente de le recompiler. Cette fois-ci, nous avons corrigÃ© la faute de frappe et
voyons un message vert de victoire. Vous avez maintenant le site et Sass sur votre ordinateur, vous pouvez donc travailler avec
ou sans connexion, oÃ¹ que vous soyez !

### DÃ©couvrez les diffÃ©rents modes de compilation

Ouvrez votre feuille style.css fraÃ®chement compilÃ©e :

```scss
.form {
    width: 100%;
    padding-bottom: 1.5rem; }
.form__heading {
    width: 100%;
    color: #fff;
    text-shadow: 0.55rem 0.55rem #11af82;
    background: #15DEA5;
    line-height: 5rem;
    padding: 1.5rem; }
.form__field label {
    color: #D6FFF5;
    display: block;
    font-size: 2rem;
    line-height: 2rem;
    padding-top: 1.5rem; }
.form__field input {
    width: 100%;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    padding: 1.5rem;
    color: #D6FFF5;
    font-weight: 900;
    font-style: italic;
    font-size: 2.75rem; }
.form__field textarea {
    width: 100%;
    color: #15DEA5;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    outline: none;
    padding: 1.5rem;
    margin-bottom: 0.75rem;
}
```

Elle a un aspect lÃ©gÃ¨rement diffÃ©rent par rapport Ã  quand nous Ã©crivions notre CSS Ã  la main. Toutefois, Sass a prÃ©servÃ© la
**hiÃ©rarchie visuelle** du **nesting** issue des feuilles `.scss`. Câ€™est bien pratique, car Ã§a vous permet de parcourir le fichier
CSS facilement pour trouver les blocs de code qui vous intÃ©ressent.

Sass a quatre modes de compilation qui interprÃ¨tent chacun le CSS dâ€™une faÃ§on diffÃ©rente. Le premier, le mode par dÃ©faut, est ce
que vous venez de voir, le mode **nested**.

Le deuxiÃ¨me mode de compilation est appelÃ© **expanded**, et il ressemble en tout point Ã  du CSS quâ€™on aurait rÃ©digÃ© manuellement :

```scss
.form {
width: 100%;
padding-bottom: 1.5rem;
}
.form__heading {
width: 100%;
color: #fff;
text-shadow: 0.55rem 0.55rem #11af82;
background: #15DEA5;
line-height: 5rem;
padding: 1.5rem;
}
.form__field label {
color: #D6FFF5;
display: block;
font-size: 2rem;
line-height: 2rem;
padding-top: 1.5rem;
}
.form__field input {
width: 100%;
background: #001534;
border: 0.1rem solid #15DEA5;
padding: 1.5rem;
color: #D6FFF5;
font-weight: 900;
font-style: italic;
font-size: 2.75rem;
}
.form__field textarea {
width: 100%;
color: #15DEA5;
background: #001534;
border: 0.1rem solid #15DEA5;
outline: none;
padding: 1.5rem;
margin-bottom: 0.75rem;
}
```

Certaines personnes prÃ©fÃ¨rent lâ€™expanded plutÃ´t que le nested parce quâ€™il leur paraÃ®t plus familier. Ã€ vous de voir.

Le troisiÃ¨me mode est **compact**. Il traduit le CSS avec un ensemble de rÃ¨gles par ligne :

```scss
.form { width: 100%; padding-bottom: 1.5rem; }
.form__heading { width: 100%; color: #fff; text-shadow: 0.55rem 0.55rem #11af82; background: #15DEA5; line-height: 5rem; padding: 1.5rem; }
.form__field label { color: #D6FFF5; display: block; font-size: 2rem; line-height: 2rem; padding-top: 1.5rem; }
.form__field input { width: 100%; background: #001534; border: 0.1rem solid #15DEA5; padding: 1.5rem; color: #D6FFF5; font-weight: 900; font-style: italic; font-size: 2.75rem; }
.form__field textarea { width: 100%; color: #15DEA5; background: #001534; border: 0.1rem solid #15DEA5; outline: none; padding: 1.5rem; margin-bottom: 0.75rem; }
```


Le mode compact donne un fichier plus court et lÃ©gÃ¨rement plus lÃ©ger qui nÃ©cessite moins de scrolling, mais il nâ€™est pas forcÃ©ment
facile Ã  lire.

Le quatriÃ¨me et dernier mode est **compressÃ©**. Quand Sass compile la feuille CSS en mode compressÃ©, il retire tous les espaces et
retours Ã  la ligne inutiles :

```scss
.form{width:100%;padding-bottom:1.5rem}.form__heading{width:100%;color:#fff;text-shadow:.55rem .55rem #11af82;background:#15DEA5;line-height:5rem;padding:1.5rem}.form__field label{color:#D6FFF5;display:block;font-size:2rem;line-height:2rem;padding-top:1.5rem}.form__field input{width:100%;background:#001534;border:0.1rem solid #15DEA5;padding:1.5rem;color:#D6FFF5;font-weight:900;font-style:italic;font-size:2.75rem}.form__field textarea{width:100%;color:#15DEA5;background:#001534;border:0.1rem solid #15DEA5;outline:none;padding:1.5rem;margin-bottom:.75rem}
```

Le rÃ©sultat est compliquÃ© Ã  lire, mais Ã§a donne un fichier beaucoup plus lÃ©ger. On appelle aussi cela un **fichier CSS minifiÃ©**,
et câ€™est gÃ©nÃ©ralement ce quâ€™on utilise quand on dÃ©ploie le site en live. La taille rÃ©duite du fichier diminue la quantitÃ© de
donnÃ©es devant Ãªtre tÃ©lÃ©chargÃ©es, ce qui rÃ©duit les temps de chargement, les besoins en matiÃ¨re dâ€™espace de stockage et la
consommation de donnÃ©es.

Mettons Ã  jour le script pour quâ€™il compile votre CSS en mode compressÃ© !

### DÃ©couvrez la compilation en mode compressÃ©

Ã€ la fin de votre script, vous devez ajouter un nouveau **flag** : --style, suivi du style dans lequel vous voulez compiler,
compressed :

```json
{
"name": "writting-sass",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
"sass": "sass --watch ./sass/main.scss:./css/style.css --style compressed"
},
"author": "",
"license": "ISC",
}
```

Une fois le flag ajoutÃ©, cliquez sur _Enregistrer_ pour mettre Ã  jour votre fichier Sass et lancer une recompilation puisque
--watch observe chaque fois que votre code est modifiÃ© :

```scss
.form {
    width: 100%;
    padding-bottom: 1.5rem; }
.form__heading {
    width: 100%;
    color: #fff;
    text-shadow: 0.55rem 0.55rem #11af82;
    background: #15DEA5;
    line-height: 5rem;
    padding: 1.5rem; }
.form__field label {
    color: #D6FFF5;
    display: block;
    font-size: 2rem;
    line-height: 2rem;
    padding-top: 1.5rem; }
.form__field input {
    width: 100%;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    padding: 1.5rem;
    color: #D6FFF5;
    font-weight: 900;
    font-style: italic;
    font-size: 2.75rem; }
.form__field textarea {
    width: 100%;
    color: #15DEA5;
    background: #001534;
    border: 0.1rem solid #15DEA5;
    outline: none;
    padding: 1.5rem;
    margin-bottom: 0.75rem; }
```

Mais ce nâ€™est pas Ã§a quâ€™on voulait. Câ€™est toujours nestÃ©, non, pourquuuuuoi ! ğŸ˜­

Si vous regardez la ligne de commande de plus prÃ¨s, vous pouvez voir notre erreur :

![Image du code qui n'a pas Ã©tÃ© arrÃªtÃ©](https://user.oc-static.com/upload/2019/10/09/15706367044052_image9.jpg)

Le code continue de compiler

Nous nâ€™avons jamais interrompu le script Sass originellement. Il tourne encore ! Et celui-ci avait un mode de compilation bien
diffÃ©rent.

Pour **compiler** en utilisant notre script fraÃ®chement modifiÃ©, il faut dâ€™abord **interrompre** lâ€™ancien script, en appuyant sur
Ctrl+C. Ensuite, relancez-le en tapant Ã Â  nouveau npm run sass :

```shell
npm run sass
```

Notre script Sass fonctionne Ã  nouveau, mais cette fois il inclut le style de compilation que nous voulions :

![Le bon mode de compilation](https://user.oc-static.com/upload/2019/10/09/15706367569307_image8.jpg)

Le bon mode de compilation

Cliquez Ã  nouveau sur Enregistrer et regardez le code compilÃ© :

```scss
.form{width:100%;padding-bottom:1.5rem}.form__heading{width:100%;color:#fff;text-shadow:.55rem .55rem #11af82;background:#15DEA5;line-height:5rem;padding:1.5rem}.form__field label{color:#D6FFF5;display:block;font-size:2rem;line-height:2rem;padding-top:1.5rem}.form__field input{width:100%;background:#001534;border:0.1rem solid #15DEA5;padding:1.5rem;color:#D6FFF5;font-weight:900;font-style:italic;font-size:2.75rem}.form__field textarea{width:100%;color:#15DEA5;background:#001534;border:0.1rem solid #15DEA5;outline:none;padding:1.5rem;margin-bottom:.75rem}
```

Par souci de concision, nous nâ€™avons montrÃ© que le bloc `.form`Â pour chacun des modes de compilation. Lorsque vous compilez, vous
voyez bien sÃ»r lâ€™intÃ©gralitÃ© de votre code CSS.

#### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Installez Sass et compilez le code donnÃ© en exemple en suivant les Ã©tapes vues dans ce chapitre.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/7D8CFDFE009F14291C255CE1DFFF6A2B" width="100%" height="500" frameborder="0"></iframe>


:::info
Et si vous compariez votre travail avec [cette correction](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-3/chapitre-2/exercice-1)Â ?
:::

### Vous avez rÃ©ussi !

Organiser ses fichiers et installer des packages nâ€™est pas lâ€™activitÃ© la plus excitante du monde, mais câ€™est important.
Rappelez-vous que vous passez _beaucoup_ plus de temps Ã  lire votre code quâ€™Ã  lâ€™Ã©crire : plus votre codebase sera propre et bien
organisÃ©e, plus vous serez en mesure de trouver et surtout comprendre des morceaux de code rapidement et facilement.

Continuez comme Ã§a et votre futur vous aura une adoration sans finÂ envers votre vous prÃ©sent.

### En rÃ©sumÃ©

- _package.json_ contient les informations de votre projet.
- La commande `npm init`Â initialise un fichier package.json.
- La commande `npm install sass -g`Â installe Sass sur votre machine et pas seulement votre projet.
- `scripts`Â contient la liste des commandes que vous pouvez exÃ©cuter en lanÃ§ant `npm + le nom du script`.
- Le flag --style permet de prÃ©ciser sous quelle forme sera compilÃ© votre CSS. Vous pouvez choisir entre nested, compressed,
expanded ou compact.    

_Dans les chapitres suivants, on va revenir aux choses plus amusantes : se familiariser avec les types de donnÃ©es avancÃ©es de Sass
et comment les utiliser pour vous faciliter encore un peu plus la vie !_

-----

## IntÃ©grez les types de donnÃ©es Sass

[IntÃ©grez les types de donnÃ©es Sass - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6599971-integrez-les-types-de-donnees-sass)

<Vimeo vimeoId="534814897" />

<br />

Vous vous souvenez lorsque vous appreniez ce quâ€™Ã©taient les variables ? Nous avons survolÃ© les types de donnÃ©es disponibles dans
Sass, et je vous avais dit de ne pas trop vous occuper des listes et des maps, car on les verrait plus en dÃ©tail plus tard... Eh
bien Ã§a y est, nous y voilÃ  : lâ€™heure des **listes** et des **maps** est arrivÃ©e !

### DÃ©couvrez les listes et les maps

Les variables Sass que nous avons vues jusquâ€™Ã  prÃ©sent ne stockent quâ€™une seule valeur : une couleur, une taille, etc. Cela
convient trÃ¨s bien pour de nombreux usages, mais quâ€™en est-il du **padding** ? Vous pouvez assigner quatre valeurs diffÃ©rentes
au sein d'une seule rÃ¨gle :

```scss
.block {
    padding: 1rem 2rem 3rem 4rem;
}
```

CrÃ©er une variable pour chaque cÃ´tÃ© du padding nâ€™aurait aucun intÃ©rÃªt : alerte aux rÃ©pÃ©titions ! ğŸš¨ Et sâ€™il existait une variable
capable de stocker les quatre dimensions ?

```scss
$padding-dimensions: 1rem 2rem 3rem 4rem;
.block {
    padding: $padding-dimensions;
}
```

:::note ?
Une minute ! Ã‡a fonctionne, Ã§a ?
:::

Regardons le CSS compilÃ© :

```scss
.block {
    padding: 1rem 2rem 3rem 4rem;
}
```

Sorcellerie ! ğŸ˜¨

`$padding-dimensions`Â est ce que Sass appelle une **_liste_**, ici une liste de valeurs. Cela vous permet de **regrouper** des
valeurs dans une seule variable. Dans le cas prÃ©sent, nous avons fait une liste des dimensions Ã  utiliser comme valeurs pour une
propriÃ©tÃ© de padding.

Pour crÃ©er une liste, il vous suffit de **dÃ©finir une variable** et de la remplir avec des valeurs. La **syntaxe** pour les
Ã©crire est extrÃªmement flexible. Vous pouvez les sÃ©parer par des espaces, comme nous lâ€™avons fait pour `$padding-dimesions`, ou
utiliser des virgules :

```scss
$syntax-01: 1rem 2rem 3rem 4rem;
$syntax-02: 1rem, 2rem, 3rem, 4rem;
```

Vous pouvez aussi les Ã©crire avec ou sans parenthÃ¨ses, câ€™est comme vous voulez :

```scss
$syntax-01: 1rem 2rem 3rem 4rem;
$syntax-02: 1rem, 2rem, 3rem, 4rem;
$syntax-03: (1rem 2rem 3rem 4rem);
$syntax-04: (1rem, 2rem, 3rem, 4rem);
```

Toutes ces diffÃ©rentes options seront compilÃ©es de la mÃªme maniÃ¨re :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
$syntax-01: 1rem 2rem 3rem 4rem;
$syntax-02: 1rem, 2rem, 3rem, 4rem;
$syntax-03: (1rem 2rem 3rem 4rem);
$syntax-04: (1rem, 2rem, 3rem, 4rem);
.syntax-01 {
    padding: $syntax-01;
}
.syntax-02 {
    padding: $syntax-02;
}
.syntax-03 {
    padding: $syntax-03;
}
.syntax-04 {
    padding: $syntax-04;
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.syntax-01 {
    padding: 1rem 2rem 3rem 4rem;
}
.syntax-02 {
    padding: 1rem, 2rem, 3rem, 4rem;
}
.syntax-03 {
    padding: 1rem, 2rem, 3rem, 4rem;
}
.syntax-04 {
    padding: 1rem 2rem 3rem 4rem;
}




```

</div>
</div>

<br />

Ce nâ€™est pas parce que vous avez dÃ©cidÃ© de stocker un groupe de valeurs dans une liste que vous voulez forcÃ©ment toutes les
utiliser dans la mÃªme instance. Vous pouvez aussi utiliser individuellement les valeurs dâ€™une liste.

CommenÃ§ons par crÃ©er une liste des **diffÃ©rentes tailles de texte** que nous utilisons dans le site :

```scss
$font-size: 7rem 5rem 4rem 2rem;
```

Maintenant, utilisons la valeur **2rem** issue de $font-size pour renseigner la valeur de la taille de texte de nos labels. Pour
accÃ©der aux valeurs individuelles dâ€™une liste, utilisez la fonction `nth()`Â suivie du nom de la liste et lâ€™index de lâ€™Ã©lÃ©ment
souhaitÃ© au sein de la liste :

:::info
Lâ€™index reprÃ©sente lâ€™emplacement dâ€™un Ã©lÃ©ment dans un tableau.
:::

```scss
$font-size: 7rem 5rem 4rem 2rem;
.form{
    &__field {
        & label {
            font-size: nth($font-size, 4);
        }
    }
}
```

On veut utiliser la valeur 2rem situÃ©e dans la liste $font-size pour le label de notre formulaire font-size,Â on appelle donc
nth($font-size, 4). Pourquoi 4 ? 2rem est la quatriÃ¨me valeur dans $font-size.

:::info
Si vous Ãªtes habituÃ© Ã  dâ€™autres langages de programmation, vous Ãªtes peut-Ãªtre un peu perdu avec cet index Ã  4 et non Ã  3, câ€™est
normal : la plupart des autres langages de programmation qui ont des listes commencent avec un index Ã  zÃ©ro ; Sass, lui, commence
Ã  1. Câ€™est Ã©trange, mais au moins vous Ãªtes prÃ©venus !
:::

Les **listes** permettent de **regrouper des ensembles de valeurs**. Mais si vous revenez sur votre code, disons dans quelques
mois, elles peuvent Ãªtre un peu difficiles Ã  lire. Regarder une liste et essayer de se rappeler lâ€™usage de ses Ã©lÃ©mentsÂ peut vous
filer une bonne migraine ou alors vous forcer Ã  scroller dans toute votre codebase. Dans quelques mois, mÃªme dans quelques
minutes, vous aurez probablement oubliÃ© les indices des diffÃ©rentes valeurs de $font-size. Et câ€™est normal, mais il existe une
solution.

### CrÃ©ez des maps

Les listes sont souvent difficiles Ã  lire et Ã  mÃ©moriser parce quâ€™il nâ€™y a pas vraiment de contexte pour lister leur contenu,
câ€™est juste un ensemble de valeurs regroupÃ©es. Câ€™est pour Ã§a quâ€™existent les maps de Sass ! Elles sont trÃ¨s semblables aux listes,
sauf quâ€™elles assignent Ã  chaque valeur un nom sous forme dâ€™une **paire clÃ©/valeur** :

```scss
$font-size: (logo:7rem, heading:5rem, project-heading:4rem, label:2rem);
```

En assignant chaque valeur Ã  une **clÃ©**, ou un nom,Â câ€™est beaucoup plus simple de se souvenir et de comprendre son utilitÃ©. Ici
nous avons assignÃ© la valeur 7rem Ã  la clÃ© logo, 2rem Ã  la clÃ© label, etc. Si câ€™est plus clair, câ€™est plus simple. Si câ€™est plus
simple, câ€™est mieux .ğŸ‘

Pour ceux dâ€™entre vous qui connaissent dâ€™autres langages informatiques, sachez quâ€™en Sass les maps sont lâ€™Ã©quivalents des hashs,
ou objets en JavaScript, mais ne portent juste pas le mÃªme nom.

Les rÃ¨gles sont beaucoup plus strictes pour Ã©crire des maps que pour les listes. Avec les listes, Ã  peu prÃ¨s tout est optionnel
(les parenthÃ¨ses, les virgules...).

Mais le contenu des maps doit Ãªtre **entourÃ© dâ€™une paire de parenthÃ¨ses** et doit **utiliser des virgules pour sÃ©parer les paires
clÃ©/valeur** :

```scss
$map: (
    key-01: value-01,
    key-02: value-02,
    key-03: value-03
);
```

Pour accÃ©der Ã  la valeur dâ€™une map, câ€™est aussi un peu diffÃ©rent. Avec les maps, il faut utiliser la fonction `map-get()`Â ;
celle-ci nÃ©cessite deux **arguments** : le premier est **le nom de la map** (ici _$font-size_), et le second est **le nom de la
clÃ©** (ici _label_).

```scss
$font-size: (logo:7rem, heading:5rem, project-heading:4rem, label:2rem);
.form{
    &__field {
        & label {
            font-size: map-get($font-size, label);
        }
    }
}
```

Le rÃ©sultat final sera toujours 2rem compilÃ© en tant que taille de police dans le CSS :

```css
.form__field label {
    font-size: 2rem;
}
```

Allez, testons un peu nos nouvelles compÃ©tences maps en crÃ©ant une map nommÃ©e $input-txt-palettes, qui contient les palettes de
couleurs pour tous nos inputs de texte. Regroupez les palettes de couleurs par Ã©tat (principale, secondes), puis crÃ©ez une clÃ©
pour chaque pseudoclasse `: active`,Â `focus`Â etÂ `invalid`Â (active, focus, invalide) :

```scss
$colour-primary: #15DEA5;
$colour-secondary: #001534;
$colour-accent: #D6FFF5;
$colour-white: #fff;
$colour-invalid: #DB464B;
$txt-input-palette: (
    active: ,
    focus: ,
    invalid:
);
```

Vous avez crÃ©Ã© des clÃ©s, sauf quâ€™elles sont vides. Souvenez-vous : il sâ€™agit de paires clÃ©/valeurs. Nous avons nos clÃ©s, il nous
faut maintenant leur assigner des valeurs. Pour assigner vos palettes de couleurs Ã  chaque clÃ©, cela nÃ©cessite de **nester** une
autre map pour les couleurs dans chacune des clÃ©s.

:::info
Vous vous souvenez du nesting ? On lâ€™a dÃ©jÃ  vu [ici](https://openclassrooms.com/en/courses/6106181-simplifiez-vous-le-sass-avec-css/6596483-decouvrez-sass-et-sa-syntaxe?status=draft)
avec Sass.
:::

Eh oui, des maps dans les maps ! Inception. ğŸ¤¯

**Vous pouvez assigner nâ€™importe quel type de donnÃ©es Sass comme valeurs dans vos maps (ou listes).**Â Vos inputs de texte doivent
stocker trois couleurs distinctes, du coup chaque clÃ© contiendra elle-mÃªme une clÃ© avec trois valeurs : les couleurs de la
bordure, du fond et du texte :

```scss
$colour-primary: #15DEA5;
$colour-secondary: #001534;
$colour-accent: #D6FFF5;
$colour-white: #fff;
$colour-invalid: #DB464B;
$txt-input-palette: (
    active: (
        bg: $colour-primary,
        border: $colour-primary,
        txt: $colour-white,
    ),
    focus: (
        bg: $colour-primary,
        border: $colour-primary,
        txt: $colour-white,
    ),
    invalid: (
        bg: $colour-invalid,
        border: $colour-white,
        txt: $colour-white,
    )
);
```

Vous avez maintenant une **variable** qui contient toutes les informations de couleurs pour les diffÃ©rents Ã©tats de votre texte
(active, focus, invalid), dans un format qui est **facile Ã  lire** mais surtout **facile Ã  retenir.** Si vous avez besoin de
modifier les Ã©tats ou les valeurs, ils sont tous regroupÃ©s au mÃªme endroit dans un seul bloc : 1000 fois plus simple Ã  retrouver
de cette faÃ§on que de scroller dans toute votre codebase non ?

### Utilisez les mixins avec les maps

Toutes vos couleurs pour les diffÃ©rents Ã©tats de vos input textes sont stockÃ©es dans une variable et elles sont prÃªtes pour la
bataille ! Pour vous faciliter un peu la tÃ¢che, crÃ©ons une **mixin** pour dÃ©ployer ces palettes. Pour cela, vous devez assigner
des rÃ¨gles pour les propriÃ©tÃ©s border,Â background-color et color du texte, avec les bonnes valeurs issues de `$txt-input-palette`.

```scss
@mixin txt-input-palette {
    border: .1rem solid $border;
    background-color: $bg;
    color: $txt;
}

Pour dÃ©clarer de quel Ã©tat (hover, etc.) obtenir les informations, vous devez
assigner un argument pour lâ€™Ã©tat que vous pouvez passer dans la mixin :

@mixin txt-input-palette($state) {
    border: .1rem solid $border;
    background-color: $bg;
    color: $txt;
}
```

Aux cÃ´tÃ©s du nom de lâ€™Ã©tat, vous pouvez stocker sa map de palette dans une variable nommÃ©e `$palette`Â :

```scss
@mixin txt-input-palette($state) {
    $palette: map-get($txt-input-palette, $state);
    border: .1rem solid $border;
    background-color: $bg;
    color: $txt;
}
```

Ã€ prÃ©sent, $paletteÂ contient une map des valeurs de couleurs pour bg,Â borderÂ etÂ txtÂ de lâ€™Ã©tat assignÃ©. Vous pouvez lâ€™utiliser
avec la fonction map-get()Â pour remplir les valeurs de couleur de votre ensemble de rÃ¨gles :

```scss
@mixin txt-input-palette($state) {
    $palette: map-get($txt-input-palette, $state);
    border: .1rem solid map-get($palette, border);
    background-color: map-get($palette, bg);
    color: map-get($palette, txt);
}
```

Et voilÃ  ! Vous avez une mixin utilisable pour mettre en forme tous les **Ã©lÃ©ments de texte** et les **pseudo-sÃ©lecteurs**
simplement en passant lâ€™Ã©tat quand vous appliquez la mixin ! Ceci vous aidera Ã  ce que votre code soit maintenable et facile Ã 
modifier Ã  lâ€™avenir.

Appliquons la mixin Ã  votre sÃ©lecteur par dÃ©faut et inactifÂ `form__txt input`Â :

```scss
@mixin txt-input-palette($state) {
    $palette: map-get($txt-input-palette, $state);
    border: .1rem solid map-get($palette, border);
    background-color: map-get($palette, bg);
    color: map-get($palette, txt);
}
.form {
    &__field {
        & input {
            @include txt-input-palette(focus);
        }
    }
}
```

Maintenant, vous devriez voir dans le CSS compilÃ© le sÃ©lecteur `.form__field input`, rempli avec des rÃ¨gles pour `border`,
`background-color`Â et `color`Â pour le texte :

```scss
.form__field input {
    border: 0.1rem solid #15DEA5;
    background-color: #001534;
    color: #15DEA5;
}
```

Parfait !

#### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Mettez en application vos nouvelles connaissances dans cet exercice oÃ¹ vous devez conserver les couleurs des boutons, tout en adaptant le code avec les listes et les maps.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/8B38C5501F7E9611B283FA25511199FE" width="100%" height="500" frameborder="0"></iframe>

:::info
Retrouvez laÂ [correction de l'exercice ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-3/chapitre-3/exercice-1). ğŸ˜‰
:::

### En rÃ©sumÃ©

- Les listes et les maps sont des collections de valeurs.
- Les listes ont une syntaxe trÃ¨s flexible ; on peut utiliser ou non des virgules, ou rien. Pareil pour les parenthÃ¨ses.
- On accÃ¨de aux valeurs dâ€™une liste en appelant leur index via la fonction `nth()`Â ğŸ‘‰ğŸ¼ `nth($list, index)`.
- En Sass, les indexs des listes commencent Ã  1.
- Les maps sont semblables aux listes, sauf que chaque valeur reÃ§oit un nom quâ€™on appelle une clÃ©Â :Â `$map(key: value)`.
- Les maps ont une syntaxeÂ beaucoup moins permissive que les listes. Les maps doivent utiliser des parenthÃ¨ses et virgules.
- On accÃ¨de aux valeurs dâ€™une map via la fonction `map-get()`Â ğŸ‘‰ğŸ¼Â `map-get($map, key)`.
- Les maps et les listes peuvent contenir nâ€™importe quel type de donnÃ©es Sass, y compris dâ€™autres listes et maps.

_Ã€ prÃ©sent, vous avez une mixin avec laquelle vous pouvez crÃ©er des propriÃ©tÃ©s pour chaque Ã©tat de vos inputs texte ouuuuu vous
pourriez aussi lâ€™automatiser, nâ€™est-ce pas ? Ce serait nettement moins fastidieux, et beaucoup plus classe ! ğŸ˜_

_Quelle coÃ¯ncidence â€“ câ€™est exactement ce que nous ferons dans le prochain chapitre !_

-----

## Utilisez les boucles dans Sass pour fluidifier votre code

[Utilisez les boucles dans Sass pour fluidifier votre code - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6606591-utilisez-les-boucles-dans-sass-pour-fluidifier-votre-code)

<Vimeo vimeoId="534814945" />

<br />

Dans le chapitre prÃ©cÃ©dent, nous avons crÃ©Ã© une mixin qui nous facilite grandement la crÃ©ation de diffÃ©rents modificateurs pour
vos textes :

```scss
$txt-input-palette: (
    active: (
        bg: $colour-primary,
        border: $colour-primary,
        txt: $colour-white,
    ),
    focus: (
        bg: $colour-primary,
        border: $colour-primary,
        txt: $colour-white,
    ),
    invalid: (
        bg: $colour-invalid,
        border: $colour-white,
        txt: $colour-white,
    )
);
@mixin txt-input-palette($state) {
    $palette: map-get($txt-input-palette, $state);
    border: .1rem solid map-get($palette, border);
    background-color: map-get($palette, bg);
    color: map-get($palette, txt);
}
```

Il nous reste encore Ã  crÃ©er le **sÃ©lecteur adaptÃ©** pour chaque Ã©tat et Ã  appliquer la mixin avec le bon argument. Sauf que
câ€™est un travail rÃ©pÃ©titif et fastidieux, exactement ce que Sass nous invite Ã  Ã©viter.

### CrÃ©ez des boucles !

:::note ?
Comment faire ? ğŸ¤”
:::

En programmation, il existe ce quâ€™on appelle des **_boucles_**. Une boucle est une structure qui permet dâ€™exÃ©cuter un certain
nombre de fois une sÃ©rie dâ€™instructions.

:::info
Euh, pardonâ€¦ ? ğŸ˜¨
:::

Prenez une boÃ®te de biscuits. Dans le paquet, il y a 45 dÃ©licieux cookies aux pÃ©pites de chocolat. ğŸª Vous Ãªtes dans la cuisine
et vous avez envie dâ€™un petit cookie, la sÃ©quence suivante dÃ©marre :
- Vous ouvrez le paquet.
- Vous hÃ©sitez sur le fait dâ€™avoir ou non besoin de manger ce cookie.
- Vous dÃ©cidez que non mais bon, vous les avez achetÃ©s, alors autant en manger un, non ?
- Vous mangez un cookie et nagez en plein bonheur.
- Vous vous sentez un peu coupable.
- Vous refermez le paquet et vous dites que câ€™Ã©tait juste un seul cookie..

Ensuite vous rouvrez le paquet. Encore une fois. Et vous recommencez la mÃªme chose, encore et encore, jusquâ€™Ã  ce que vous ayez
mangÃ© tous les cookies du paquet. Certains parleraient de cercle vicieux, personnellement je prÃ©fÃ¨re le terme de **boucle** !
Une boucle pleine de culpabilitÃ© peut-Ãªtre, mais Ã§a reste une boucle. Dans notre cas, la boucle nâ€™est rien dâ€™autre que **la
rÃ©pÃ©tition dâ€™un ensemble dâ€™actions sur notre paquet de cookies**, elle se termine lorsque le paquet est vide. On pourrait la
traduire par : â€œtant quâ€™il y a encore des cookies dans le paquetâ€, je peux effectuer Ã  la suite toutes les actions prÃ©cÃ©dentes.

En appliquant une boucle au sein de votre mixin de texte, Sass peut **automatiquement** crÃ©er les **bons sÃ©lecteurs** et les
**bons ensembles de rÃ¨gles** pour chaque Ã©lÃ©ment de la map que vous lui soumettez. VoilÃ  qui semble bien plus propre et moins
laborieux que de crÃ©er manuellement un bloc pour chacun des diffÃ©rents textes, non ?

Sass met Ã  notre disposition plusieurs types de boucles, mais nous nâ€™en utiliserons quâ€™une : la boucle **@each**. Câ€™est la plus
simple Ã  mettre en place et elle fonctionne trÃ¨s bien avec maps. Puisque tous les types de boucles de Sass nous donneront les
mÃªmes rÃ©sultats Ã  la fin, autant choisir lâ€™option la plus simple.

Quand vous Ã©crivez une boucle @each dans Sass, vous indiquez que pour chaque paire clÃ©/valeur dâ€™une $map vous voulez effectuer
une tÃ¢che, et câ€™est exactement comme Ã§a quâ€™on la dÃ©finit :

```scss
@each $key, $value in $map {
}
```

Câ€™est parti ! On dÃ©finit notre boucle grÃ¢ce au mot clÃ© @each (pour _chaque_...). Puis, on dÃ©clare les Ã©lÃ©ments dont il sâ€™agit :
chaque **$key** et chaque **$value**. Ensuite, on lui dit oÃ¹ aller les chercher. Ce qui nous donne : pour chaque $key et $value
dans cette **$map**.

Sass entre dans $map et crÃ©e des variables temporaires $key et $value pour chaque ensemble clÃ©/valeur quâ€™il trouve. Ces variables
nâ€™existent que dans cette itÃ©ration de la boucle. Elles nâ€™existent ni avant ni aprÃ¨s lâ€™itÃ©ration, et sont invisibles pour le
reste du code.

### Pour chacun et jusquâ€™au dernier

Nous allons utiliser la boucle @each pour crÃ©er tous les ensembles de rÃ¨gles de pseudosÃ©lecteurs pour tous nos Ã©tats
`.form__input label`, et les remplir de leur ensemble de rÃ¨gles dâ€™un seul coup ! Modifions un peu notre mixin `txt-input-palette`
pour quâ€™elle le fasse Ã  notre place.

La premiÃ¨re chose que vous devez faire est de passer toute la map `$txt-input-palette`Â en tant quâ€™argument, plutÃ´t que juste la
clÃ© $state. Votre boucle va itÃ©rer sur chaque clÃ© de la map, il nâ€™y a donc pas besoin de les nommer manuellement :

```scss
@mixin txt-input-palette($palettes) {
    $palette: map-get($txt-input-palette, $state);
    border: .1rem solid map-get($palette, border);
    background-color: map-get($palette, bg);
    color: map-get($palette, txt);
}
```

Vous pouvez aussi supprimer la variable $palette et sa fonctionÂ `map-get()`. La boucle @each ira aussi chercher automatiquement
les valeurs pour chaque clÃ© dans la map :

```scss
@mixin txt-input-palette($palettes) {
    border: .1rem solid map-get($palette, border);
    background-color: map-get($palette, bg);
    color: map-get($palette, txt);
}
```

Ã€ prÃ©sent, vous pouvez commencer Ã  utiliser @each pour automatiser votre travail !

```scss
@mixin txt-input-palette($palettes) {
    @each $state, $palette in $palettes {
        border: .1rem solid map-get($palette, border);
        background-color: map-get($palette, bg);
        color: map-get($palette, txt);
    }
}
```

On regarde ensemble : ici nous avons ajoutÃ© une boucle @each qui va itÃ©rer tout au long de notre map $palettes, tandis que les
variablesÂ $stateÂ et $paletteÂ stockent chacune la clÃ© et la valeur. Ensuite, en itÃ©rant Ã  chaque passage, cela crÃ©e des rÃ¨gles
pour border, background-color, et la colorÂ du texte.

MalgrÃ© les nombreuses itÃ©rations, ils sont tous placÃ©s dans un mÃªme sÃ©lecteur :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
@mixin txt-input-palette($palettes) {
    @each $state, $palette in $palettes {
        border: .1rem solid map-get($palette, border);
        background-color: map-get($palette, bg);
        color: map-get($palette, txt);
    }
}
.form {
    &__field {
        & input {
            @include txt-input-palette($txt-input-palette);
        }
    }
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.form__field input {
    border: 0.1rem solid #15DEA5;
    background-color: #001534;
    color: #15DEA5;
    border: 0.1rem solid #15DEA5;
    background-color: #15DEA5;
    color: #fff;
    border: 0.1rem solid #15DEA5;
    background-color: #15DEA5;
    color: #fff;
    border: 0.1rem solid #fff;
    background-color: #DB464B;
    color: #fff;
}
```

</div>
</div>

<br />

Pas tout Ã  fait ce que nous avions prÃ©vu Ã  la base...

Le but Ã©tait de crÃ©er le sÃ©lecteur pour chaque Ã©tat au fur et Ã  mesure que notre boucle traitait les Ã©lÃ©ments de la map... On va
trouver une solution. ğŸ’ª Nous allons utiliser **lâ€™esperluette** (vous vous en souvenez ? ğŸ˜ƒ) suivie par deux points pour
attribuer le nom de chaque `$state`Â Ã  un pseudosÃ©lecteur :

```scss
@mixin txt-input-palette($palettes) {
    @each $state, $palette in $palettes {
        &:#{$state} {
            border: .1rem solid map-get($palette, border);
            background-color: map-get($palette, bg);
            color: map-get($palette, txt);
        }
    }
}
```

Cet ensemble hashtag/accolade/$variable est tout nouveau, mais pas de panique, il sâ€™agit simplement de la **syntaxe
dâ€™interpolation (#{variable})** de Sass.Â 

:::note ??
Alerte : mot trop compliquÃ©, je veux des explications !
:::

Okay. On peut aussi remplacer syntaxe dâ€™interpolation par _substitution de variable._ Celle-ci nâ€™est pas exclusive Ã  Sass et
existe dans de nombreux langages, comme Ruby par exemple. Elle vous permet dâ€™utiliser la valeur dâ€™une variable au sein dâ€™une
**chaÃ®ne de caractÃ¨res** (ou _string_) et de la remplacer par une autre.

Dans notre cas, elle nous permet de dire que lâ€™on veut utiliser la valeur de la variable `$state`Â en tant que nom de
pseudosÃ©lecteur au lieu de le taper nous-mÃªmes.

Maintenant, quand vous regardez le CSS compilÃ©, vous voyez un pseudosÃ©lecteur pour chaque Ã©tat, avec les bonnes valeurs de
couleurs renseignÃ©es au sein de lâ€™ensemble de rÃ¨gles :

```css
.form__field input:active {
    border: 0.1rem solid #15DEA5;
    background-color: #15DEA5;
    color: #fff;
}
.form__field input:focus {
    border: 0.1rem solid #15DEA5;
    background-color: #15DEA5;
    color: #fff;
}
.form__field input:invalid {
    border: 0.1rem solid #fff;
    background-color: #DB464B;
    color: #fff;
}
```

DÃ©sormais, `txt-input-palette`Â gÃ©nÃ©rera un pseudosÃ©lecteur pour lâ€™Ã©tat **si** cet Ã©tat nâ€™est pas â€œinactifâ€. VÃ©rifions si tout
marche correctement :

```css
.form__field input:active {
    border: 0.1rem solid #15DEA5;
    background-color: #15DEA5;
    color: #fff;
}
.form__field input:focus {
    border: 0.1rem solid #15DEA5;
    background-color: #15DEA5;
    color: #fff;
}
.form__field input:invalid {
    border: 0.1rem solid #fff;
    background-color: #DB464B;
    color: #fff;
}
```

Et voilÃ  ! â˜€ï¸ Maintenant, dÃ¨s que vous changez une valeur de couleur ou une combinaison de palettes, les rÃ¨gles sâ€™appliquant au
texte seront automatiquement modifiÃ©es. Et ce nâ€™est pas tout ! Si vous ajoutez un nouvel Ã©tat dansÂ `$txt-input-palette`, Sass
lâ€™ajoutera Ã  votre CSS compilÃ© tout seul, sans que vous ayez rien Ã  faire. La classe, non ?

Et mÃªme sâ€™il vous prend lâ€™envie dâ€™ajouter 20 palettes de couleur Ã  votre map, ou si vous les supprimiez toutes sauf une, votre
CSS se mettrait Ã  jour tout seul. Pas dâ€™embrouilles, pas de couper/coller/modifier inutiles. Plus de chasse Ã  la coquille dans
un ocÃ©an de code, fini tout Ã§a ! GrÃ¢ce aux boucles, crÃ©er et maintenir votre codebase nâ€™est pas plus compliquÃ© que de modifier
les valeurs dans une map et cliquer sur Enregistrer. Rien de plus simple !

#### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans lâ€™exercice qui suit, crÃ©ez une boucle pour gÃ©nÃ©rer les couleurs des boutons fournis dans lâ€™exercice.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/1111B22F93AEE7DD3876516F292A085B" width="100%" height="500" frameborder="0"></iframe>

:::info
Et si vous compariez votre exercice Ã  [cette correction](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-3/chapitre-4/exercice-1)
pour vÃ©rifier votre travail ?
:::

### En rÃ©sumÃ©

- Une boucle est un ensemble dâ€™actions qui se rÃ©pÃ¨tent.
- On dÃ©finit une boucle Ã  lâ€™aide du mot clÃ© `@each`, suivi de la `$key`, laÂ `$value`, et la `$map` associÃ©es.
- La syntaxe dâ€™interpolation vous permet dâ€™utiliser la valeur dâ€™une variable au sein dâ€™une chaÃ®ne de caractÃ¨res.

_Notre site commence Ã  avoir une bonne tÃªte ! Mais de nos jours, il doit Ãªtre adaptÃ© sur tous types dâ€™Ã©crans, que ce soit un
ordinateur, un smartphone ou une tablette._

_Dans le chapitre suivant, nous allons voir comment Sass peut vous aider Ã  rendre votre site responsive. ğŸ˜_

-----

## Ajoutez des breakpoints pour une mise en page responsive

[Ajoutez des breakpoints pour une mise en page responsive - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6606716-ajoutez-des-breakpoints-pour-une-mise-en-page-responsive)

<Vimeo vimeoId="534815002" />

<br />

Pour le moment, tout a lâ€™air parfait quand on regarde notre page sur un navigateur dâ€™ordinateur :

![Image du portfolio sur desktop](https://user.oc-static.com/upload/2019/10/11/15708063068998_image16.png)

Notre portfolio sur desktop

Mais ce nâ€™est pas aussi beau quand on la regarde sur un appareil mobile !

![Image du portfolio sur mobile](https://user.oc-static.com/upload/2021/04/14/16183930066623_image3-bis.png)

Notre portfolio sur mobile

Oooooops...ğŸ˜¬ Lâ€™affichage nâ€™est pas fou sur mobile, et câ€™est normal car notre page nâ€™est pas encore **responsive**.Â 

La mise en page reste la mÃªme quelle que soit la rÃ©solution de lâ€™Ã©cran, et ce nâ€™est pas ce que nous voulons. Pour que lâ€™affichage
de notre site sâ€™adapte sur nâ€™importe quel support, nous devons mettre en place des **media queries**.

Les media queries indiquent au navigateur dâ€™**utiliser un ensemble de rÃ¨gles alternatif** sous certaines conditions. Par exemple,
si câ€™est pour un Ã©cran ou si câ€™est pour du print, ou si la rÃ©solution du navigateur est celle dâ€™un grand Ã©cran ou dâ€™un petit
tÃ©lÃ©phone portable. Pour exÃ©cuter une media query, on dÃ©ploie la rÃ¨gle CSS **@media**, suivie dâ€™un argumentÂ et dâ€™une paire
dâ€™accolades contenant les ensembles de rÃ¨gles :

```css
@media (max-width: 599px) {
}
```

Cette **media query** signifie que le navigateur appliquera **lâ€™ensemble de rÃ¨gles** que vous mettrez entre les accolades si la
largeur du navigateur est infÃ©rieure Ã  600 pixels.

Les rÃ©solutions que vous indiquez pour vos media queries sont appelÃ©es des **_breakpoints_** : ce sont les **limites** liÃ©es Ã  la
**rÃ©solution de lâ€™Ã©cran** qui font que les ensembles de rÃ¨gles liÃ©s sâ€™appliquent ou non. Pour notre exemple, nous avons crÃ©Ã© une
media query avec un breakpoint qui appliquera les ensembles de rÃ¨gles spÃ©cifiquement adaptÃ©s aux Ã©crans mobiles.

La syntaxe CSS standard pour les media queries consiste Ã  placer un **sÃ©lecteur** et son **ensemble de rÃ¨gles** directement entre
les **accolades** de la query. Lorsque la rÃ©solution de lâ€™Ã©cran correspond au breakpoint, alors le breakpoint prendra le pas sur
lâ€™ensemble de rÃ¨gles par dÃ©faut :

```css
@media (max-width: 599px) {
    .proj-grid {
        grid-template-columns: 1fr;
    }
}
```

Nous avons utilisÃ© le breakpoint pour changer la mise en page de la grille des projets sur notre site, afin quâ€™elle soit adaptÃ©e
sur mobile. Sur la version desktop (pour ordinateur), elle fait trois colonnes de large et peu importe la rÃ©solution de la
fenÃªtre. Mais sur mobile, nous avons mis tous les aperÃ§us de projets **sur une seule colonne**. Au final, cette section est bien
plus lisible sur mobile que sur desktop :

![Image de la version mobile amÃ©liorÃ©e du portfolio](https://user.oc-static.com/upload/2021/04/14/16183931359083_image5-bis.jpg)

Une version mobile amÃ©liorÃ©e

Nous sommes bien partis pour rendre notre site **mobile-friendy** (adaptÃ© sur mobile) ! Et entre nous, cette mode du smartphone
risque de bien durer, donc câ€™est plutÃ´t une bonne chose pour notre site. ğŸ˜‰ Mais devoir placer les sÃ©lecteurs au sein de la media
query signifie quâ€™**ils ne feront pas partie de leurs blocs BEM nestÃ©s**. Ã‡a nous complique la tÃ¢che pour trouver et maintenir
les Ã©lÃ©ments, et Ã§a nous rajoute encoooore du travail dâ€™Ã©criture...

Heureusement, Sass, comme toujours, est lÃ  pour vous sauver la mise et vous faciliter la vie. Ã‡a devient difficile dâ€™imaginer
Ã©crire du CSS sans prÃ©processeur, nâ€™est-ce pas ? ğŸ¤­

#### Mettez en place des media queries

Les media queries CSS standard exigent de placer les sÃ©lecteurs Ã  lâ€™intÃ©rieur de la query, alors que Sass, lui, vous permet de
placer les media queries directement dans les sÃ©lecteurs :

```css
.proj-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    @media (max-width: 599px) {
        grid-template-columns: 1fr;
    }
}
```

PlutÃ´t que de devoir tout sÃ©parer, la media query et ses rÃ¨gles sont **proprement imbriquÃ©es dans leur bloc BEM**Â ; du coup,
bonus pour nous : comme tout est au mÃªme endroit, câ€™est plus simple Ã  trouver et Ã  modifier. Quand Sass compile les media queries,
il vÃ©rifie dans quel sÃ©lecteur elles sont imbriquÃ©es et affiche une media query standard avec le sÃ©lecteur **nestÃ©** dedans :

```css
.proj-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
}
@media (max-width: 599px) {
    .proj-grid {
        grid-template-columns: 1fr;
    }
}
```

Et voilÃ  ! Sass vous aide Ã  gÃ©rer les media queries clÃ©s en main. Essayons Ã  prÃ©sent de passer Ã  la vitesse supÃ©rieure en
intÃ©grant les notions vues prÃ©cÃ©demment dans le cours, pour rendre notre code encore plus simple et maintenable.

#### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans cet exercice,Â  il vous faut passer en responsive la section image du code fourni, en vous basant sur ce que vous venez dâ€™apprendre.

Console de code

<iframe title="codevolve" id="codevolveIframe1" src="https://www.codevolve.com/api/v1/access_token/5DFCE761B8B81B08ACC2718D6DD746EE" width="100%" height="500" frameborder="0"></iframe>

:::info
Retrouvez la [correction de l'exercice ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-3/chapitre-5/exercice-1)
:::

### Utilisez les breakpoints avec Sass

Pour rendre les choses encore plus **maintenables** (oui oui, câ€™est possible), au lieu de dÃ©clarer tous nos breakpoints dans
notre codebase, nous allons crÃ©er une **map** `$breakpoints`Â pour y stocker nos diffÃ©rents breakpoints. Ajoutons-y notre valeur
de breakpoint pour mobile tant quâ€™on y est :

```scss
$breakpoints: (
    mobile: 599px
);
```

Devoir Ã©crire @media screen and (max-width: map-get($breakpoints, mobile) Ã  chaque fois que vous devez utiliser une media query
me semble un peu lassant. Nous allons utiliser une **mixin** Sass pour rÃ©duire toute cette syntaxe superflue et obtenir quelque
chose de plus sÃ©mantique :

```scss
@mixin mobile-only {
    @media screen and (max-width: map-get($breakpoints, mobile)) {
        grid-template-columns: 1fr;
    }
}
```

En nommant la **mixin mobile-only**, vous comprenez tout de suite que les rÃ¨gles quâ€™elle contient **ne sâ€™appliquent quâ€™aux
rÃ©solutions mobile**, sans compter que câ€™est plus facile Ã  retenir et Ã  Ã©crire. Nous avons dÃ©placÃ© la rÃ¨gle grid-template-columns
pour la version mobile du preview de projet dans la mixin.

Branchons Ã  prÃ©sent notre mixin mobile-only dans le `bloc.proj-prev`Â :

```scss
@mixin mobile-only {
    @media screen and (max-width: map-get($breakpoints, mobile)){
        grid-template-columns: 1fr;
    }
}
.proj-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    @include mobile-only;
}
```

VoilÃ  qui est beaucoup plus clair Ã  regarder ! Et quand vous vÃ©rifiez le CSS compilÃ©, vous voyez une media query pour les
rÃ©solutions infÃ©rieures Ã  600px avec un ensemble de rÃ¨gles pour le bloc `.proj-prev`, comme avant :

```css
.proj-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
}
@media screen and (max-width: 599px) {
    .proj-grid {
        grid-template-columns: 1fr;
    }
}
```

Parfait !

Sauf quâ€™on ne peut utiliser la mixin que dans ce cas prÃ©cis. Pour dâ€™autres situations elle est inutile : son ensemble de rÃ¨gles
est spÃ©cifique Ã  la mise en page de la grille du bloc `.proj-prev`, et en plus de Ã§a elle est codÃ©e en dur dans la mixin. Ce qui
signifie que nous devrons **Ã©crire une nouvelle mixin pour chacune de nos media queries**. Entre nous, câ€™est beaucoup trop de
travail inutile. Peut-Ãªtre que Sass nâ€™est pas si gÃ©nial, aprÃ¨s toutâ€¦

ğŸ˜ Je vous fais marcher, bien sÃ»r que Sass a une bien meilleure faÃ§on de sâ€™y prendre, voyons !

#### Utilisez la directive @content

PlutÃ´t que de devoir coder en dur le contenu dâ€™une mixin, Sass vous offre la possibilitÃ© de dÃ©ployer la directive **@content**.

```scss
@mixin mobile-only {
    @media screen and (max-width: map-get($breakpoints, mobile)) {
        @content;
    }
}
```

Quand Sass compile les instances de la mixin, il remplace @content par le code que vous aurez placÃ© Ã  lâ€™intÃ©rieur de lâ€™instance
de la mixin.


:::note ?
Et comment on sâ€™y prend, au juste, pour ajouter du contenu dans une instance de mixin ? ğŸ¤”
:::

Lorsque vous utilisez la directive @content, vous pouvez ajouter une paire dâ€™accolades aux instances de la mixin pour y mettre
votre contenu :

```scss
@mixin mobile-only {
    @media screen and (max-width: map-get($breakpoints, mobile)) {
        @content;
    }
}
.proj-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    @include mobile-only {
        grid-template-columns: 1fr;
    }
}
```

DÃ©sormais, Sass remplacera @content parÂ `grid-template-columns: 1fr`Â quand il compile le code :

```css
.proj-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
}
@media screen and (max-width: 599px) {
    .proj-grid {
        grid-template-columns: 1fr;
    }
}
```

En rÃ©alitÃ©, @content est un placeholder pour du code qui **sera remplacÃ© au moment de la compilation, instance par instance**.
En lâ€™appliquant, nous avons crÃ©Ã© une mixin trÃ¨s flexible et simple Ã  la fois pour nos media queries.

Nous pouvons maintenant utiliser notre mixin mobile-only dans tout notre site pour lâ€™adapter aux appareils mobiles. Utilisons-la
pour ajuster la font-size du bloc .quote, tant quâ€™on y est :

<div style={{display: 'flex', flexDirection: 'row', justifyContent: 'space-between', padding: '12px', backgroundColor: 'gray', border: '1px solid black', borderRadius:'12px'}}>
<div style={{width:'49%'}}>

```scss title="scss"
$font-size: (
    logo: 7rem,
    quote: 6rem,
    heading: 5rem,
    project-heading: 4rem,
    label: 2rem
);
.quote {
    font-size: map-get($font-size, quote);
    @include mobile-only {
        font-size: map-get($font-size, quote)\*0.4;
    }
}
```

</div>
<div style={{width:'49%'}}>

```css title="css"
.quote {
    font-size: 6rem;
}
@media screen and (max-width: 599px) {
    .quote {
        font-size: 2.4rem;
    }
}





```

</div>
</div>

<br />

Sass nous fournit les outils pour crÃ©er des sites web **responsive** et **graphiquement cohÃ©rents** avec du CSS propre et
maintenable, tout en rÃ©duisant drastiquement les quantitÃ©s de code fastidieux et rÃ©pÃ©titif Ã  Ã©crire.

#### Essayez par vous-mÃªme !

**![16183911506509_A-vous-de-jouer%20%282%29.png](https://user.oc-static.com/upload/2021/04/14/16183911506509_A-vous-de-jouer%20%282%29.png)**

Dans lâ€™exercice prÃ©cÃ©dent, vous avez rendu responsive le bloc image ; il est temps de faire de mÃªme avec le bloc article !

Console de code

<iframe title="codevolve" id="codevolveIframe2" src="https://www.codevolve.com/api/v1/access_token/EC12BFCE9E9F0B0AFE5E79CA0E65539B" width="100%" height="500" frameborder="0"></iframe>

Retrouvez [la correction de l'exercice ici](https://github.com/tdimnet/Simplifiez-vous-le-CSS-avec-Sass/tree/partie-3/chapitre-5/exercice-2) !

### En rÃ©sumÃ©

- Les media queries vous permettent dâ€™adapter votre contenu Ã  diffÃ©rents Ã©crans, en disant au navigateur dâ€™utiliser un ensemble
de rÃ¨gles alternatives dans certaines circonstances.
- Pour exÃ©cuter une media query, on dÃ©ploie la rÃ¨gle CSS `@media`, suivie de la liste des queries et dâ€™une paire dâ€™accolades
contenant les ensemble de rÃ¨gles alternatives requises.
- Les breakpoints sont les rÃ©solutions que vous utilisez pour les media queries.
- Dans Sass, vous pouvez placer des media queries dans des sÃ©lecteurs, ce qui vous permet de les imbriquer dans le bon bloc BEM.
- On utilise `@content`Â en tant que placeholder pour des media queries spÃ©cifiques.

_Dans le prochain chapitre, nous mettrons la cerise sur le gÃ¢teau en ajoutant automatiquement des prÃ©fixes Ã  notre CSS compilÃ©,
ce qui nous garantira que notre site sâ€™affiche correctement sur tous les principaux navigateurs. Cool, non ?_

-----

## Utilisez Autoprefixer pour crÃ©er du code adaptÃ© Ã  tous les navigateurs

[Utilisez Autoprefixer pour crÃ©er du code adaptÃ© Ã  tous les navigateurs - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6612156-utilisez-autoprefixer-pour-creer-du-code-adapte-a-tous-les-navigateurs)

<Vimeo vimeoId="534815049" />

<br />

Notre site a lâ€™air parfait sur votre navigateur, mais pas nÃ©cessairement sur celui des autres. Nous lâ€™avons dÃ©veloppÃ© en
utilisant Chrome, mais dâ€™autres utilisateurs peuvent trÃ¨s bien utiliser Firefox, Operaâ€¦ ou _Internet Explorer_ (aaaaaahhh). ğŸ˜±

:::note ?
Et alorsâ€¦ câ€™est pas pareil pour tout le monde ? Câ€™est juste une histoire de prÃ©fÃ©rence, non ? ğŸ™„
:::

### Explorez les diffÃ©rents affichages par navigateurs

Eh bien non, il sâ€™avÃ¨re que **certaines propriÃ©tÃ©s CSS sâ€™afficheront diffÃ©remment selon les navigateurs**, sauf que vous voulez
vous assurer que le rendu soit le mÃªme pour tous les visiteurs de votre site, peu importe leur navigateur. Pour les propriÃ©tÃ©s
anciennes et bien connues telles que border ou margin, pas besoin de sâ€™inquiÃ©ter : elles sont standardisÃ©es et fonctionnent sur
tous les navigateurs. Mais ce nâ€™est pas le cas pour certaines propriÃ©tÃ©s plus rÃ©centes, telles que grid ou flexbox.

:::info
Flexbox permet de disposer, aligner et distribuer l'espace entre les items d'un container, mÃªme lorsque leurs dimensions sont
inconnues et/ou dynamiques â€“ d'oÃ¹ le terme "flex".
:::

Les Ã©quipes qui conÃ§oivent vos navigateurs, tels que Google et Mozilla, nâ€™attendent pas que les nouveaux outils plutÃ´t cool
soient **standardisÃ©s** pour pouvoir les intÃ©grer. Au lieu de Ã§a, ils crÃ©ent leur **propre version**, en ajoutant un **prÃ©fixe**
pour la distinguer des autres navigateurs. Bien sÃ»r, un jour ou lâ€™autre, la nouvelle propriÃ©tÃ© sera standardisÃ©e et fonctionnera
pour tous les navigateurs, supprimant le besoin dâ€™utiliser des prÃ©fixes. Mais en attendant, il vous faudra utiliser des prÃ©fixes
dans votre code.

Quand vous utilisez flexbox, au lieu de simplement dÃ©finir la propriÃ©tÃ© display comme Ã©tant flex, vous devez lister touuuuuus les
**prÃ©fixes** :

```css
.header {
    display: -webkit-box;
    display: -moz-box;
    display: -ms-flexbox;
    display: flex;
}
```

:::info
_webkit_ est pour Chrome et Safari, _ms_ pour Microsoft, _moz_ pour Firefox.
:::

DÃ©sormais, notre header sâ€™affichera uniformÃ©ment sous Chrome, Safari, Mozilla, Opera et Microsoft Edge ! Je sais, ce nâ€™Ã©tait pas
du tout au programme jusquâ€™ici et nous avons Ã©crit Ã©normÃ©ment de code. Et maintenant, il va falloir aller tout modifier pour que
notre code tout entier soit adaptÃ© sur tous les supports, quel boulot !

:::note ?
Noooon ! Je refuuuuseeee ! **ğŸ˜­**
:::

Pas de panique, clairement personne nâ€™en a envie. Ajouter des prÃ©fixes est ennuyeux et ils changent tout le temps : puisque les
standards Ã©voluent en permanence, vous allez devoir les vÃ©rifier Ã  chaque fois que vous Ã©crivez du CSS pour Ãªtre sÃ»r que votre
code est bien compatible. Mmmh barbant.

â€œ**Autoprefixer**â€ est un plugin qui vous sauvera desÂ `-webkit-`Â et des `-moz-`. Il fait exactement ce que son nom indique : il
ajoute automatiquement des prÃ©fixes dans votre CSS. Il vous suffit de lui fournir une feuille CSS et il la passera en revue pour
y ajouter les prÃ©fixes lÃ  oÃ¹ il faut.

### Installez Autoprefixer

Alors, comment fait-on pour faire marcher ce plugin salvateur ? Ouvrez le terminal dans VS Code et utilisez **npm** pour
installer **Autoprefixer**, **PsstCSS**Â et **PostCSS-CLI**.

:::info
**PostCSS-CLI** est un outil de ligne de commande que vous utiliserez pour faire tourner Autoprefixer.
:::

La marche Ã  suivre est Ã  peu prÃ¨s la mÃªme que pour installer Sass, sauf que vous installez trois packages dâ€™un coup. Pour
installer plusieurs packages en mÃªme temps, il vous suffit de les sÃ©parer par des espaces :

```shell
npm install autoprefixer postcss postcss-cli -g
```

Une fois que npm a tÃ©lÃ©chargÃ© et installÃ© les packages, retournez dans package.jsonÂ et ajoutez un nouveau script Ã  exÃ©cuter pour
npm, comme lorsque vous avez installÃ© Sass. AprÃ¨s votre script â€œsassâ€, vous allez ajouter un nouveau script nommÃ© â€œprefixâ€.

```json
{
"name": "joeblow",
"version": "1.0.0",
"description": "Joe Blow's web portfolio",
"main": "index.js",
"scripts": {
    "sass": "sass ./sass/main.scss:./public/css/style.css -w --style compressed",
    "prefix":
},
"author": "",
"license": "ISC",
}
```

Et dans ce script, vous devez dire Ã  npm dâ€™utiliser le nouveau package `postcss`Â que vous venez dâ€™installer, et nâ€™oubliez pas de
lui dire oÃ¹ trouver votre fichier CSS compilÃ© :

```json
{
"name": "joeblow",
"version": "1.0.0",
"description": "Joe Blow's web portfolio",
"main": "index.js",
"scripts": {
    "sass": "sass ./sass/main.scss:./public/css/style.css -w --style compressed",
    "prefix": "postcss ./public/css/style.css"
},
"author": "",
"license": "ISC",
}
```

Une fois que vous avez dit Ã  npm quel package utiliser et oÃ¹ trouver votre fichier CSS, vous devez dire au package `postcss`
dâ€™utiliser Autoprefixer en exÃ©cutant le `flag --use`Â suivi dâ€™_autoprefixer_ :

```json
{
"name": "joeblow",
"version": "1.0.0",
"description": "Joe Blow's web portfolio",
"main": "index.js",
"scripts": {
    "sass": "sass ./sass/main.scss:./public/css/style.css -w --style compressed",
    "prefix": "postcss ./public/css/style.css --use autoprefixer"
},
"author": "",
"license": "ISC",
}
```

Hop et derniÃ¨re Ã©tape : vous devez lui dire oÃ¹ mettre votre nouvelle feuille CSS prÃ©fixÃ©e :


```json
{
"name": "joeblow",
"version": "1.0.0",
"description": "Joe Blow's web portfolio",
"main": "index.js",
"scripts": {
    "sass": "sass ./sass/main.scss:./public/css/style.css -w --style compressed",
    "prefix": "postcss ./public/css/style.css --use autoprefixer -d ./public/css/prefixed/"
},
"author": "",
"license": "ISC",
}
```

Et voilÃ , votre script de prÃ©fixage est terminÃ© ! Tout ce quâ€™il reste Ã  faire, câ€™est dire Ã  Autoprefixer jusquâ€™Ã  quand il doit
remonter pour assurer votre compatibilitÃ© avec tous les browsers.

:::note
Comment Ã§a jusquâ€™Ã  quand ? Tu veux dire une date ? ğŸ¤”
:::

Par dÃ©faut, Autoprefixer **nâ€™ira vÃ©rifier que la prÃ©cÃ©dente version** des principaux navigateurs pour conclure quels prÃ©fixes il
doit ajouter Ã  vos feuilles CSS. Mais vous voulez Ãªtre sÃ»r que les internautes utilisant des versions de browsers un peu
**plus anciennes** soient Ã©galement pris en compte. On va donc indiquer Ã  Autoprefixer de regarder les quatre derniÃ¨res versions
des navigateurs lorsquâ€™il vÃ©rifie la compatibilitÃ© de vos feuilles CSS. Juste aprÃ¨s nos scripts, ajoutons donc une nouvelle clÃ©
nommÃ©e `browserslist`Â (liste des navigateurs) :

```json
{
"name": "joeblow",
"version": "1.0.0",
"description": "Joe Blow's web portfolio",
"main": "index.js",
"scripts": {
    "sass": "sass ./sass/main.scss:./public/css/style.css -w --style compressed",
    "prefix": "postcss ./public/css/style.css --use autoprefixer -d ./public/css/prefixed/"
},
"author": "",
"license": "ISC",
"browserslist":
}
```

Et donnons Ã  browserslist la valeur deÂ `last 4 versions`Â :

```json
{
"name": "joeblow",
"version": "1.0.0",
"description": "Joe Blow's web portfolio",
"main": "index.js",
"scripts": {
    "sass": "sass ./sass/main.scss:./public/css/style.css -w --style compressed",
    "prefix": "postcss ./public/css/style.css --use autoprefixer -d./public/css/prefixed/"
},
"author": "",
"license": "ISC",
"browserslist": "last 4 versions"
}
```

Vous venez de dire Ã  Autoprefixer de remonter et de prendre en compte jusquâ€™Ã  4 versions avant celle dâ€™aujourdâ€™hui.

Ã‡a y est, vous Ãªtes maintenant prÃªt Ã  autoprÃ©fixer votre CSS ! ğŸ¤˜

### Lancez Autoprefixer

Allons dans le terminal et lanÃ§ons le script prefix :

```shell
npm run prefix
```

Le script apparaÃ®t dans la ligne de commande et, un instant plus tard, câ€™est terminÃ© (tellement rapide) !

![Image illustrant l'exÃ©cution rapide du script](https://user.oc-static.com/upload/2019/10/14/15710402787877_image17.jpg)

ExÃ©cution du script

Regardez le nouveau CSS prÃ©fixÃ© et vÃ©rifiez le bloc .header :


```css
.header {
    background: #15DEA5;
    height: 10rem;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
    -ms-flex-wrap: wrap;
    flex-wrap: wrap;
    width: 100%;
}
```

Notre site web sâ€™affichera dÃ©sormais proprement et uniformÃ©ment sur tous les navigateurs **compatibles**.

:::info
Notez le mot â€œcompatible.â€ Flexbox, par exemple, nâ€™est pas supportÃ© sur Internet Explorer 9Â ni sur les versions prÃ©cÃ©dentes.
Ajouter un prÃ©fixe nâ€™y changera rien. **Les prÃ©fixes garantissent que les diffÃ©rentes implÃ©mentations dâ€™une mÃªme propriÃ©tÃ© seront
appelÃ©es dans leurs navigateurs respectifs**. Si pour une raison obscure vous avez besoin que votre site soit adaptÃ© sur IE8 (ğŸ˜¬),
il vous faudra utiliser dâ€™autres propriÃ©tÃ©s pour votre mise en page...
:::

Notre site web est prÃªt pour le grand public ! Il est responsive et compatible. Et grÃ¢ce Ã  Sass, le maintenir Ã  lâ€™avenir sera
tellement plus simple ! ğŸ™Œ

### Bonus : utiliser des boucles et maps pour crÃ©er des modificateurs

Vous savez comment Ã§a marche : la clÃ© de la rÃ©ussite, câ€™est la pratique ! ğŸ˜‰

Lâ€™exercice suivant est totalement facultatif, mais câ€™est un trÃ¨s bon entraÃ®nement pour crÃ©er des maps et les utiliser avec des
boucles @each, qui peuvent vous faire gagner du temps et rendre votre code encooore plus maintenable (vers lâ€™infini et au delÃ  !)

Voici le challenge : automatiser la crÃ©ation de modificateurs qui changent la couleur du texte deÂ .article__headlineÂ pour les
valeurs de couleurs suivantes :
1. #cc8624 (orange).
2. #cc2475 (rose).
3. #2469cc (bleu).
4. #24cc24 (vert).

Mettez les valeurs dans une map en attribuant une clÃ© Ã  chacune, puis utilisez une boucle @each pour gÃ©nÃ©rer des sÃ©lecteurs ayant
la structure suivante :

```css
.article__heading-- /*colour name goes here*/ {
    color: /*colour values goes here*/;
}
```

:::info
Si vous Ãªtes encore un peu mal Ã  lâ€™aise avec les maps, vous pouvez aller rÃ©viser dans les chapitres prÃ©cÃ©dents ! ğŸ˜€
:::

### En rÃ©sumÃ©

- Certaines propriÃ©tÃ©s CSS nÃ©cessitent ce quâ€™on appelle des _prÃ©fixes_ et sâ€™afficheront diffÃ©remment sur diffÃ©rents navigateurs.
- Utilisez le plugin Autoprefixer pour ajouter automatiquement des prÃ©fixes dans votre CSS.
- Installez Autoprefixer en utilisant la ligne de commande, et faites bien attention dâ€™indiquer combien de versions anciennes
vous voulez couvrir !

_Nous arrivons Ã  la fin de ce cours. FÃ©licitation ! Encore unÂ petitÂ effort : je vous ai prÃ©parÃ© un rÃ©sumÃ© du cours, au chapitre
suivant !_

-----

## RÃ©sumÃ© du cours

[RÃ©sumÃ© du cours - Simplifiez-vous le CSS avec Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/6612666-resume-du-cours)

<Vimeo vimeoId="534815121" />

<br />

### Mission accomplie ! ğŸ‘ğŸ‘ğŸ‘

Vous avez rÃ©ussi ! FÃ©licitations ! ğŸ‰ Vous avez montÃ© dâ€™un cran vos compÃ©tences en CSS, appris Ã  utiliser des outils performants
tels que Sass pour amÃ©liorer votre code et acquis de solides bases de dÃ©veloppeur par-dessus le marchÃ© ! Je sais que nous avons
vu beaucoup de choses, que câ€™est un sacrÃ© paquet dâ€™informations Ã  ingÃ©rer et que vous avez pu vous sentir submergÃ© par moments,
mais vous avez tenu bon ! Et par-dessus tout, vous avez acquis de solides compÃ©tences qui vous seront utiles tout au long de
votre carriÃ¨re.

ğŸ˜¢ Trop dâ€™Ã©motions, je ne dois pas pleurerâ€¦Â ***disparaÃ®t sous sa cape dâ€™invisibilitÃ©***

Allez, on se reprend. Ã€ prÃ©sent tout ce quâ€™il vous reste Ã  faire, câ€™est de mettre vos nouvelles compÃ©tences en application :
tout dâ€™abord en faisant le quiz de fin de section, puis en continuant Ã  amÃ©liorer et personnaliser votre site portfolio âœ¨.

Je vous laisse quelques sites utiles juste en dessous ğŸ‘‡ğŸ¼ :
- Codepen ([https://codepen.io/](https://codepen.io/pen/))
- Documentation de Sass ([https://sass-lang.com/documentation](https://sass-lang.com/documentation))
- MDN CSS ([https://developer.mozilla.org/fr/docs/Web/CSS](https://developer.mozilla.org/fr/docs/Web/CSS))

Vous avez maintenant les connaissances nÃ©cessaires pour :
- identifier comment utiliser les sÃ©lecteurs BEM et les prÃ©processeurs CSS pour structurer votre code ;
- expliquer la syntaxe Sass et les conventions (notamment pour les sÃ©lecteurs, les modificateurs et les extensions) ;
- appliquer les variables, mixins, extensions et fonctions Sass pour amÃ©liorer une codebase ;
- identifier les techniques Sass avancÃ©es pour crÃ©er un site web responsive et compatible avec tous les browsers ;
- possÃ©der des bases en programmation dans divers sujets comme les loops, listes, maps et les fonctions !

Jâ€™aimerais beaucoup vous souhaiter bonne chance pour vos futurs projets... mais entre nousâ€¦ je sais que vous nâ€™en aurez pas
besoin. Vous allez tout dÃ©chirer ! ğŸ˜‰

-----

## Quiz : Optimisez votre code en utilisant les techniques avancÃ©es de Sass

[Optimisez votre code en utilisant les techniques avancÃ©es de Sass - OpenClassrooms](https://openclassrooms.com/fr/courses/6106181-simplifiez-vous-le-css-avec-sass/exercises/3707)

#### CompÃ©tences Ã©valuÃ©es

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Optimiser son code en utilisant les techniques avancÃ©es de Sass

-----

#### Description

Bienvenue dans ce quiz ! Il s'agit du dernier pour valider ce cours.

Bonne chance !

-----

#### Question 1 : Parmi les directories suivants, lequel ne fait pas partie du pattern 7-1 ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Base<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> _variables.scss<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Themes<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Utils<br />
<br />

*Les sept noms de directories du pattern 7-1 sont les suivants :*
- Base
- Utils
- Layout
- Components
- Pages
- Themes
- Vendors

*_variables.scss est le nom dâ€™un partiel Sass, qui peut Ãªtre importÃ© dans le fichier main.scss. Il doit Ãªtre placÃ© dans le
directory Utils.*

-----

#### Question 2 : Dâ€™aprÃ¨s la structure de fichiers suivante, quelle proposition est correctement formatÃ©e pour importer le partiel `_variables.scss`Â dans main.scss ?

![Image montrant la structure du fichier](https://user.oc-static.com/upload/2019/10/14/15710584610645_image17.png)

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```css
@import "./utils/variables"
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```css
@import "variables"
```
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```css
@import ./utils/variables
```
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```css
import "./utils/variables"
```

*Pour importer le partiel des variables, vous devez taper @import suivi dâ€™une paire de guillemets. Entre les guillemets, tapez
le chemin vers votre partiel : â€œ./utils/variablesâ€. Le point au dÃ©but du chemin indique Ã  Sass que le chemin du partiel commence
dans le mÃªme directory que main.scss.*

*Ensuite, /utils/ mÃ¨ne Sass au directory Utils, oÃ¹ il trouvera le partiel de variables.*

*Quand vous tapez le nom du partiel, nâ€™utilisez pas dâ€™underscore ni dâ€™extension de fichier. Sass sait quâ€™il doit trouver un
fichier commenÃ§ant par un underscore et quâ€™il sâ€™agira dâ€™un fichier Sass.*

-----

#### Question 3 : Laquelle des propositions suivantes est une map Sass correctement formatÃ©e ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
$map: (key1,$value1,key2,$value2,key3,$value3
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
$map: (key1: value1, key2: value2, key3: value3)
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
$map: value1, value2, value3
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>
```scss
$map: $value1 $value2 $value
```

*Les maps Sass doivent contenir des paires clÃ©/valeur. Pour assigner une valeur Ã  une clÃ© : indiquez la clÃ©, ajoutez les deux
points, puis renseignez la valeur. comme suit :Â `clÃ©: valeur`.*

*Chaque paire clÃ©/valeur doit Ãªtre sÃ©parÃ©e par des virgules et elles doivent toutes se trouver entre des parenthÃ¨ses.*

-----

#### Question 4 : Parmi les propositions suivantes, lesquelles sont des listes Sass correctement formatÃ©es ?

*Attention, plusieurs rÃ©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
$list: $value1, $value2, $value3
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
$list: ($value1, $value2, $value3)
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
$list: $value1 $value2 $value3
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
$list: $value1$value2$value3
```

*La syntaxe pour Ã©crire des listes est trÃ¨s flexible. Vous pouvez les mettre ou non entre parenthÃ¨ses. En revanche, vous devez
sÃ©parer les valeurs par des espaces ou des virgules. La rÃ©ponse 4 nâ€™est pas correctement formatÃ©e, puisque les valeurs ne sont
pas sÃ©parÃ©es les unes des autres.*

-----

#### Question 5 : Ã€ partir de cette liste Sass, lequel des bouts de code suivants retournera une valeur de 3 rem ?

```scss
$list: 1rem, 2rem, 3rem, 4rem;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
nth($list, 2)
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
nth($list, 3)
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
$map-get($list, 2)
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
nth(3, $list)
```

*Pour accÃ©der aux diffÃ©rentes valeurs dâ€™une liste Sass, appelez la fonction nth() avec deux arguments :*
1. *Le premier argument est le nom de la liste Ã  laquelle vous voulez accÃ©der.*
2. *Le second argument est lâ€™index de la valeur que vous voulez retourner, le premier item de la liste a un index de 1.*

*Dans le cas de la liste indiquÃ©e dans la question, le nom de la liste est $list et 3rem a un index de 3, donc pour retourner la
valeur de 3rem Ã  partir de la liste, il faut appeler la fonction nth() suivante :*

```scss
nth($list, 3);
```

#### Question 6

```scss
$map: (
    pink: #f442f1,
    mint: #15dea5,
);
@each $key, $value in $map {
    .btn--#{$key} {
        background-color: $value;
    }
}
```

**En partant du code ci-dessus, lesquels de ces sÃ©lecteurs seront gÃ©nÃ©rÃ©s par la boucle `@each`Â ?**

*Attention, plusieurs rÃ©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
.btn--pink {
    background-color: #f442f1;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
.btn--mint {
    background-color: #15dea5;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
.btn .pink {
    background-color: #f442f1;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
.mint {
    background-color: #15dea5;
}
```

*La boucle @each va gÃ©nÃ©rer un sÃ©lecteur avec le prÃ©fixe `.btn--`Â suivi du nom de chaque clÃ© dans $map. Elle crÃ©era une propriÃ©tÃ©
background-color avec la couleur correspondant Ã  la valeur de cette clÃ© dans chaque sÃ©lecteur.*

-----

#### Question 7

```scss
$font-sizes: (
    heading: 3rem,
    byline: 1.75rem,
    caption: 1rem
);
```

**En vous basant sur la map Sass ci-dessus, lequel de ces bouts de code retournerait la valeur de la clÃ© `byline`Â ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
.article__byline {
    font-size: map-get($font-sizes, byline);
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.article__byline {
    font-size: map-get(byline, $font-sizes);
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.article__byline {
    font-size: nth($font-sizes), byline);
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.article__byline {
    font-size: map-get($font-sizes, 2);
}
```

*Pour accÃ©der Ã  une valeur situÃ©e dans une map, on utilise la fonction `map-get()`Â qui prend deux arguments : le premier est le
nom de la map (ici `$font-sizes`), le second le nom de la clÃ© de la valeur que vous voulez obtenir (ici `byline`).*

*Pour accÃ©der Ã  byline via `map-get()`, utilisez `$font-sizes`Â comme premier argument et `byline`Â comme second :*

```scss
.article__byline {
    font-size: map-get($font-sizes, byline);
}
```

-----

#### Question 8

```scss
@mixin mobile-only {
    @media screen and (max-width: 599px) {
        @content;
    }
}
.block {
    margin: 1.5rem;
    @include mobile-only {
        margin: .5rem;
    }
}
```

**En partant du code ci-dessus, quelle sera le margin de `.block`Â si la largeur du navigateur est de 480 px ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> .5 rem<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 2 rem<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 1.5 rem<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 0<br />
<br />

*La mixin `mobile-only`Â contient une media query pour un Ã©cran dâ€™une largeur maximale de **599Â px**.*
   
***Si** lâ€™Ã©cran a une largeur de 599 px ou moins,Â **alors** le navigateur appliquera les rÃ¨gles contenues dans la media query,
que nous pouvons rÃ©gler pour chaque usage grÃ¢ce Ã  la directiveÂ `@content`.*
    
*Ã‰tant donnÃ© que la largeur du navigateur est de 480 px, celui-ci appliquera lâ€™ensemble de rÃ¨gles que nous avons Ã©crit quand
nous avons inclus la mixin `mobile-only`Â dans `.block`, donc une marge de .5rem.*

-----

#### Question 9

```scss
$map: (
    small: 1rem,
    medium: 5rem,
    large: 10rem
);
@each $size, $measurement in $map {
    .btn--#{$mesurement} {
        font-size: $size;
    }
}
```

**Le code que vous avez ci-dessus, lorsqu'il est compilÃ© nous donne ce rÃ©sultat :**

```css
.btn--1rem {
    font-size: small;
}
.btn--5rem {
    font-size: medium;
}
.btn--10rem {
    font-size: large;
}
```

**Le souci, câ€™est que le rÃ©sultat est tout emmÃªlÃ© : il semblerait que des valeurs aient Ã©tÃ© mal placÃ©es. Le code attendu Ã©tait
celui-ci :**

```css
.btn--small {
    font-size: 1rem;
}
.btn--medium {
    font-size: 5rem;
}
.btn--large {
    font-size: 10rem;
}
```

**Parmi les solutions suivantes, laquelle vous permet dâ€™obtenir le rÃ©sultat attendu ci-dessus ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
@each $size, $measurement in $map {
    .btn--$size {
        font-size: $measurement;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
@each $size, $measurement in $map {
    .btn--#{$map($size)} {
        font-size: $measurement;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
@each $size, $measurement in $map {
    .btn--#{$size} {
        font-size: $measurement;
    }
}
```

*Nous avons une map Sass avec trois paires clÃ©/valeur et nousÂ voulons produire trois sÃ©lecteurs dont :*
1. *Le nom du sÃ©lecteur comprend la clÃ© sous forme de string.*
2. *La valeur sera stockÃ©e dans une propriÃ©tÃ© de ce sÃ©lecteur.*

*Dans le rÃ©sultat de notre premiÃ¨re boucle, tout est inversÃ© : la valeur se retrouve dans le nom du sÃ©lecteur et la clÃ© dans la
propriÃ©tÃ© !*

```css
.btn--1rem {
    font-size: small;
}
.btn--5rem {
    font-size: medium;
}
.btn--10rem {
    font-size: large;
}
```

*Pour y remÃ©dier, il vous faut utiliser `$size`Â dans le nom du sÃ©lecteur.*

*Pour lâ€™utiliser sous forme de chaÃ®ne de caractÃ¨res, vous devez utiliser la syntaxe dâ€™interpolation : câ€™est-Ã -dire lâ€™accompagner
dâ€™un hashtag et dâ€™accolades :*

```scss
#{$size}
```

*Ensuite, utilisez la valeur de cette clÃ© pour dÃ©finir la taille de texte du sÃ©lecteur :*

```scss
@each $size, $measurement in $map {
    // incluez le nom de la clÃ© dans le sÃ©lecteur
    .btn--#{$size} {
        // utilisez la valeur de la clÃ©
        font-size: $measurement;
    }
}
```

#### Question 10 : Autoprefixer crÃ©e du CSS compatible avec tous les navigateurs enâ€¦

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> supprimant tout le code non compatible.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> plaÃ§ant le code non compatible dans un fichier Ã  part.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> ajoutant automatiquement dans votre CSS les prÃ©fixes nÃ©cessaires.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> alertant lâ€™utilisateur quâ€™il doit mettre Ã  jour son browser.<br />
<br />

*Les constructeurs des navigateurs nâ€™ont pas nÃ©cessairement envie dâ€™attendre que les nouvelles propriÃ©tÃ©sÂ CSS soient standardisÃ©es
pour pouvoir les mettre en application dans leur navigateur.*

*Du coup, en attendant quâ€™elles le soient, chaque navigateur a sa propre version de ces propriÃ©tÃ©s, qui sont identifiables grÃ¢ce
Ã  des prÃ©fixes spÃ©cifiques.*

*PlutÃ´t que de devoir renseigner tous les prÃ©fixes manuellement, vous pouvez utiliser _Autoprefixer_ pour les gÃ©nÃ©rer
automatiquement.*

-----

#### Question 11

```css
.form{width:100%;padding-bottom:1.5rem}.form__heading{width:100%;color:#fff;
text-shadow:.55rem .55rem #11af82;background:#15DEA5;line-height:5rem;padding:1.5rem}
.form__field label{color:#D6FFF5;display:block;font-size:2rem;line-height:2rem;padding-top:1.5rem}
.form__field input{width:100%;background:#001534;border:0.1rem solid #15DEA5;padding:1.5rem;
color:#D6FFF5;font-weight:900;font-style:italic;font-size:2.75rem}
.form__field textarea{width:100%;color:#15DEA5;background:#001534;border:0.1rem solid #15DEA5;
outline:none;padding:1.5rem;margin-bottom:.75rem}
```

**Pour prÃ©parer votre dÃ©ploiement en ligne, lequel des bouts de code suivants compilera votre code Sass en CSS minifiÃ© tel quâ€™on
peut le voir ci-dessus ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Nested<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Compressed<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Compact<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Expanded<br />
<br />

*Sass a quatre modes de compilation disponibles via leÂ flag `--style`Â :*
- _**Nested** : imite le nesting Sass tout en maintenant une syntaxe CSS correcte._
- _**Expanded** : le plus proche de la faÃ§on dont on Ã©crit gÃ©nÃ©ralement le CSS manuellement, et par consÃ©quent plus facile Ã  lire._
- _**Compact** : met chaque sÃ©lecteur et son ensemble de rÃ¨gles sur une seule ligne._
- _**Compressed** : supprime tous les espaces et retours Ã  la ligne, ce qui crÃ©e un fichier plus lÃ©ger et plus adaptÃ© au
dÃ©ploiement. On lâ€™appelle souvent code minifiÃ©._

*Pour prÃ©parer votre dÃ©ploiement, la meilleure faÃ§on de procÃ©der est de compiler votre Sass en CSS minifiÃ© en utilisant le mode
**compressÃ©**.*
