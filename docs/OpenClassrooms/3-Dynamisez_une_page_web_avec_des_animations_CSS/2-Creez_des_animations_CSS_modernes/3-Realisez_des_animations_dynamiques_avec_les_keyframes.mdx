---
sidebar_position: 4
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# R√©alisez des animations dynamiques avec les @keyframes

## Cr√©ez des animations plus complexes avec la r√®gle CSS @keyframes

[Cr√©ez des animations plus complexes avec la r√®gle CSS @keyframes - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340923-creez-des-animations-plus-complexes-avec-la-regle-css-keyframes)

<Vimeo vimeoId="508777342" />

<br />

Avec les transitions, nous avons appris √† d√©finir une valeur de d√©part et une valeur de fin.

Ces transitions sont parfaites pour animer par exemple l'√©tat de survol d'un bouton ou le fait de passer d'une couleur A √† une couleur B (en
animant `opacity`¬†et pas `background-color`, n'est-ce pas ü§®). Simple et efficace. Vous pouvez m√™me changer le timing de votre transition.

Mais comment faire si on veut plus qu'un point A et un point B ?

### Cr√©ez des √©tapes suppl√©mentaires

Jetons un ≈ìil √† la barre de progression que nous avions cr√©√©e dans la partie 2, lorsque nous avons √©tudi√© `transform-origin`¬†:

![La barre de chargement avec transform-origin](https://user.oc-static.com/upload/2021/02/10/16129488216241_Gif099.gif)

Cette barre de chargement fait le travail. Mais‚Ä¶ toutes les personnes ayant d√©j√† t√©l√©charg√© quelque chose sur Internet savent que les vitesses
de connexion sont loin d'√™tre **constantes**. La progression se fait par √†-coups, entrecoup√©s de pauses et de ralentissements (ce qu'on pr√©f√®re).
Dans la courbe d'acc√©l√©ration de notre transition, le **timing** commence rapidement avant de s'estomper vers la fin, mais la progression suit
toujours une trajectoire r√©guli√®re.

Si nous voulons cr√©er une barre de progression avec un ressenti plus **authentique**, nous pouvons utiliser la r√®gle CSS _**@keyframes**_. Elle
nous permet de cr√©er des arr√™ts et des acc√©l√©rations plus irr√©guliers, qui ressemblent davantage √† une v√©ritable barre de chargement.

Alors que les transitions CSS ne font que passer d'une valeur √† l'autre, les @keyframes nous permettent de concevoir des animations avec
plusieurs √©tapes, et ainsi de cr√©er des animations plus **complexes** et **dynamiques**.

Repr√©sentez-vous une course d'obstacles. Pour se rendre de la ligne de d√©part √† la ligne d'arriv√©e, les concurrents doivent passer √† travers
des pneus, grimper par-dessus un mur et se balancer √† travers une s√©rie de barres parall√®les. Et entre¬†deux obstacles, un point de contr√¥le,
pour que les concurrents terminent tout le parcours, plut√¥t que de tricher en courant directement jusqu'√† la ligne d'arriv√©e. Nous pouvons
comparer les @keyframes √† ces points de contr√¥le : ils jalonnent l'itin√©raire de nos animations.

### D√©finissez vos keyframes

Un keyframe CSS est d√©fini par le **pourcentage d'animation** compl√©t√© lorsque sa valeur est r√©alis√©e.

Cela veut dire que le d√©but de notre animation en keyframes aurait une progression de 0% et la propri√©t√© transform√©e une valeur de `scaleX(0)`.
La fin aurait une progression de 100% et une valeur de `scaleX(1)`. Maintenant que nous avons la premi√®re et la derni√®re √©tape, construisons
notre premier ensemble de @keyframes¬†!

Contrairement aux transitions, qui sont √† usage unique et qui n'existent qu'√† l'int√©rieur du s√©lecteur o√π elles ont √©t√© d√©clar√©es, les
@keyframes sont disponibles globalement, donc n'importe quel s√©lecteur dans notre fichier CSS peut les utiliser. Et comme ils sont disponibles
de mani√®re globale, ils ne sont pas d√©clar√©s dans un s√©lecteur. Au lieu de cela, nous d√©clarons les @keyframes au niveau de base du fichier CSS,
en utilisant l'op√©rateur @keyframe, suivi du nom de notre choix, entre accolades ouverte et ferm√©e :

```scss
@keyframes progress-bar {
}
```

Lorsque nous utilisons la r√®gle @keyframes, nous d√©clarons un **ensemble** de keyframes et nous lui donnons un nom, que nous pouvons utiliser
pour appeler l'animation sur le s√©lecteur de notre choix. Maintenant que nous avons cr√©√© un ensemble @keyframes pour notre barre de progression,
ajoutons nos keyframes de d√©but et de fin.

Chaque keyframe est d√©fini en utilisant son pourcentage, puis sa propre paire d'accolades qui nous permettent de d√©finir les propri√©t√©s que
nous souhaitons appliquer √† ce stade de l'animation¬†:

```scss
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Nous avons maintenant une animation ¬´¬†progress-bar¬†¬ª (barre de progression) d√©finie par la r√®gle keyframes. Elle part d'une √©chelle `scaleX()`
de z√©ro qui finit √† 1 au cours de son animation, tout comme la transition que nous avons construite dans la partie 2.

Imaginons que nous¬†voulions des keyframes de d√©but et de fin sans rien au milieu. Dans ce cas, pas besoin de pourcentage¬†: nous pouvons d√©finir
les keyframes en utilisant les mots cl√©s ¬´¬†**from**¬†¬ª et ¬´¬†**to**¬†¬ª¬†:

```scss
@keyframes progress-bar {
    from {
        transform: scaleX(0);
    }
    to {
        transform: scaleX(1);
    }
}
```

Le mot cl√© ¬´¬†from¬†¬ª agit exactement de la m√™me fa√ßon que le 0%, et ¬´¬†to¬†¬ª correspond √† 100%¬†: √† vous de choisir en fonction de vos
pr√©f√©rences/vos styles de codage √©tablis.

On est plut√¥t pas mal partis‚Ä¶

:::note ?
Mais qu'est-ce qu'on fait maintenant ?
:::

### Passez √† l'action

Nous pouvons ajouter cette animation dans le pseudos√©lecteur `:active`¬†de notre bouton. Cela vous rappelle quelque chose ? C'est ce que nous
avions fait pour notre transition. Sauf qu'ici, nous la d√©clarons via les propri√©t√©s `animation-name`¬†et `animation-duration`.
`animation-duration`¬†ressemble beaucoup √† `transition-duration`, et accepte une valeur en ms (millisecondes) ou en s (secondes).

`animation-name`, en revanche, est une nouvelle propri√©t√©. Elle nous permet d'assigner l'animation que nous venons de d√©clarer (avec les
√©tapes from et to) √† notre √©l√©ment d√©clencheur ; ici la pseudoclasse `:active`.

Ainsi, pour utiliser les keyframes de notre animation progress-bar, nous devons donner la valeur progress-bar √† `animation-name`¬†:

```scss
.btn {
    &:active {
        & > .progress__bar {
            transform: scaleX(1);
            animation-name: progress-bar;
        }
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Maintenant, il nous suffit de reproduire la dur√©e de notre transition. Pour cela, assignons √† la propri√©t√© `animation-duration`¬†une valeur de
1000¬†ms¬†:

```scss
.btn {
    &:active {
        & > .progress__bar {
            transform: scaleX(1);
            animation-name: progress-bar;
            animation-duration: 1000ms;
        }
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Bien jou√©¬†!

Pour bien comprendre : les transitions s'animent lorsqu'on assigne une valeur √† une propri√©t√© et que cette valeur change dans l'√©l√©ment
d√©clencheur. Pour les transitions, les valeurs doivent donc √™tre assign√©es aux s√©lecteurs √† l'int√©rieur de notre code.

Les animations @keyframes sont un peu diff√©rentes. Lorsque `animation-name`¬†et `animation-duration`¬†sont assign√©s √† un s√©lecteur, les
propri√©t√©s et valeurs contenues dans chaque keyframe sont appliqu√©es pendant toute la dur√©e de l'animation.

Cela signifie que nous n'avons pas besoin de nous soucier de r√©gler la valeur de `scaleX()`¬†comme nous l'avions fait avec notre transition sur
la barre de progression. Nous n'avons cependant pas besoin de la supprimer. En cas de conflit entre les propri√©t√©s/valeurs CSS d'une valeur
assign√©e et d'une valeur avec keyframe, le CSS privil√©gie la valeur d√©clar√©e dans le keyframe.

:::caution !
Quelles que soient les propri√©t√©s CSS que nous pla√ßons √† l'int√©rieur de notre animation¬†@keyframes, elles remplaceront toutes les propri√©t√©s
CSS existantes sur le s√©lecteur o√π elles sont assign√©es. Il est important de se rappeler que nous ne pouvons avoir qu'une seule propri√©t√© de
transformation appliqu√©e √† un s√©lecteur. Par exemple, si nous avons un s√©lecteur ayant une propri√©t√© `transform`¬†utilisant la fonction
`translate()`, nos keyframes ayant √©galement scale l'√©craseront et supprimeront toutes les translations que nous avions appliqu√©es.
:::

M√™me si nous n'en avons pas _besoin_, pour des raisons de clart√©, voyons comment supprimer transform de la pseudoclasse¬†`:active`¬†:

```scss
.btn {
    &:active {
        & > .progress__bar {
            animation-name: progress-bar;
            animation-duration: 1000ms;
        }
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Et voil√†, on est pr√™ts¬†!

Heu‚Ä¶ vraiment¬†? Comme pour les transitions, il est possible d'utiliser une seule propri√©t√© d'animation pour d√©finir son nom, sa dur√©e, etc. Un
peu de m√©nage s'impose pour simplifier notre code !

```scss
.btn {
    &:active {
        & > .progress__bar {
            animation: progress-bar 1000ms;
        }
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Voyons voir comment se porte notre nouvelle barre de progression avec keyframes¬†:

![La barre de chargement avec les keyframes](https://user.oc-static.com/upload/2021/02/10/16129488552233_Gif100.gif)

:::note ?
O√π est-elle pass√©e ?! Elle s'anime comme on voulait... mais ensuite elle dispara√Æt¬†?
:::

Nous reviendrons plus en d√©tail sur les diff√©rences entre les transitions et les animations r√©alis√©es avec @keyframes dans le chapitre suivant.
Mais pour l'instant, sachez simplement que les deux se comportent diff√©remment.

### D√©composez les diff√©rents keyframes

Nous avons une barre de progression anim√©e qui passe directement de 0% √† 100%. Elle ressemble bien √† notre transition. Mais nous voulions
**complexifier** l'animation en ajoutant quelques keyframes ici et l√†. Pour cela, quels pourcentages devons-nous choisir¬†? Et quelles valeurs
devons-nous leur attribuer¬†? Utilisons comme mod√®le la courbe d'acc√©l√©ration de notre transition de barre de progression originale¬†:

![Image montrant la progression originale de l'animation](https://user.oc-static.com/upload/2021/02/15/16133908125247_CSS_graphic_1C6_5%20copy.png)

:::info
Comme dans la partie pr√©c√©dente, le logiciel le plus utilis√© √©tant en anglais, les captures d'√©cran seront en anglais.

Pr√©cisons : Animation Percentage = pourcentage de l'animation.
:::

Sur l'axe X, nous avons le pourcentage de progression de l'animation, de notre point de d√©part √† 0% √† 100% tout √† droite. Et sur l'axe Y, nous
avons la valeur de `scaleX()` de 0 en bas √† 1 en haut.

Si nous devions choisir un point le long de la courbe d'acc√©l√©ration, sa coordonn√©e X pourrait servir de valeur en pourcentage des keyframes,
et sa coordonn√©e Y de valeur pour `scaleX()`¬†:

![Barre de chargement avec keyframes](https://user.oc-static.com/upload/2021/02/10/16129488958038_Gif101.gif)

Choisissons trois points le long de la courbe que nous d√©finirons comme keyframes. Puisque nous voulons d√©composer un peu l'animation de fa√ßon
√† la rendre plus naturelle, essayons de choisir ces points √† intervalles al√©atoires sur l'axe des X. Quelque chose comme cela pourrait marcher¬†:

![Les points choisis pour les keyframes](https://user.oc-static.com/upload/2019/08/06/15650997031089_image54.png)

Maintenant que nous avons des valeurs avec lesquelles nous pouvons travailler, replongeons-nous dans nos keyframes¬†! Pour les cr√©er, nous
allons prendre la coordonn√©e X de chaque point, la transformer en pourcentage pour chacun de nos nouveaux keyframes, et utiliser la coordonn√©e
Y comme valeur pour la valeur de scaleX(), de cette fa√ßon :

```scss
.btn {
    &:active {
        & > .progress__bar {
            animation: progress-bar 1000ms;
        }
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.4);
    }
    46% {
        transform: scaleX(.81);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Voyons comment l'animation s'affiche √† l'√©cran avec nos nouveaux keyframes¬†:

![L'animation de la barre de chargement avec les keyframes](https://user.oc-static.com/upload/2021/02/10/16129489187728_Gif102.gif)

La barre se remplit avec un profil similaire √† notre transition, mais chaque fois que l'animation arrive √† un keyframe, il y a un l√©ger
ralentissement dans sa progression. On approche bien du sentiment de vraiment charger quelque chose.

:::info
Les ralentissements √† chaque keyframe proviennent de la fonction de timing qui leur est appliqu√©e par d√©faut. Ici, nous n'avons pas appliqu√©
manuellement de fonction de timing, donc comme pour les transitions, une fonction de timing par d√©faut est appliqu√©e. Dans le chapitre suivant,
nous examinerons plus en d√©tail le r√¥le des fonctions de timing avec les @keyframes CSS, mais pour l'instant, sachez que si aucune fonction de
timing n'est appliqu√©e √† une animation, une fonction de timing par d√©faut est appliqu√©e √† chaque keyframe. Cela cr√©e ainsi des ralentissements
momentan√©s entre la sortie lente d'un keyframe et l'introduction lente du keyframe suivant.
:::

### Animez plusieurs propri√©t√©s

Nous avons donc une barre de progression un peu plus authentique. Ajoutons maintenant encore un peu plus de complexit√©. Au-del√† de sa
progression de gauche √† droite, nous aimerions aussi que l‚Äôopacit√© de notre animation change, pour qu'elle √©volue d'un vert translucide √† un
joli vert menthe, au fur et √† mesure que la barre se remplit. Lorsque nous cr√©ons des @keyframes CSS, nous ne sommes pas limit√©s √† une seule
propri√©t√©. Bien au contraire ! Nous pouvons assigner √† chaque keyframe **autant de propri√©t√©s** que nous le souhaitons.

Pour ajouter des propri√©t√©s suppl√©mentaires √† un keyframe, il suffit de les ajouter dans nos **accolades**, comme nous le ferions avec un
s√©lecteur CSS standard. Pour notre animation de couleur, nous pouvons configurer notre premier keyframe pour que la barre ait une opacit√© de
10% au d√©but de l'animation¬†:

```scss
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
        opacity: .1;
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.4);
    }
    46% {
        transform: scaleX(.81);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Nous avons r√©gl√© l'opacit√© √† 10% dans le premier keyframe. Mais rien n'est pr√©cis√© dans les suivants quant √† l'opacit√©. On peut supposer que
la couleur de la barre restera √† 10% d'opacit√© pendant le reste de l'animation.

Voyons voir ce que √ßa donne dans le navigateur :

![L'animation de la barre de chargement dans le navigateur](https://user.oc-static.com/upload/2021/02/10/16129489287995_Gif103.gif)

‚Ä¶ Ce n'est pas du tout le cas !

Bien qu'il n'y ait pas d'autres keyframes pour l'opacit√©, la barre repasse bien √† 100% d'opacit√© au cours de l'animation.

:::note ?
Mais¬†pourquoi ?
:::

Nous n'avons pas pr√©cis√© de valeur d'opacit√© dans les autres keyframes. Le navigateur va donc chercher la valeur d'opacit√© dans le s√©lecteur.
Or, nous n'avons d√©clar√© aucune valeur de mani√®re explicite non plus dans `.progress__bar`.¬†Le navigateur prend donc la valeur par d√©faut de
1 pour l'opacit√©.

Testons cela. Assignons une valeur de 0 √† opacity dans le s√©lecteur `.progress__bar`¬†et augmentons l'opacit√© de notre premier keyframe √† 50%¬†:

```scss
.progress {
    &__bar {
        opacity: 0;
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
        opacity: .5;
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.4);
    }
    46% {
        transform: scaleX(.81);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Maintenant, notre barre devrait commencer √† 50% et s'animer pour devenir compl√®tement transparente √† la fin de l'animation¬†:

![L'animation avec la valeur d'opacit√© chang√©e](https://user.oc-static.com/upload/2021/02/10/16129489876045_Gif105.gif)

Sans keyframe de d√©part, le navigateur d√©marrera l'animation avec la valeur dans le s√©lecteur, tout comme il le fait √† la fin d'une animation
si nous ne fournissons pas de keyframe de fin. Donc, si nous devions seulement fixer la valeur d'opacit√© √† un pourcentage interm√©diaire, comme
cela¬†:

```scss
.progress {
    &__bar {
        opacity: 0;
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.4);
    }
    46% {
        transform: scaleX(.81);
        opacity: 1;
    }
    100% {
        transform: scaleX(1);
    }
}
```

Notre barre commence et se termine d√©sormais avec la valeur d'opacit√© que nous avons assign√©e dans `.progress__bar`, qui est z√©ro¬†:

![L'animation de la barre qui se charge](https://user.oc-static.com/upload/2021/02/10/1612948948211_Gif104.gif)

Nous sommes d'accord l√†-dessus : une barre de progression enti√®rement transparente ne constitue pas vraiment la meilleure exp√©rience
utilisateur.

Assignons donc une valeur d'opacit√© de 1. Mais, cette fois-ci, plut√¥t que d'attendre que l'animation soit compl√®tement termin√©e pour devenir
opaque, fixons le pourcentage de keyframe √† 85%¬†:

```scss
.progress {
    &__bar {
        opacity: 0;
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.4);
    }
    46% {
        transform: scaleX(.81);
    }
    85% {
        opacity: 1;
    }
    100% {
        transform: scaleX(1);
    }
}
```

Maintenant notre barre devrait passer 85¬†% de la dur√©e de l'animation √† remplir l'opacit√©. Allons v√©rifier cela¬†:

![L'animation avec l'opacit√© chang√©e](https://user.oc-static.com/upload/2021/02/10/1612948998744_Gif106.gif)

Eh bien... elle passe bien 85% de l'animation √† augmenter l'opacit√© de la barre, mais ensuite elle passe les 15% de l'animation finale √†
revenir √† une barre compl√®tement transparente. Ce n'est pas exactement ce que nous esp√©rions...

Plut√¥t normal en fait : nous n'avons toujours pas de valeur pour la propri√©t√© d'opacit√© √† animer entre 85% et 100%, donc le navigateur passe
les 15¬†derniers pourcents de l'animation √† repasser √† la valeur assign√©e √† `.progress__bar`, qui est toujours 0. Nous devons donc d√©finir un
dernier keyframe pour la propri√©t√© d'opacit√©, avec une valeur fix√©e √† 1.

Nous avons d√©j√† cr√©√© un keyframe avec un pourcentage de 100% pour notre propri√©t√© `transform`. Nous pourrions ajouter la propri√©t√© d'opacit√© √†
ce keyframe, mais que se passerait-il si nous d√©cidions que nous voulions que notre opacit√© finale soit de 85% au lieu de 100%¬†? Ensuite, nous
devons modifier la valeur d'opacit√© dans plusieurs emplacements. Cela signifie plus de travail üò≠, mais aussi des risques suppl√©mentaires
d'oubli et d'erreur.

Jusqu'√† pr√©sent, nous avons fix√© un pourcentage unique pour chaque keyframe, mais nous pouvons attribuer plusieurs pourcentages √† un keyframe.
En ajoutant plusieurs pourcentages √† un keyframe, le navigateur appliquera son contenu √† chaque pourcentage d'animation. Il suffit de les
s√©parer par des virgules¬†:

```scss
.progress {
    &__bar {
        opacity: 0;
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.4);
    }
    46% {
        transform: scaleX(.81);
    }
    85%,100% {
        opacity: 1;
    }
    100% {
        transform: scaleX(1);
    }
}
```

Et maintenant, si nous reprenons notre barre de progression pour la tester √† nouveau, les choses _devraient_ ressembler √† ce √† quoi nous nous
attendions¬†:

![L'animation termin√©e](https://user.oc-static.com/upload/2021/02/10/1612949009296_Gif107.gif)

PARFAIT¬†! Maintenant l'opacit√© de notre barre de chargement est totale √† 85% et le reste jusqu'√† la fin de l'animation.

Alors, vous avez test√© chez vous ? ü§ì

:::info
Si un pourcentage de keyframe est d√©fini plusieurs fois au sein d'un ensemble et que ces keyframes contiennent des valeurs contradictoires, la
valeur du keyframe qui a √©t√© d√©finie en dernier remplacera la ou les valeur(s) pr√©c√©dente(s) du ou des keyframe(s).
:::

:::caution
Les animations CSS sont encore relativement nouvelles, et ne sont donc pas encore compl√®tement standardis√©es d'un navigateur √† l'autre. Par
souci de simplicit√© pour le cours, nous n'utilisons que les propri√©t√©s standard dans nos snippets de code. Mais si vous d√©ployez votre code,
toutes les animations CSS devraient avoir des pr√©fixes de navigateur appliqu√©s avant leur d√©ploiement, pour √™tre s√ªr qu'elles soient
compatibles avec tous les navigateurs.
:::

### En r√©sum√©

- les animations @keyframes nous permettent de construire des animations plus complexes en¬†cr√©ant plusieurs √©tapes pour les propri√©t√©s tout au
long de l'animation ;
- les keyframes CSS sont instanci√©es √† l'aide de la r√®gle @keyframes suivie d'un nom pour l'ensemble des keyframes¬†:
    - @keyframes example-frames {...} ;
- chaque keyframe peut √™tre √©tabli en utilisant comme valeur le pourcentage d'animation r√©alis√©¬†:
    - 33% {...} ;
- si vous n'avez besoin que d'un keyframe de d√©but et de fin, les mots cl√©s ¬´¬†from¬†¬ª et ¬´¬†to¬†¬ª peuvent √™tre utilis√©s √† la place de 0% et 100%
respectivement ;
- si aucun keyframe de d√©but ou de fin n'est fourni, l'animation commence et/ou se termine avec les valeurs de propri√©t√© assign√©es au s√©lecteur.
Si aucune valeur n'est explicitement assign√©e dans le s√©lecteur, c'est la valeur par d√©faut qui est choisie ;
- une animation d√©finie par la r√®gle @keyframes peut contenir diff√©rents keyframes avec des propri√©t√©s distinctes ;
- plusieurs pourcentages peuvent √™tre assign√©s √† un seul keyframe. Les valeurs d√©finies dans ce keyframe seront appliqu√©es √† ces pourcentages
dans l'animation ;
- les propri√©t√©s et valeurs d'un ensemble de keyframes remplaceront les valeurs de propri√©t√©s attribu√©es √† un s√©lecteur au cours de l'animation.

_Vous avez maintenant d√©couvert les keyframes : bravo ! Dans le prochain chapitre, nous allons nous pencher plus en d√©tail sur l'impl√©mentation
d'animations @keyframes dans notre CSS, sur les diff√©rences fondamentales avec les transitions. Nous verrons √©galement comment pousser nos
animations encore plus loin avec d'autres propri√©t√©s d'animation @keyframes. √Ä tout de suite !_

-----

## Utilisez les propri√©t√©s de l'animation CSS

[Utilisez les propri√©t√©s de l'animation CSS - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6341109-utilisez-les-proprietes-de-lanimation-css)

<Vimeo vimeoId="508777376" />

<br />

En surface, les keyframes ressemblent _beaucoup_ √† des transitions, mais avec des √©tapes suppl√©mentaires en chemin. Peut-√™tre que vous-m√™me,
vous ne voyez les keyframes que comme des transitions avec des √©tapes suppl√©mentaires ?

Mais d√©trompez-vous ! Les keyframes sont _plus_ qu'un ensemble de valeurs !

### Comprenez la diff√©rence entre @keyframes et transition

Comme nous venons de le voir avec notre barre de progression, les animations CSS avec keyframes ne se comportent pas comme des transitions.
C'est normal : **transitions et animations sont deux techniques ayant des logiques diff√©rentes, car elle ne r√©pondent pas au m√™me objectif**.

Les transitions sont destin√©es √† s'int√©grer de mani√®re subtile entre une valeur de d√©part et une valeur de fin. Telles que des valeurs
`scale()`¬†(d'√©chelle) diff√©rentes sur un bouton et sa pseudoclasse `:hover`¬†:

![Une animation CSS d'un bouton qui grossit avec des transitions](https://user.oc-static.com/upload/2021/02/10/1612949114373_Gif108.gif)

Ce bouton s'agrandit au fur et √† mesure que nous le survolons, puis r√©tr√©cit lorsque la souris s'en √©loigne, m√™me si la transition n'est pas
termin√©e.

Si nous appliquons les m√™mes valeurs `scale()`¬†via des @keyframes, le r√©sultat obtenu est totalement diff√©rent. Voyez par vous-m√™me¬†:

![Une animations du m√™me bouton qui grossit avec des keyframes](https://user.oc-static.com/upload/2021/02/10/16129491258451_Gif109.gif)

Lorsque nous cr√©ons une transition, nous disons au navigateur d'aller et venir entre les valeurs assign√©es dans un s√©lecteur et les valeurs
assign√©es √† une pseudoclasse. Les @keyframes, quant √† eux, lisent une s√©rie de valeurs **d√©finies**. Une fois d√©clench√©e, une animation avec
keyframes progresse jusqu'√† ce qu'elle soit termin√©e, ou jusqu'√† ce qu'elle soit interrompue.

Avec les keyframes, lorsque nous assignons notre animation progress-bar √† l'√©tat `:active`¬†de notre bouton, l'animation n'existe que si l'√©tat
`:active`¬†est d√©clench√©. Lorsque l'on retire la souris, l'√©tat `:active`¬†dispara√Æt de l'√©l√©ment, et avec lui, de l'animation qui lui a √©t√©
assign√©e. C'est pour cette raison que l'animation dispara√Æt si brusquement lorsque l'on sort de l'√©tat `:active`.

![Une animation d'une barre de chargement qui dispara√Æt lorsqu'elle est √† 100 %](https://user.oc-static.com/upload/2021/02/10/16129491378691_Gif110.gif)¬†

Les transitions sont **intrins√®quement** li√©es √† l'√©tat d'un √©l√©ment et aux diff√©rences dans ses valeurs assign√©es. Les propri√©t√©s et valeurs
des keyframes sont quant √† elles cod√©es en dur, elles ne n√©cessitent qu'un √©v√©nement pour les d√©clencher. Les pseudoclasses ne sont que l'une
des options pour le faire. Dans ce chapitre, nous allons examiner une autre fa√ßon de d√©ployer nos animations, ainsi que les propri√©t√©s
suppl√©mentaires √† notre disposition pour concevoir des animations et des exp√©riences utilisateur plus complexes.

### D√©clenchez vos animations d√®s le chargement de la page

Jusqu'√† maintenant, nous avons appris √† utiliser syst√©matiquement une pseudoclasse pour d√©clencher nos animations. Car c'est effectivement la
seule option en¬†CSS lorsque nous utilisons des transitions. **Mais avec les @keyframes, nous pouvons d√©clencher une animation d√®s le
chargement d'un √©l√©ment.**

Lorsque nous assignons une animation avec keyframe √† un √©l√©ment, il d√©clenchera l'animation au chargement dans le navigateur. Plut√¥t que
d'appliquer notre animation de barre de progression √† la pseudoclasse `:active`¬†sur `.btn,`¬†appliquons-la √† `.progress__bar`¬†en tant que
telle¬†:

```scss
.progress {
    &__bar {
        animation: progress-bar 1000ms;
    }
}
@keyframes progress-bar{
    0% {
        transform: scaleX(0);
        opacity: .1;
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.4);
    }
    46% {
        transform: scaleX(.81);
    }
    85%,100% {
        opacity: 1;
    }
    100% {
        transform: scaleX(1);
    }
}
```

Maintenant, notre barre de progression se chargera d√®s que la page web sera charg√©e. Il n'est pas n√©cessaire d'interagir avec un bouton, ni
d'ailleurs avec aucun autre √©l√©ment. Le chargement de la page, et donc la barre de progression, est l'√©v√©nement qui d√©clenche l'animation.
Cela signifie que nous pouvons nous d√©barrasser de ce bouton¬†:

```html
<html>
    <div class="container">
        <div class="progress">
            <div class="progress__bar"></div>
        </div>
    </div>
</html>
```

Notre barre de progression se suffit maintenant √† elle-m√™me. Nous avons ins√©r√© un¬†GIF pour indiquer quand la page se recharge¬†:

![Barre de chargement avec icone et sans d√©lai](https://user.oc-static.com/upload/2021/02/10/16129491527251_Gif111.gif)

Superbe¬†! Notre animation... est anim√©e¬†!

Cher utilisateur, nous n'avons plus besoin de toi pour d√©clencher nos animations avec tes interactions. Plut√¥t pratique, n'est-ce pas ? Nous
pouvons cr√©er des animations sur notre site web pour introduire des √©l√©ments au fur et √† mesure de leur chargement.

### Ajoutez un d√©lai √† votre animation @keyframes

Le seul probl√®me avec une animation qui d√©marre d√®s que la page se charge, c'est que... l'animation d√©marre d√®s la page se charge. Notre
animation commence donc avant que nos visiteurs n'aient vraiment eu la chance de commencer √† parcourir notre page.

Vous savez ce qui serait parfait¬†? Utiliser un d√©lai de transition pour que notre animation attende un peu avant de d√©marrer. Malheureusement,
la propri√©t√© `transition-delay`¬†permet de retarder les _transitions_, et les transitions seulement. üò≠

...Heureusement pour nous, il existe la propri√©t√© `animation-delay`¬†!

Vous allez finir par croire que j'adore jouer avec vos √©motions. Je vous dis qu'on ne peut pas, mais que finalement si. Ne m'en veuillez pas,
j'essaie de vous faire d√©couvrir la richesse des animations keyframes petit √† petit, pour que puissiez pleinement en profiter ü§©.

La propri√©t√©¬†`animation-delay`¬†fonctionne comme `transition-delay`, sauf qu'elle retarde uniquement les animations con√ßues avec des @keyframes.
Elle accepte les valeurs en secondes ou en millisecondes :

```scss
.delay-seconds {
    animation-delay: 1s;
}
.delay-seconds {
    animation-delay: 1000ms;
}
```

Tout comme pour `transition-delay`, nous pouvons indiquer la valeur de cette propri√©t√© dans la version abr√©g√©e "animation", en l'indiquant
dans sa liste de valeurs. Ajoutons donc un court d√©lai de 150ms √† l'animation de notre barre de progression¬†:

```scss
.progress {
    &__bar {
        animation: progress-bar 1000ms 150ms;
    }
}
```

Maintenant, notre barre de progression attendra 0,15 secondes avant de commencer le chargement, donnant √† nos visiteurs un moment pour
remarquer notre barre de progression au chargement de la page :

![Barre de chargement avec icone et d√©lai de 0.15s](https://user.oc-static.com/upload/2021/02/15/16133904011168_Gif112.gif)

√áa marche¬†! Mais...

L'effet ne marche pas vraiment, car rien n'est charg√©... La barre se remplit, et puis... plus rien.

Choisissons du contenu √† afficher une fois l'animation de la barre de progression termin√©e. Apr√®s tout, on est sur Internet, et Internet,
c'est un peu le royaume des chats. Donc c'est parti pour une photo de chat. Alors, voyons voir ce que nous trouvons.

### Encha√Ænez les animations

![Photo de chat](https://user.oc-static.com/upload/2019/08/24/15666772486521_Capture%20d%E2%80%99e%CC%81cran%202019-08-24%20a%CC%80%2018.48.50.jpg)

üôåYes ! √áa devrait faire l'affaire !

:::info
Des sites comme [unsplash.com](https://unsplash.com/) ou [pexels.com](https://www.pexels.com/)¬†mettent √† votre disposition des tonnes d'images
de qualit√©, libres de droit et donc disponibles gratuitement¬†! Assurez-vous simplement que la licence sur la photo corresponde √† l'utilisation
que vous comptez en faire sur votre site.
:::

Ajoutons une `div`¬†pour notre photo de chat apr√®s notre `div .progress`, ainsi que quelques paragraphes de texte¬†:

```html
<html>
    <p>Merci pour votre patience</p>
    <p>Voici votre chat</p>
</html>
```

Et utilisons la propri√©t√© `background-image`¬†pour remplir la div avec notre nouvelle photo de chat, ainsi que quelques autres propri√©t√©s pour
redimensionner et recadrer l'image et rendre le texte lisible¬†:

```scss
.cat {
    width: 50vw;
    height: 30vw;
    position: absolute;
    overflow: hidden;
    background-image: url("https://bit.ly/2XJJLKn");
    background-size: cover;
    background-position: -20%;
    z-index: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    padding: .1rem;
    font-size: 4vw;
    font-weight: 900;
    color: white;
}
```

Si nous l'affichons dans le navigateur, nous voyons notre photo de chat... et pas grand-chose d'autre¬†:

![Image de chat](https://user.oc-static.com/upload/2019/08/24/15666817026193_Webp.net-resizeimage.png)

Pour le moment, notre div `.cat`¬†couvre notre barre de progression, ce qui convient une fois la barre charg√©e. En revanche, nous ne souhaitons
pas la voir tant que la barre n'a pas fini de se charger. Pour cela, cr√©ons un nouvel ensemble de @keyframes pour d√©placer notre image hors de
l'√©cran, jusqu'√† ce que la barre ait fini de se charger.

```scss
@keyframes cat {
    0% {
        transform: translateX(-9999px);
    }
    100% {
        transform: translateX(0);
    }
}
```

La propri√©t√© `transform`¬†avec sa fonction `translateX()`¬†nous permet de d√©placer notre chat hors de l'√©cran au d√©but de l'animation, et
mettre sa valeur de fin √† 0, ce qui l'am√®ne √† son point de destination. Nous avons √©galement d√©clar√© la dur√©e et le d√©lai de lancement de
l'animation dans des variables, ce qui nous permet de changer ces valeurs plus facilement (merci Sass üî•).

Maintenant, ajoutons notre animation de chat √† notre div `.cat`. Nous ne voulons pas que notre chat bouge. Nous voulons simplement qu'il
apparaisse quand la barre est compl√®tement charg√©e. Nous r√©glons donc la dur√©e de l'animation sur 0. Le d√©lai, quant √† lui, correspond √† la
combinaison entre la dur√©e de l'animation progress-bar avec son d√©lai¬†de lancement :

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 150ms;
$cat-delay: $prog-bar-dur + $prog-bar-delay;
.cat {
    animation: cat 0ms $cat-delay;
}
@keyframes cat {
    0% {
        transform: translateX(-9999px);
    }
    100% {
        transform: translateX(0);
    }
}
```

Et quand nous la v√©rifions dans le navigateur...

![Image de chat](https://user.oc-static.com/upload/2019/08/24/15666817340739_Webp.net-resizeimage.png)

... le r√©sultat est toujours le m√™me. Notre chat cache toujours tout notre travail. Heureusement qu'il est mignon. Cette fois-ci, ajoutons
une dur√©e √† notre animation pour voir pourquoi les choses ne se passent pas comme pr√©vu :

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 150ms;
$cat-delay: $prog-bar-dur + $prog-bar-delay;
.cat {
    animation: cat 1000ms $cat-delay;
}
@keyframes cat {
    0% {
        transform: translateX(\-9999px);
    }
    100% {
        transform: translateX(0);
    }
}
```

Maintenant, notre chat va glisser en position en l'espace d'une seconde¬†:

![Animation avec translation de la photo de chat sur la barre de chargement](https://user.oc-static.com/upload/2021/02/10/16129492697858_Gif113.gif)

Eh bien, ce n'est pas exactement ce que nous attendions... Notre image appara√Æt au chargement de notre page, puis dispara√Æt brusquement avant
de se placer comme on s'y attendait. Pas _tout √† fait_ ce que nous voulions...

Mais justement, ce comportement ne vous dit pas quelque chose ? ü§î

Quelque chose de _**tr√®s**_ similaire se produit avec notre barre de progression, sauf qu'elle dispara√Æt une fois l'animation _**termin√©e**_.

En fait, lorsque notre animation _n'est pas_ en train d'√™tre anim√©e, les √©l√©ments reviennent √† leur valeur de propri√©t√© assign√©e. C'est
pourquoi notre barre de progression dispara√Æt √† la fin de son animation ; elle anime l'√©chelle horizontale de 0 √† 1, mais elle a une valeur
`scaleX()`¬†de 0 :

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 150ms;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0);
        animation: progress-bar $prog-bar-dur $prog-bar-delay;
    }
}
```

Ainsi, lorsque l'animation se termine, la barre revient √† sa valeur assign√©e pour `scaleX()`, qui est aussi 0, disparaissant ainsi du site :

![Animation de la barre de chargement seule](https://user.oc-static.com/upload/2021/02/10/16129493076545_Gif114.gif)

Il en va de m√™me pour les √©l√©ments qui ont des animations avec des d√©lais assign√©s. Pendant que l'√©l√©ment attend de d√©marrer son animation, il
utilisera les valeurs des propri√©t√©s qui lui ont √©t√© assign√©es. Pour tester cela par nous-m√™me, r√©glons la valeur `scaleX()`¬†de la barre
`.progress__bar`¬†sur .5 et augmentons le d√©lai pour une valeur plus visible, par exemple 1000ms¬†:

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 1000ms;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay;
    }
}
```

Ajoutons des commentaires √† notre `div .cat`¬†pour que nous puissions nous concentrer pour l'instant sur la barre de progression¬†:

```html
<html>
    <div class="container">
        <div class="progress">
            <div class="progress__bar"></div>
        </div>
        <!-- <div class="cat">
            <p>Merci pour votre patience</p>
            <p>Voici votre chat</p>
        </div> -->
    </div>
</html>
```

Voyons maintenant comment se comporte notre barre de progression¬†:

![Barre de progression recharg√©e √† moiti√©](https://user.oc-static.com/upload/2021/02/10/16129493210861_Gif115.gif)

Notre barre de progression respecte un d√©lai d'une seconde avant de s'animer. En attendant, elle est √† une √©chelle de 50% sur l'axe des X et
100% d'opacit√©. Puis, tout¬†√† coup, elle passe √† une¬†`scaleX()`¬†de 0, une opacit√© de .1 et commence √† s'animer jusqu'√† ce que la barre soit
pleine et compl√®tement opaque. Puis, une fois l'animation termin√©e, la barre revient √† ses valeurs assign√©es dans le s√©lecteur.

### √âtendez les propri√©t√©s de vos keyframes avec animation-fill-mode

Pourtant, nous voulons que notre animation s'√©tende de la gauche vers la droite, en remplissant l'espace avant que l'animation ne commence
puis se termine avec les valeurs de d√©but et de fin de l'animation. Nous pouvons nous repr√©senter notre animation par un d√©grad√© de couleur,
allant d'un vert menthe au bleu marine :

![Image repr√©sentant le d√©grad√© de couleurs](https://user.oc-static.com/upload/2019/08/07/15651665038496_image76.png)

Plut√¥t que de commencer et de terminer la couleur au d√©but du d√©grad√© de couleur, nous voulons que la couleur de d√©part remplisse l'espace √†
gauche du d√©grad√©, en reprenant la couleur de d√©part, puis que la couleur de fin s'√©tende vers la droite du d√©grad√©, bas√©e sur la couleur de
fin¬†:

![Image repr√©sentant le d√©grad√© complet](https://user.oc-static.com/upload/2019/08/07/15651665735252_image16.png)

Pour remplir les espaces avant et apr√®s nos animations avec keyframes, nous pouvons utiliser la propri√©t√©¬†**`animation-fill-mode`**, qui va
√©tendre les valeurs de d√©but d'une animation, ou ses valeurs finales, ou les deux.

`animation-fill-mode`¬†accepte trois mots cl√©s diff√©rents comme valeur. Le premier est **backwards** (pour "en arri√®re"). Backwards √©tend les
valeurs de d√©part d'une animation pour la p√©riode de temps qui pr√©c√®de le d√©but de l'animation¬†:

![Image repr√©sentant le d√©grad√© avec backwards](https://user.oc-static.com/upload/2019/08/07/15651666424076_image67.png)

Comme backwards √©tend cette valeur au d√©but, ce mot cl√© n'est utile que si nous avons un d√©lai appliqu√© √† nos animations. S'il n'y a pas de
d√©lai, il n'y a pas de vide √† remplir avant l'animation pour `animation-fill-mode`.

Ajoutons maintenant animation-fill-mode √† la barre `.progress__bar`¬†avec le mot cl√© _backwards_¬†:

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 1000ms;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay;
        animation-fill-mode: backwards;
    }
}
```

Maintenant, plut√¥t que de commencer √† moiti√© remplie, notre barre de progression reste vide pendant toute la dur√©e de son d√©lai
(animation-delay). √Ä la fin du d√©lai, l'animation continue normalement, et √† la fin, revient en arri√®re √† la valeur assign√©e de `scaleX(.5)` :

![animation-fill-mode: backwards pour la barre de progression](https://user.oc-static.com/upload/2021/02/10/16129493399757_Gif116.gif)

Le deuxi√®me mot cl√© pour le mode animation-fill-mode est **forwards** (pour "en avant"). Au¬†contraire de backwards, forwards √©tend les valeurs
finales d'une animation vers l'avant, sans fin¬†:

![Une image du d√©grad√© avec forwards](https://user.oc-static.com/upload/2019/08/07/15651668513712_image37.png)

Forwards consiste en quelque sorte √† dire au navigateur de mettre l'animation sur pause sur la toute derni√®re image, plut√¥t que de passer aux
valeurs assign√©es. Changeons la valeur de `animation-fill-mode`¬†de la barre `.progress__bar`¬†avec forwards et d√©couvrons ce que √ßa donne :

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 1000ms;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay;
        animation-fill-mode: forwards;
    }
}
```

Maintenant, notre barre de progression est de nouveau √† 50% jusqu'√† ce que l'animation commence.¬†Elle revient¬†√† 0 en animant √† partir de l√†.
Mais plut√¥t que de revenir directement √† 50%, la barre reste pleine¬†:

![animation-fill-mode forwards pour la barre de progression](https://user.oc-static.com/upload/2021/02/10/16129493556086_Gif117.gif)

Dans notre cas, il semble √©vident que nous voulons que notre animation s'√©tende et se remplisse, dans les deux sens, comme celle de notre
barre de progression. Le mot cl√© judicieusement intitul√© **both** (_les deux_) pour le mode animation-fill-mode remplit l'animation dans les
deux sens¬†:

![Une image de d√©grad√© avec both](https://user.oc-static.com/upload/2019/08/07/15651672482074_image13.png)

R√©glons le mode animation-fill-mode de la barre `.progress__bar`¬†sur both¬†:

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 1000ms;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay;
        animation-fill-mode: both;
    }
}
```

V√©rifions dans le navigateur. Nous devrions voir notre barre partie de 0% de remplissage jusqu'√† ce que l'animation commence, puis se remplir
normalement, et ensuite rester √† 100%¬†:

![animation-fill-mode: both pour la barre de progression](https://user.oc-static.com/upload/2021/02/10/16129493665592_Gif118.gif)

Et voil√†√†√†√†√†√†√†√†√†√†√† une barre de progression fonctionnelle avec nos keyframes üôå ! Plut√¥t pas mal¬†! R√©duisons le d√©lai √† nos 100ms d'origine.
D'ailleurs, tout comme avec nos autres propri√©t√©s d'animation, nous ne sommes pas _oblig√©s_ d'indiquer la propri√©t√© animation-fill-mode
s√©par√©ment. Au lieu de cela, nous pouvons d√©finir sa valeur directement dans la propri√©t√© `animation`¬†raccourcie¬†:

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 1000ms;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay both;
    }
}
```

Nous avons maintenant une barre de progression fonctionnelle.

Revenons maintenant √† notre chat. Nous pouvons utiliser animation-fill-mode. Nous voulons que l'animation s'√©tende dans les deux sens, pour
qu'elle reste invisible jusqu'√† la fin du d√©lai, puis reste visible apr√®s cela. Ajoutons donc le mot cl√© _both_ √† la propri√©t√© d'animation de
`.cat` :

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 150ms;
$cat-delay: $prog-bar-dur + $prog-bar-delay;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay both;
    }
}
.cat {
    animation: cat 0ms $cat-delay both;
}
```

J'esp√®re que √ßa va marcher, que la barre de chargement s'affichera d√®s le chargement de la page. Qu'elle sera vide dans un premier temps,
puis qu'elle se remplira pour enfin laisser appara√Ætre l'image de chat¬†:

![Barre de progression avec photo de chat](https://user.oc-static.com/upload/2021/02/10/16129493817443_Gif119.gif)

Yaaaaay¬†! On a r√©ussi !

Maintenant que tout marche comme voulu, nous pouvons faire quelques petits ajustements.

Nous ne voyons presque pas la barre de progression compl√®tement pleine, car notre image de chat se charge d√®s que la barre est pleine, ce qui
nous laisse peu de temps pour enregistrer que le processus de chargement est termin√©. Ajoutons un peu de retard entre la fin de l'animation
de la barre de progression et le d√©but de l'animation du chat. Nous pouvons multiplier la variable $prog-delay par 2 dans `$cat-delay`, ce qui
nous donnera 150ms suppl√©mentaires avant le d√©but de l'animation du chat¬†:

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 150ms;
$cat-delay: $prog-bar-dur + $prog-bar-delay*2;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay both;
    }
}
.cat {
    animation: cat 0ms $cat-delay both;
}
```

Jetons √† nouveau un coup d'≈ìil au navigateur¬†:

![Barre de chargement avec un d√©lai suppl√©mentaire avant l'affichage de l'image de chat](https://user.oc-static.com/upload/2021/02/10/16129493963629_Gif120.gif)

Beaucoup plus joli. Ce n'est pas un changement √©norme, mais ce petit d√©lai suppl√©mentaire entre les deux animations nous permet de comprendre
que la barre a fini de se charger, ce qui aide √† mieux anticiper et trouver plus fluide le passage direct au contenu du chat.

### Animez vari√© et √©quilibr√©

Maintenant que nous avons charg√© notre contenu comme nous le voulions, revenons plus sp√©cifiquement √† l'animation de la barre de progression
et aux pauses et acc√©l√©rations qu'elle cr√©e lorsque la barre se remplit¬†:

![Barre de progression avec image de chat](https://user.oc-static.com/upload/2021/02/10/16129494149961_Gif121.gif)

Elles ajoutent un peu de texture √† notre animation, mais elles sont assez uniformes. Pour l'instant, chaque keyframe a une acc√©l√©ration et un
ralentissement par d√©faut, que nous pourrions aussi √©crire en cubic-bezier (.25,.1,.25,1).

Ainsi, chaque keyframe dans la barre de progression se voit assigner ces valeurs cubic-bezier, comme si l'intervalle entre¬†deux keyframes
√©tait sa propre animation, avec son propre ¬´¬†ease-in¬†¬ª et ¬´¬†ease-out¬†¬ª. Dans notre graphique cubic-bezier, cela ressemblerait √† cela¬†:

![Le graphique cubic-b√©zier de l'animation](https://user.oc-static.com/upload/2019/08/07/15651685944369_image77.png)

Nous voyons bien comment chaque keyframe a sa propre courbe d'acc√©l√©ration, dict√©e par la fonction animation-timing. Pour rendre cela un peu
plus clair, assignons notre propre fonction de timing, plus extr√™me, √† notre animation progress-bar. Utilisons beaucoup de ¬´¬†easing¬†¬ª, ce qui
va cr√©er un contraste plus marquant d'un point de vue du rythme au cours de l'animation. Quelque chose comme cubic-bezier(.9,0,.1,1)¬†:

![Le cubic-b√©zier pour une animation plus marqu√©e](https://user.oc-static.com/upload/2019/08/07/15651687129788_image7.png)

Pour assigner notre courbe d'acc√©l√©ration `cubic-bezier()`¬†√† `progress-bar`, nous pouvons utiliser la propri√©t√© **animation-timing-function**,
avec la fonction cubic-bezier comme valeur¬†:

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 150ms;
$cat-delay: $prog-bar-dur + $prog-bar-delay*2;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay both;
        animation-timing-function: cubic-bezier(.9,0,.1,1);
    }
}
```

Nous pouvons √©galement raccourcir les choses et ajouter la fonction cubic-bezier √† notre propri√©t√© d'animation abr√©g√©e¬†:

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 150ms;
$cat-delay: $prog-bar-dur + $prog-bar-delay*2;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay both cubic-bezier(.9,0,.1,1);
    }
}
```

Maintenant, les ease-in et ease-out de nos keyframes sont beaucoup plus marqu√©s. Notre animation para√Æt donc plus irr√©guli√®re. Lorsque nous
regardons notre barre de progression √† nouveau dans le navigateur, nous voyons des pauses beaucoup plus d√©lib√©r√©es et des acc√©l√©rations dans
le mouvement de la barre¬†:

![Barre de progression chat avec animation cubic-bezier](https://user.oc-static.com/upload/2021/02/10/16129494777497_Gif122.gif)

Bien que les acc√©l√©rations soient nettement plus visibles avec notre fonction cubic-bezier, elles sont probablement un peu exag√©r√©es. En
g√©n√©ral, la fonction de ¬´¬†ease timing¬†¬ª par d√©faut fonctionne assez bien. Le probl√®me vient du keyframe √† 24%. Il est trop proche du keyframe
pr√©c√©dent, qui, √† 17%, n'est s√©par√© que de 7%. La proximit√© des deux keyframes, combin√©e √† l'uniformit√© des courbes d'acc√©l√©ration, entra√Æne
une l√©g√®re perte de la pause/acc√©l√©ration du deuxi√®me keyframe.

Un keyframe h√©rite par d√©faut du timing d√©fini dans le s√©lecteur o√π l'animation a √©t√© assign√©e, **sauf si une fonction de timing a √©t√©
explicitement assign√©e √† ce keyframe**. Pour assigner une fonction de timing √† un keyframe sp√©cifique, il suffit de d√©clarer la propri√©t√©
animation-timing-function dans le keyframe en question. Revenons √† notre fameux keyframe de¬†24% :

```scss
$prog-bar-dur: 1000ms;
$prog-bar-delay: 150ms;
$cat-delay: $prog-bar-dur + $prog-bar-delay*2;
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0.5);
        animation: progress-bar $prog-bar-dur $prog-bar-delay both;
    }
}
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
        opacity: .1;
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.40);
        animation-timing-function: cubic-bezier(.9,0,.1,1);
    }
    46% {
        transform: scaleX(.81);
    }
    85%,100% {
        opacity: 1;
    }
    100% {
        transform: scaleX(1);
    }
}
```

Lorsque nous assignons une fonction de timing √† un keyframe, nous contr√¥lons la courbe d'acc√©l√©ration des valeurs entre ce keyframe et le
suivant. Cela signifie que nous contr√¥lons l'introduction lente du mouvement √† 24% et la sortie lente √† 46%¬†:

![La partie qui nous int√©resse du cubic-b√©zier](https://user.oc-static.com/upload/2019/08/07/15651795905117_image62.png)

Observons comment notre barre de progression s'affiche dans le navigateur avec sa nouvelle fonction de timing de keyframe¬†:

![Animation barre de progression image chat avec fonction de timing par keyframe](https://user.oc-static.com/upload/2021/02/10/16129495082933_Gif123.gif)

Maintenant, l'acc√©l√©ration du keyframe √† 24% est beaucoup plus prononc√©e, tandis que les autres restent √† des valeurs d'introduction et de
sortie plus fluides. Ce qui est _presque_ parfait.... presque... mais, puisque nous y mettons tant d'efforts, autant le faire jusqu'au bout.

Il y a un petit probl√®me lors de l'acc√©l√©ration du keyframe 46%. Ceci s'explique par le fait que la fonction de timing pr√©c√©dente, d√©clar√©e
sur 24%, a une fin longue et plane, tandis que le d√©but de la fonction de timing du keyframe suivant de cubic-bezier (.25,.1,.25,1) est plus
court avec une pente plus raide. Le mouvement para√Æt moins harmonieux¬†:

![Zoom sur la courbe cubic-b√©zier](https://user.oc-static.com/upload/2021/02/15/16133815127074_3C2_1.png)

Donnons √©galement au keyframe 46% sa propre fonction de timing et utilisons-la pour fluidifier un peu cette transition. Pour rendre le
mouvement plus fluide, il suffit d'aplanir son d√©but, pour mieux encha√Æner avec la sortie du keyframe pr√©c√©dent. Pour l'instant, notre
"ease in" a une coordonn√©e Y de .1. Si nous le r√©duisons √† 0, nous obtenons un cubic-bezier(.25, 0, .25,1) et un "ease in" plus plat¬†:

![La courbe plus](https://user.oc-static.com/upload/2021/02/15/16133815255053_3C2_2.png)

Int√©grons notre nouvelle fonction de timing au keyframe 46%.

Par ailleurs, l'animation de l'opacit√© ne semble plus vraiment ajouter de valeur. Au contraire, elle rend notre animation moins visible.
Supprimons-la et simplifions un peu les choses¬†:

```scss
@keyframes progress-bar {
    0% {
        transform: scaleX(0);
    }
    17% {
        transform: scaleX(.18);
    }
    24% {
        transform: scaleX(.40);
        animation-timing-function: cubic-bezier(.9,0,.1,1);
    }
    46% {
        transform: scaleX(.81);
        animation-timing-function: cubic-bezier(.25,0.25,1);
    }
    100% {
        transform: scaleX(1);
    }
}
```

Voyons ce que √ßa donne¬†:

![Animation barre de progression fonction de timing personnalis√©e et pas de changement d'opacit√©](https://user.oc-static.com/upload/2019/08/24/1566683102931_ezgif.com-optimize%20%284%29.gif)

_Beaucoup_ mieux.¬†

Bravo¬†! Nous avons une barre de progression avec un ressenti plus authentique gr√¢ce √† l'utilisation des @keyframes, et de la propri√©t√©
animation-timing-function. Les propri√©t√©s animation-delay et animation-fill-mode nous permettent √©galement d'encha√Æner les animations entre
elles au mieux.

Encore une fois, si vous souhaitez vous amuser avec le code, je vous mets [un CodePen](https://codepen.io/atoulmet/pen/rNByOPr) √† disposition.

_Pourquoi ne pas essayer de changer la dur√©e de la propri√©t√© animation-timing-function ?_

### R√©sum√©

- les animations CSS @keyframes peuvent √™tre d√©clench√©es en utilisant des pseudoclasses telles que `:hover`, tout comme les transitions ;
- les @keyframes CSS peuvent √©galement √™tre d√©clench√©s par le chargement des √©l√©ments auxquels ils sont assign√©s, comme un s√©lecteur. Par
exemple, d√®s le chargement d'une page ;
- nous pouvons retarder le d√©marrage des animations avec keyframes en utilisant la propri√©t√© `animation-delay`, avec un d√©lai exprim√© en
secondes ou en millisecondes, tout comme les transitions ;
- nous pouvons √©tendre ces valeurs du d√©but √† la fin de ces animations en utilisant la propri√©t√© `animation-fill-mode`¬†:
    - le mot cl√© ¬´¬†backwards¬†¬ª prolonge les valeurs de d√©part d'une animation avant son lancement, couvrant la dur√©e du d√©lai assign√© avant
    que l'animation elle-m√™me ne commence,
    - le mot cl√© ¬´¬†forwards¬†¬ª prolonge les valeurs finales d'une animation jusqu'√† ce que la page soit recharg√©e ou que le navigateur soit
    ferm√©,
    - le mot cl√© ¬´¬†both¬†¬ª prolonge l'animation dans les deux sens ;
- nous pouvons d√©finir une fonction de timing des @keyframes en utilisant la fonction animation-timing-function sur le s√©lecteur o√π
l'animation a √©t√© assign√©e ;
- nous pouvons √©galement d√©finir un timing sp√©cifique keyframe par keyframe, en assignant la propri√©t√© `animation-timing-function`¬†aux
keyframes en question.

_Au chapitre suivant, nous verrons de nouvelles propri√©t√©s li√©es aux @keyframes. Nous verrons notamment comment √©crire des animations plus
concises et r√©utilisables, mais nous apprendrons √©galement √† mettre nos animations sur pause. √Ä tr√®s vite ! üöÄ_

-----

## Manipulez et r√©utilisez les animations CSS

[Manipulez et r√©utilisez les animations CSS - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340941-manipulez-et-reutilisez-les-animations-css)

<Vimeo vimeoId="508777409" />

<br />

√áa fait deux chapitres que je vous en parle, vous devez commencer √† saisir le potentiel des animations @keyframes, n'est-ce pas ?

Nous avons maintenant tous les outils n√©cessaires pour cr√©er et affiner la plupart des animations auxquelles nous pouvons penser. Mais...

Et si on voulait faire une animation de quelque chose qui rebondit ind√©finiment d'avant en arri√®re ?

![Carr√© qui se d√©place de gauche √† droite](https://user.oc-static.com/upload/2021/02/10/16129496961984_Gif124.gif)

Nous _pourrions_ bien s√ªr cr√©er une animation avec _**BEAUCOUP**_ de keyframes...¬†

Et si nous voulions que des √©l√©ments diff√©rents tournent dans des directions oppos√©es ? Ou √† des vitesses diff√©rentes¬†?

![Carr√©s qui effectuent des rotations √† diff√©rentes vitesses et dans diff√©rents sens](https://user.oc-static.com/upload/2021/02/10/16129497089353_Gif125.gif)

Nous _pourrions_ cr√©er plusieurs animations @keyframes, une avec une rotation dans le sens des aiguilles d'une montre et l'autre dans le sens
inverse, une autre avec une vitesse diff√©rente, etc.

Je pr√©f√®re vous le dire tout de suite : si vous pr√©f√©rez ces solutions, ce sera sans moi üôÉ. Car si je vous en parle, c'est qu'il existe bien
s√ªr une solution adapt√©e. En quelques propri√©t√©s seulement, nous pouvons dire au navigateur de le r√©p√©ter pour nous. Ou de le lire √† l'envers.
Ou m√™me de faire une pause et de le jouer sur commande.

Nous allons voir ensemble comment tirer le meilleur parti des animations @keyframes, tout en gardant la base de code la plus propre et
maintenable possible.

### Repensez votre validation d'email

Remontons dans le temps ‚è±, √† la partie 1, chapitre 3 et au monde des transitions et des pseudoclasses. Cette √©poque o√π vous ne connaissiez
pas encore les keyframes. Nous avions cr√©√© un input d'adresse e-mail qui donnait √† l'utilisateur un feedback visuel si l'adresse entr√©e
n'√©tait pas valide :

![Champs email qui devient rouge si l'email n'est pas valide](https://user.oc-static.com/upload/2021/02/10/16129497209027_Gif126.gif)¬†

C'√©tait d√©j√† pas mal du tout. L'utilisateur peut voir en un coup d‚Äô≈ìil qu'il y a quelque chose qui cloche. Mais le fondu entre les √©tats
valide et non valide reste plut√¥t soft.

Nous pouvons maintenant tirer parti des keyframes pour cr√©er une animation encore plus impactante.

Pour vous rafra√Æchir la m√©moire, ici notre √©l√©ment input est un input standard, dont le type est d√©fini sur email :

```html
<html>
    <div class="container">
        <div class="form">
            <div class="form__group">
                <label for="email-input">email</label>
                <input type="email" name=‚Äùemail-input>
            </div>
        </div>
    </div>
</html>
```

Notre animation change actuellement la `background-color`¬†pour un rouge fonc√© sur une dur√©e de 500ms si l'adresse saisie n'est pas valide¬†:

```scss
$cd-txt: #6300a0;
$cd-txt--invalid: #fff;
$cd-danger : #b20a37 ;
.form {
    &__group {
        & input {
            border: 2px solid $cd-box;
            border-radius: 100rem;
            color: $cd-txt;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5rem;
            outline: none;
            padding: .5rem 1.5rem;
            width: 100%;
            transition: background-color 500ms;
            &:focus {
                border: 2px solid $cd-txt;
            }
            &:not(:focus):invalid {
                background-color: $cd-danger;
                border: 2px solid $cd-danger;
                color: $cd-txt--invalid;
            }
        }
    }
}
```

Le style de base est tout √† fait correct, il vaut mieux donc mieux ne pas y toucher. Au lieu de cela, nous allons supprimer la transition du
s√©lecteur d'entr√©e. Au revoir tout notre beau travail ! Il est parfois tr√®s difficile d'avoir √† supprimer du travail sur lequel on avait
pass√© du temps pour se lancer dans une autre direction, mais cela fait juste partie du processus cr√©atif. Parfois, quelque chose ne
fonctionne pas aussi bien que nous l'envisagions, et nous devons savoir l'abandonner. Alors... adieu transition `background-color`.

```scss
$cd-txt: #6300a0;
$cd-txt--invalid: #fff;
$cd-danger : #b20a37 ;
.form {
    &__group {
        & input {
            border: 2px solid $cd-box;
            border-radius: 100rem;
            color: $cd-txt;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5rem;
            outline: none;
            padding: .5rem 1.5rem;
            width: 100%;
            &:focus {
                border: 2px solid $cd-txt;
            }
            &:not(:focus):invalid {
                background-color: $cd-danger;
                border: 2px solid $cd-danger;
                color: $cd-txt--invalid;
            }
        }
    }
}
```

Nous avons d√©sormais un input d'e-mail qui devient rouge lorsque l'entr√©e n'est pas valide et ne sera pas corrig√©e¬†:

![Champ email qui devient rouge lorsque l'email n'est pas valide](https://user.oc-static.com/upload/2021/02/10/16129499442575_Gif127.gif)

Alors maintenant, quoi¬†? Qu'est-ce qu'on pourrait faire de tellement mieux qui justifierait de jeter une transition parfaitement utilisable
pour tout recommencer¬†?

### Cr√©ez des √©motions avec vos animations

Je vous vois. Vous avez h√¢te de savoir ce que l'on va cr√©er ensemble.

L'id√©e est simple : Et si on faisait hocher la t√™te √† notre input¬†?

C'est un signe quasiment universel que¬†la plupart peuvent interpr√©ter comme un ¬´¬†non¬†¬ª. En tant qu'humains, nous absorbons et nous traitons
le langage corporel au niveau de l'inconscient, de sorte que m√™me les mouvements subtils peuvent avoir un sens. Nous n'avons ainsi plus rien
√† faire. Un rapide hochement de t√™te, clair et ferme, c'est tout ce dont nous avons besoin.

:::info
Il y a plusieurs d√©cennies, le professeur de psychologie Albert Mehrabian publiait le livre _Silent Messages,_ dans lequel il d√©taillait les
composants d‚Äôune communication efficace, en √©tablissant la r√®gle des 7% - 38% - 55%. Selon cette r√®gle, une communication efficace passe √† 7%
par les mots, √† 38% par le ton, et √† 55% par le langage corporel. En d‚Äôautres termes, le composant le plus important est le langage corporel,
mais les sites Internet nous limitent au langage. Avec l‚Äôanimation, nous pouvons donner aux sites Internet la possibilit√© de parler avec les
mains !
:::

Alors repr√©sentons notre "refus" avec l'animation @keyframes headshake¬†:

```scss
@keyframes headshake {
}
```

Nous voulons que notre entr√©e commence et se termine l√† o√π elle devrait, et nous n'avons donc pas besoin de cr√©er des keyframes pour le d√©but
et la fin. En les laissant en dehors des keyframes, notre animation utilisera les valeurs par d√©faut du s√©lecteur. √áa tombe bien,¬†ce dont nous
avons vraiment besoin, ce sont des keyframes pour le mouvement interm√©diaire.

Depuis son √©tat neutre, nous voulons que l'input se d√©place un peu vers la droite, puis vers la gauche, avant de revenir √† sa position √† son
√©tat neutre. Donc, √† 0%, nous sommes dans la position par d√©faut. Puis, √† un quart de l'animation, nous voulons que l'entr√©e soit enti√®rement
√† droite. Et √† 75% dans l'animation, nous voulons qu'elle soit √† l'oppos√© sur la gauche, avant de revenir enfin √† sa position neutre¬†:

```scss
@keyframes headshake {
    25% {
        // enti√®rement √† droite
        transform: translateX();
    }
    75% {
        // enti√®rement √† gauche
        transform: translateX();
    }
}
```

Il ne nous reste plus qu'√† d√©cider √† quel moment nous voulons que notre input hoche la t√™te. √áa ne devrait pas √™tre trop exag√©r√©, juste un
hochement de t√™te net et courtois. Un point de pourcentage ou deux devraient faire l'affaire. Cr√©ons une variable intitul√©e `$shake-intensity`,
r√©glons-la (soyons fous)¬†sur une valeur de 2%, et ajoutons-la √† nos fonctions `translateX()`¬†:

```scss
$shake-intensity: 2%;
@keyframes headshake {
    25% {
        // enti√®rement √† droite
        transform: translateX($shake-intensity);
    }
    75% {
        // enti√®rement √† gauche
        transform: translateX(-$shake-intensity);
    }
}
```

Nous voulons que la position de notre input sur la gauche soit l'inverse de la droite. Nous avons donc juste pr√©fix√© la variable avec un
symbole n√©gatif. D√©sormais, nous devons ajouter nos¬†@keyframes headshake au s√©lecteur `input:not(:focus):invalid.`¬†Nous voulons un hochement
de t√™te brusque et rapide, alors donnons-lui une valeur courte pour sa dur√©e. Quelque chose aux alentours des 100ms devrait faire l'affaire,
au d√©but du moins¬†:

```scss
$cd-danger : #b20a37 ;
$cd-txt: #6300a0;
$shake-intensity: 2%;
.form {
    &__group {
        & input {
            &:active, &:focus {
                border: 2px solid $cd-txt;
            }
            &:not(:focus):invalid {
                color: white;
                border: 2px solid $cd-danger;
                background: $cd-danger;
                animation: headshake 100ms cubic-bezier(.4,.1,.6,.9);
            }
        }
    }
}
@keyframes headshake {
    25% {
        // enti√®rement √† droite
        transform: translateX($shake-intensity);
    }
    75% {
        // enti√®rement √† gauche
        transform: translateX($shake-intensity \* \-1);
    }
}
```

Nous avons √©galement r√©gl√© la fonction `animation-timing-function`¬†pour le headhake sur cubic-bezier(.4,.1,.6,.9), ce qui reste plut√¥t l√©ger¬†:

![Le cubic-b√©zier l√©g√®rement modifi√©](https://user.oc-static.com/upload/2019/08/07/15651814252524_image40.png)

Testons¬†la r√©action que cela nous donne¬†!

![Champs d'email qui devient rouge lorsque l'email n'est pas valide](https://user.oc-static.com/upload/2021/02/10/1612950073298_Gif128.gif)

√áa, c'est un beau hochement de t√™te anthropomorphique¬†! Si beau d'ailleurs qu'on ne s'en lasse pas : on voudrait en voir plus.

OK¬†! Donc, √ßa veut dire que nous devons encore ajouter d'autres keyframes. Pour obtenir deux hochements de t√™te, l'extr√™me droite devrait √™tre
√†... 12,5% et 62,5%... et la gauche devrait √™tre √† 37,5% et 87,5%... c'est √ßa¬†? Et si √ßa ne suffisait toujours pas pour un bon hochement de
t√™te¬†? Et si on avait besoin de trois hochements de t√™te¬†? √áa voudrait dire que l'extr√™me droite serait √†... juste une seconde... passer √†...
euh... vous savez quoi¬†? Il doit y avoir un meilleur moyen. **Parce qu'il y a toujours un meilleur moyen¬†!**

:::note ?
Et ce meilleur moyen, c'est quoi¬†?
:::

La propri√©t√© `animation-iteration-count`¬†! Elle nous permet d'√©crire des keyframes d'un seul cycle d'animation et demander au navigateur de
les r√©p√©ter autant de fois que nous le souhaitons. Cela signifie que nous pouvons faire secouer la t√™te de notre¬†input deux fois, ou deux
cents fois, en changeant une seule valeur¬†:

```scss
$cd-danger : #b20a37 ;
$cd-txt: #6300a0;
$shake-intensity: 2%;
.form {
    &__group {
        & input {
            &:active, &:focus {
                border: 2px solid $cd-txt;
            }
            &:not(:focus):invalid {
                color: white;
                border: 2px solid $cd-danger;
                background: $cd-danger;
                animation: headshake 100ms cubic-bezier(.4,.1,.6,.9);
                animation-iteration-count: 3;
            }
        }
    }
}
@keyframes headshake {
    25% {
        // enti√®rement √† droite
        transform: translateX($shake-intensity);
    }
    75% {
        // enti√®rement √† gauche
        transform: translateX($shake-intensity \* \-1);
    }
}
```

Il y a un principe d'√©criture appel√© la ¬´¬†r√®gle de trois¬†¬ª selon laquelle une chose qui arrive trois fois serait plus efficace et impactante.
Que ce soit plus dramatique, plus dr√¥le ou plus percutant (vous avez vu, je l'ai utilis√©e ici). Alors nous avons donn√© une valeur de trois √†
la propri√©t√© `animation-iteration-count`.

![Champs d'email qui devient rouge et qui tremble lorsque l'email n'est pas valide](https://user.oc-static.com/upload/2021/02/10/16129502050779_Gif129.gif)

Meh. Je ne suis pas convaincue. Deux c'√©tait tr√®s bien aussi. R√©duisons donc le nombre d'it√©rations √† 2 et testons √† nouveau l'animation. Et
quand on les voit encha√Æn√©s comme √ßa, 2% d'intensit√© pour le hochement semble √©galement un peu trop. Descendons √† 1% pendant qu'on y est¬†:

```scss
$cd-danger : #b20a37 ;
$cd-txt: #6300a0;
$shake-intensity: 1%;
.form {
    &__group {
        & input {
            &:active, &:focus {
                border: 2px solid $cd-txt;
            }
            &:not(:focus):invalid {
                color: white;
                border: 2px solid $cd-danger;
                background: $cd-danger;
                // animation-iteration-count est directement int√©gr√© dans la propri√©t√© raccourcie animation :
                animation: headshake 100ms cubic-bezier(.4,.1,.6,.9) 2;
            }
        }
    }
}
@keyframes headshake {
    25% {
        // enti√®rement √† droite
        transform: translateX($shake-intensity);
    }
    75% {
        // enti√®rement √† gauche
        transform: translateX($shake-intensity \* \-1);
    }
}
```

O√π est pass√© `animation-iteration-count` ? Comme pour les autres propri√©t√©s d'animation, nous l'avons inclus dans la propri√©t√© d'animation
abr√©g√©e, plut√¥t que d'√©crire la version explicite. Nous avons donc ajout√© le chiffre 2 √† la liste des valeurs pour l'animation, et maintenant
notre entr√©e devrait hocher la t√™te deux fois.

Cette valeur pour la dur√©e de l'animation s'applique √† la dur√©e d'un seul cycle d'animation. Cela signifie que notre animation de hochement de
t√™te, avec une dur√©e assign√©e de 100ms et un nombre d'it√©rations de 2, prendra un total de 200ms √† se terminer¬†:

![Champs d'email qui devient rouge et qui tremble lorsque l'email n'est pas valide](https://user.oc-static.com/upload/2021/02/10/16129502187277_Gif130.gif)

√áa c'est la bonne dur√©e pour un hochement de t√™te¬†! üéâ

Avec `animation-iteration-count`, nous pouvons nous √©pargner beaucoup de calcul mental et de keyframes compliqu√©s en √©crivant un seul cycle
d'animation et en demandant au navigateur de le rejouer autant de fois que nous le voulons. Bien plus propre, et bien plus facile √† retoucher
et √† affiner.

:::note ?
Mais comment faire si¬†on¬†veut qu'une animation joue en boucle √† l'infini¬†?
:::

### Cr√©ez votre premier loader

Les sites web appellent souvent le serveur en arri√®re-plan pour demander des donn√©es, comme une image, un texte, une donn√©e, etc. Pendant que
la page attend la r√©ponse du serveur, elle affiche un espace r√©serv√©.

La r√©ponse du serveur ne prend parfois qu'une fraction de seconde ou beaucoup plus, selon la complexit√© de la demande, la taille des donn√©es
transf√©r√©es et la vitesse de connexion. Or, sur la plupart des interfaces, nous ne connaissons pas le temps n√©cessaire pour obtenir une
r√©ponse du serveur. La barre de progression du chapitre pr√©c√©dent n'est pas forc√©ment adapt√©e √† cet usage. Nous allons donc construire quelque
chose de plus g√©n√©rique¬†: un loader !

Pour commencer, cr√©ons une `<div>`¬†avec une classe `.load,`¬†et cinq divs enfants int√©gr√©es, chacune avec une classe de `.load__bar assign√©e` :

```html
<html>
    <div class="container">
        <div class="load">
            <div class="load__bar"></div>
            <div class="load__bar"></div>
            <div class="load__bar"></div>
            <div class="load__bar"></div>
            <div class="load__bar"></div>
        </div>
    </div>
</html>
```

Maintenant que nous avons construit nos barres, nous devons les styliser pour qu'elles ressemblent √†... eh bien... des barres¬†! Attribuons √†
`.load`¬†les propri√©t√©s de layout appropri√©es, et configurons les dimensions pour `.load__bar`, tout en leur donnant un joli `background-color`
vert menthe¬†:

```scss
$cd-bars: #15DEA5;
$size: 3vh;
.load {
    width: $size*10;
    height: $size*7.5;
    display: flex;
    justify-content: space-evenly;
    &__bar {
        background-color: #15DEA5;
        height: 100%;
        width: $size;
    }
}
```

En v√©rifiant dans notre navigateur, nous d√©couvrons une magnifique rang√©e de cinq barres vert menthe¬†!

![Les barres sont immobiles](https://user.oc-static.com/upload/2019/08/07/15651820975803_image12.png)

Super ! Mais pour le moment elles sont juste l√†, immobiles...

Nous sommes dans un cours d'animation ! Et nous voulons offrir √† nos utilisateurs un peu de mouvement pour √©veiller leur int√©r√™t pendant
qu'ils patientent. Alors cr√©ons un ensemble de @keyframes appel√©s _bars_ et utilisons la fonction de transformation `scaleY()` pour animer
l'√©chelle verticale de ces barres dans le temps, en commen√ßant √† 50% et en terminant √† 100%¬†:

```scss
@keyframes bars {
    0% {
        transform: scaleY(0.5);
    }
    100% {
        transform: scaleY(1.0);
    }
}
```

Bien s√ªr, pour que nos keyframes aient un effet sur nos barres et commencent √† animer leur √©chelle, nous devons d'abord les appliquer au
s√©lecteur .bars. Alors configurons une animation √† l'aide de @keyframes bars et une dur√©e de 1000ms¬†:

```scss
$cd-bars: #15DEA5;
$size: 3vh;
$anim-dur: 1000ms;
.load {
    width: $size*10;
    height: $size*7.5;
    display: flex;
    justify-content: space-evenly;
    &__bar {
        background-color: $cd-bars;
        height: 100%;
        width: $size;
        animation: bars $anim-dur;
    }
}
@keyframes bars {
    0% {
        transform: scaleY(0.5);
    }
    100% {
        transform: scaleY(1.0);
    }
}
```

La variable `$anim-dur`¬†correspond √† la dur√©e de notre animation. Comme nous l'avons vu, nous pouvons profiter du Sass pour cr√©er des
variables, ce qui nous permet d'ajuster nos valeurs un peu plus facilement, si n√©cessaire. Maintenant, nos barres devraient passer de la
moiti√© de leur taille verticale √† leur hauteur totale en une seconde¬†:

![Barres anim√©es de loading](https://user.oc-static.com/upload/2021/02/10/16129502416335_Gif131.gif)

C'est parfait : √ßa fonctionne comme ce qu'on attendait... mais, vous me connaissez. C'est encore loin de me suffire... Rien de tr√®s fun dans
cette animation pour le moment. Souvenez-vous des 12 principes : ajouter un peu de complexit√© √† nos animations contribue grandement √† les
rendre attrayantes pour nos visiteurs. Nous pouvons alterner leur croissance, pour qu'elles grandissent les unes apr√®s les autres, un peu
comme une vague.

√Ä votre avis, quel est le meilleur moyen de cr√©er des animations qui se d√©clenchent de mani√®re altern√©e ?

La propri√©t√© `animation-delay`, √ßa vous dit quelque chose¬†?

Nous avons cinq barres, donc nous avons besoin de cinq s√©lecteurs de modification, chacun avec un d√©lai d'animation assign√© l√©g√®rement plus
long.

On _pourrait_ les √©crire manuellement, on pourrait faire beaucoup de choses. Mais pourquoi le faire alors que nous pourrions utiliser Sass
pour g√©rer cette t√¢che r√©p√©titive et incr√©mentale¬†? Configurons une boucle Sass @for pour l'it√©ration √† travers un ensemble de nombres allant
de un √† cinq, en incr√©mentant le nom du s√©lecteur et le d√©lai de l'animation¬†:

```scss
$cd-bars: #15DEA5;
$size: 3vh;
$num-bars: 5
$anim-dur: 1000ms;
$anim-delay: $anim-dur / $num-bars;
.load {
    width: $size*10;
    height: $size*7.5;
    display: flex;
    justify-content: space-evenly;
    &__bar {
        background-color: $cd-bars;
        height: 100%;
        width: $size;
        animation: bars $anim-dur;
        @for $i from 1 through $num-bars {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
        }
    }
}
```

Chaque it√©ration √† travers la boucle produira un nouveau s√©lecteur, avec le num√©ro d'index de l'it√©ration utilis√© dans son nom, ainsi que
pour multiplier le `$anim-delay`¬†et cr√©er un d√©lai de lancement qui sera incr√©ment√© au fur et √† mesure. `$anim-delay`¬†est r√©gl√© sur la dur√©e
de l'animation divis√©e par le nombre de barres.

Ainsi, lors de la premi√®re it√©ration, le modificateur sera nomm√© `.load__bar--1`¬†et aura un retard de 200ms, le second sera `.load__bar--2`
avec un retard de 400ms, et ainsi de suite. En v√©rifiant le CSS compil√©, nous voyons que les s√©lecteurs suivants viennent d'√™tre cr√©√©s¬†:

```scss
.load__bar--1 {
    animation-delay: 200ms;
}
.load__bar--2 {
    animation-delay: 400ms;
}
.load__bar--3 {
    animation-delay: 600ms;
}
.load__bar--4 {
    animation-delay: 800ms;
}
.load__bar--5 {
    animation-delay: 1000ms;
}
```

Maintenant, il ne nous reste plus qu'√† appliquer nos nouveaux modificateurs aux divs appropri√©es dans notre HTML¬†:

```html
<div class="container">
    <div class="load">
        <div class="load__bar load__bar--1"></div>
        <div class="load__bar load__bar--2"></div>
        <div class="load__bar load__bar--3"></div>
        <div class="load__bar load__bar--4"></div>
        <div class="load__bar load__bar--5"></div>
    </div>
</div>
```

J'aimerais que nous prenions un instant pour admirer nos barres dans le navigateur¬†:

![Barre anim√©es loading pas synchronis√©es](https://user.oc-static.com/upload/2021/02/10/1612950255976_Gif132.gif)

Nous avons ajout√© tous nos d√©lais, mais nous avons oubli√© de r√©gler le mode de remplissage. R√©sultat : nos barres reviennent √† leur taille
initiale √† la fin de l'animation.

:::note ?
Mais comment faire pour √©viter ce probl√®me ?
:::

R√©glons donc le mode `animation-fill-mode`¬†sur backwards pour √©tendre les valeurs de d√©part de l'animation pendant le d√©lai :

```scss
$cd-bars: #15DEA5;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    width: $size*10;
    height: $size*7.5;
    display: flex;
    justify-content: space-evenly;
    &__bar {
        background-color: $cd-bars;
        height: 100%;
        width: $size;
        animation: bars $anim-dur backwards;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
        }
    }
}
```

Et voil√†¬†! Admirez nos magnifiques barres ondulantes¬†!

![Barres anim√©es ondulation](https://user.oc-static.com/upload/2021/02/10/16129502689305_Gif133.gif)

Du moins, admirez au moins UN cycle de nos barres ondulantes... Maintenant, r√©p√©tons ce cycle, vers l'infini et au del√† ! üë©‚ÄçüöÄ

Pour cela, utilisons `animation-iteration-count`, qui est parfait pour ce genre de situation. Mais combien de cycles devons-nous utiliser
dans les r√©glages pour le nombre d'it√©rations ?

### Faites boucler vos animations √† l'infini

Nous ne savons pas combien de temps va s'√©couler entre le moment o√π notre navigateur envoie sa requ√™te au serveur et la r√©ception des donn√©es
en r√©ponse. Et cela signifie que nous ne savons jamais vraiment combien de fois nous aurons besoin de r√©p√©ter l'animation de nos barres.

Nous pourrions leur attribuer un chiffre tr√®s √©lev√© comme 9999.... mais c'est une solution de contournement un peu facile et pas du tout
optimis√©e...

Plut√¥t que de sp√©cifier un nombre sp√©cifique pour le nombre d'it√©rations, **nous pouvons aussi dire au navigateur de lire l'animation √†
l'infini en lui assignant le mot cl√© ¬´¬†infinite¬†¬ª √† la place** :

```scss
$cd-bars: #15DEA5;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    width: $size*10;
    height: $size*7.5;
    display: flex;
    justify-content: space-evenly;
    &__bar {
        background-color: $cd-bars;
        height: 100%;
        width: $size;
        animation: bars $anim-dur backwards infinite;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
        }
    }
}
```

Et _maintenant_ voici notre animation r√©p√©tant √† l'infini une s√©rie de barres¬†!

![Barres anim√©es iteration count](https://user.oc-static.com/upload/2021/02/10/16129502897753_Gif134.gif)

Maintenant qu'elles tournent en boucle, nous avons un probl√®me tr√®s similaire √† celui que nous avions avant d'ajouter le mode de remplissage
backwards √† notre animation¬†: les barres passent subitement de leur taille finale √† leur taille initiale. Sauf que cette fois, c'est parce que
les valeurs de d√©but et de fin de la boucle sont diff√©rentes. Notre cycle devrait en fait commencer par des barres plus petites, qui
grandissent jusqu'√† leur taille maximale au milieu de l'animation, avant de r√©tr√©cir √† leur taille initiale √† la fin.

Pour cela, nous _pourrions_ ajouter un keyframe suppl√©mentaire au milieu de l'animation de nos barres. Mais encore une fois... nous n'allons
pas le faire. Ici aussi, il existe une meilleure solution. Et si nous voulions utiliser nos @keyframes bars ailleurs sur notre page, mais
plut√¥t que de les animer en boucle, nous voulions qu'elles ne grandissent qu'une fois¬†? Si nous ajoutions ce keyframe suppl√©mentaire √†
l'animation de nos barres, nous serions en train de modifier notre animation originale au service d'un cas particulier, et √©ventuellement de
nous emp√™cher de l'utiliser dans d'autres animations sur notre site.

√Ä la place, **nous pouvons utiliser la propri√©t√© animation-direction pour transformer nos @keyframes en une boucle invisible**, m√™me si les
valeurs de d√©but et de fin des keyframes sont diff√©rentes¬†!

La valeur par d√©faut pour animation-direction, celle qui est assign√©e si nous ne lui donnons pas explicitement une autre valeur, est ¬´¬†normal¬†¬ª.
Comme vous auriez pu le supposer, ceci rejoue une animation normalement, c'est-√†-dire du d√©but √† la fin¬†:

```scss
$cd-bars: #15DEA5;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    width: $size*10;
    height: $size*7.5;
    display: flex;
    justify-content: space-evenly;
    &__bar {
        background-color: $cd-bars;
        height: 100%;
        width: $size;
        animation: bars $anim-dur backwards infinite;
        animation-direction : normal;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
        }
    }
}
```

G√©n√©ralement, il est tr√®s rare de voir animation-direction avec la valeur ¬´¬†normal¬†¬ª, car il s'agit d'une option qui donne le m√™me r√©sultat
que si nous ne l‚Äôavions pas pr√©cis√© du tout :

![Barres ondulantes rythm√©es](https://user.oc-static.com/upload/2021/02/10/16129503060738_Gif135.gif)

L√† o√π l'utilisation de animation-direction commence √† devenir tr√®s utile, c'est avec le mot cl√© ¬´¬†reverse¬†¬ª. Et qu'est-ce qu'on obtient en
attribuant ¬´¬†reverse¬†¬ª √† animation-direction¬†? Vous vous en doutez peut-√™tre. L'animation est lue √† l'envers, en commen√ßant par la fin et en
la lisant √† l'envers jusqu'au d√©but :

```scss
$cd-bars: #15DEA5;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    width: $size*10;
    height: $size*7.5;
    display: flex;
    justify-content: space-evenly;
    &__bar {
        background-color: $cd-bars;
        height: 100%;
        width: $size;
        animation: bars $anim-dur backwards infinite;
        animation-direction: reverse;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
        }
    }
}
```

Et maintenant, l'animation de nos barres va √™tre jou√©e √† l'envers, ce qui n'est pas exactement ce que nous recherchons¬†:

![Barres ondulantes reverse](https://user.oc-static.com/upload/2021/02/10/16129503188664_Gif136.gif)

Non seulement animation-direction nous permet de jouer des animations en avant et en arri√®re, mais elle **nous permet √©galement de jouer des
animations avec des allers-retours**, de sorte que la direction de l'animation alterne avec chaque it√©ration, d'abord avec une lecture du
d√©but √† la fin, puis en alternant avec une lecture de la fin au d√©but. √áa pourrait √™tre pas mal dans le cas de notre loader.

Renseignons donc la valeur **alternate** :

```scss
$cd-bars: #15DEA5;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    width: $size*10;
    height: $size*7.5;
    display: flex;
    justify-content: space-evenly;
    &__bar {
        background-color: $cd-bars;
        height: 100%;
        width: $size;
        animation: bars $anim-dur backwards infinite;
        animation-direction: alternate;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
        }
    }
}
```

Et maintenant, nous avons une animation en boucle infinie et invisible !

![Barres ondulantes optimales](https://user.oc-static.com/upload/2021/02/10/16129503320031_Gif137.gif)

Nous voil√† sur le bon chemin¬†! La fonction timing-function pr√©voit par d√©faut diff√©rentes pentes d'easing par rapport √† ses profils
d'acc√©l√©ration et de d√©c√©l√©ration, ce qui cr√©e un effet d'√†-coups entre les cycles¬†:

![Le cubic-b√©zier de l'animation](https://user.oc-static.com/upload/2019/08/07/1565183220894_image23.png)

Au lieu de s'en tenir aux valeurs par d√©faut de la fonction animation-timing-function, assignons-lui quelque chose de plus sym√©trique, comme
le profil ease-in-out¬†:

![Le cubic-b√©zier que nous souhaitons avoir](https://user.oc-static.com/upload/2019/08/07/15651832814153_image39.png)

Et pendant que nous modifions le timing de notre animation, profitons-en pour abr√©ger tout cela en utilisant le mot cl√© ‚Äúanimation‚Äù. Encore
une fois, il suffit d‚Äôajouter la valeur alternate √† la liste des valeurs de la propri√©t√© animation¬†:

```scss
$cd-bars: #15DEA5;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    &__bar {
        background-color: $cd-bars;
        animation: bars $anim-dur backwards infinite ease-in-out alternate;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
        }
    }
}
```

Maintenant, notre boucle devrait √™tre beaucoup plus fluide¬†:

![Barres ondulantes encore plus fluides](https://user.oc-static.com/upload/2021/02/10/16129503441908_Gif138.gif)

Joliiiii ü§ì¬†! Alors, on s'arr√™te l√†¬†? ... Non, pas encore.

Pour le moment, l'animation reste quand m√™me un peu ennuyeuse. Essayons de rendre l'ensemble un peu plus attrayant en ajoutant un peu plus de
complexit√© visuelle. Peut-√™tre que nous pouvons ajouter un autre ensemble de barres juste en dessous, et les animer en miroir ? Pour cela,
nous pouvons simplement dupliquer la `div .load`¬†et son contenu¬†:

```html
<div class="container">
    <div class="load">
        <div class="load__bar load__bar--1"></div>
        <div class="load__bar load__bar--2"></div>
        <div class="load__bar load__bar--3"></div>
        <div class="load__bar load__bar--4"></div>
        <div class="load__bar load__bar--5"></div>
    </div>
    <div class="load">
        <div class="load__bar load__bar--1"></div>
        <div class="load__bar load__bar--2"></div>
        <div class="load__bar load__bar--3"></div>
        <div class="load__bar load__bar--4"></div>
        <div class="load__bar load__bar--5"></div>
    </div>
</div>
```

Voyons o√π √ßa nous m√®ne :

![Barres ondulantes x2 non synchronis√©es](https://user.oc-static.com/upload/2021/02/10/16129503569036_Gif139.gif)

Mmm... c'est _plut√¥t_ cool... Mais tentons de pimenter tout √ßa. Plut√¥t que de reproduire l'ensemble de barres du haut, essayons de faire en
sorte que l'ensemble de barres du bas se fonde dans celui du haut, de fa√ßon √† ce que la barre du haut s'agrandisse et celle du bas r√©tr√©cisse.
Un peu comme une synchronisation invers√©e. Il nous faut une boucle continue pour l'animation, mais en sens inverse.

Dites donc, ne serait-ce pas g√©nial s'il y avait un mot cl√© pour la propri√©t√© animation-direction qui jouerait les animations dans des
directions altern√©es, mais √† l'envers¬†? Bon, vous vous doutez s√ªrement maintenant que nous ne faisons pas les choses au hasard¬†!

La valeur s'appelle ¬´¬†alternate-reverse¬†¬ª. Afin d'appliquer la¬†valeur `alternate-reverse`¬†√† notre deuxi√®me ensemble de barres, nous devrons
cr√©er un nouvel ensemble de modificateurs, ce qui est possible depuis notre boucle @for.

Au sein de chaque boucle, nous demanderons de cr√©er un deuxi√®me s√©lecteur, en utilisant la m√™me structure de d√©nomination de base, mais en
ajoutant un suffixe pour indiquer que sa direction est invers√©e. Pendant que nous y sommes, donnons aussi un peu plus de contraste visuel et
ajoutons une couleur diff√©rente √† nos barres invers√©es¬†:

```scss
$cd-bars: #15DEA5;
$cd-bars-inv: #0E397F;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    &__bar {
        animation: bars $anim-dur backwards infinite ease-in-out alternate;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
            &--#{$i}-inv {
                animation-delay: $anim-delay * $i;
                animation-direction: alternate-reverse;
                background-color: $cd-bars-inv;
            }
        }
    }
}
```

Notre CSS compil√© a d√©sormais deux ensembles de modificateurs, un pour la ligne du haut, un autre pour le bas¬†:

```scss
.load__bar--1 {
    animation-delay: 200ms;
}
.load__bar--1-inv {
    animation-delay: 200ms;
    animation-direction: alternate-reverse;
    animation-fill-mode: forwards;
    background: #0E397F;
}
.load__bar--2 {
    animation-delay: 400ms;
}
.load__bar--2-inv {
    animation-delay: 400ms;
    animation-direction: alternate-reverse;
    animation-fill-mode: forwards;
    background: #0E397F;
}
.load__bar--3 {
    animation-delay: 600ms;
}
.load__bar--3-inv {
    animation-delay: 600ms;
    animation-direction: alternate-reverse;
    animation-fill-mode: forwards;
    background: #0E397F;
}
.load__bar--4 {
    animation-delay: 800ms;
}
.load__bar--4-inv {
    animation-delay: 800ms;
    animation-direction: alternate-reverse;
    animation-fill-mode: forwards;
    background: #0E397F;
}
.load__bar--5 {
    animation-delay: 1000ms;
}
.load__bar--5-inv {
    animation-delay: 1000ms;
    animation-direction: alternate-reverse;
    animation-fill-mode: forwards;
    background: #0E397F;
}
```

Rempla√ßons les modificateurs pour notre deuxi√®me ensemble de barres dans le HTML¬†:

```html
<div class="container">
    <div class="load">
        <div class="load__bar load__bar--1"></div>
        <div class="load__bar load__bar--2"></div>
        <div class="load__bar load__bar--3"></div>
        <div class="load__bar load__bar--4"></div>
        <div class="load__bar load__bar--5"></div>
    </div>
    <div class="load">
        <div class="load__bar load__bar--1-inv"></div>
        <div class="load__bar load__bar--2-inv"></div>
        <div class="load__bar load__bar--3-inv"></div>
        <div class="load__bar load__bar--4-inv"></div>
        <div class="load__bar load__bar--5-inv"></div>
    </div>
</div>
```

Et maintenant, v√©rifions comment nos barres synchronis√©es de fa√ßon inverse s'affichent dans notre navigateur¬†:

![Barres ondulantes synchronis√©es](https://user.oc-static.com/upload/2021/02/10/16129503736544_Gif140.gif)

Beaucoup mieux¬†! Nous avons ajout√© une sorte de mouvement secondaire √† notre animation en faisant en sorte que nos deux s√©ries de barres
soient compl√©mentaires...

### Faites une pause

Nos barres de chargement sont pas mal du tout. Nous pourrions tr√®s bien dire qu'elles sont termin√©es et passer √† autre chose. Mais qu'en
est-il de ces pauvres utilisateurs qui n‚Äôont pas encore la fibre¬†? Qui sait combien de temps ils devront regarder ces barres avant d'obtenir
une r√©ponse du serveur¬†? Ayons piti√© de leurs pauvres √¢mes et faisons quelque chose pour rendre l'animation un peu plus interactive et les
divertir pendant qu'ils patientent.

Surprise ! Il y a une propri√©t√© d'animation CSS que nous n'avons pas encore abord√©e. Plut√¥t que de contr√¥ler la direction ou le d√©lai d'une
animation, cette propri√©t√© permet de contr√¥ler si l'animation est lue ou non. La propri√©t√© **animation-play-state** permet de mettre en pause
ou de jouer des animations en utilisant respectivement les mots cl√©s ¬´¬†paused¬†¬ª ou ¬´¬†running¬†¬ª.

Supposons que nous disposions d'une div toute simple avec la classe .spin¬†:

```html
<div class="container">
    <div class="spin"></div>
</div>
```

Quelques @keyframes et propri√©t√©s d'animation suffisent pour la faire tourner √† l'infini, chaque rotation prenant trois secondes √† se terminer :

```scss
.spin {
    background-color: #15DEA5;
    width: 30vh;
    height: 30vh;
    animation: spin 3s linear infinite;
}
@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}
```

![Carr√© qui pivote](https://user.oc-static.com/upload/2021/02/10/16129505611161_Gif141.gif)

Elle tourne, tourne, tourne... Plus rien ne peut l'arr√™ter, ni l'acc√©l√©rer ou lui faire quoi que ce soit, √† vrai dire. Pour l'instant, nous
n'avons vu que comment mettre nos animations en mouvement, mais une fois qu'elles sont en marche, nous n'avons plus qu'√† attendre qu'elles se
terminent. Mais la propri√©t√© `animation-play-state`¬†nous offre une commande toute pr√™te que nous pouvons utiliser pour lire et mettre en pause
nos animations.

Configurons notre bo√Æte pour qu'elle commence en pause, mais que la lecture de l'animation commence au survol de la souris. Pour mettre en
pause notre bo√Æte en rotation, nous devons r√©gler `animation-play-state`¬†sur ¬´¬†paused¬†¬ª, ou simplement ajouter le mot cl√© ¬´¬†paused¬†¬ª √† la
propri√©t√© d'animation abr√©g√©e¬†:

```scss
.spin {
    background-color: #15DEA5;
    width: 30vh;
    height: 30vh;
    animation: spin 3s linear infinite paused;
}
@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}
```

Maintenant, notre bo√Æte ne bouge plus, m√™me si notre animation de rotation ¬´¬†spin¬†¬ª lui est appliqu√©e¬†:

![L'animation ne fonctionne plus](https://user.oc-static.com/upload/2019/08/07/15651894112127_image34.png)

Notre animation commence directement en statut pause. Pour faire bouger notre animation, nous avons besoin d'ajouter un bouton de lecture, ce
que nous allons faire en ajoutant un pseudos√©lecteur `:hover`¬†√† notre s√©lecteur `.spin`, dans lequel l‚Äô√©tat de l‚Äôanimation sera sur ¬´¬†running¬†¬ª¬†:

```scss
.spin {
    background-color: #15DEA5;
    width: 30vh;
    height: 30vh;
    animation: spin 3s linear infinite paused;
    &:hover {
        animation-play-state: running;
    }
}
@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}
```

Maintenant, chaque fois que nous survolerons notre bo√Æte, elle reprendra l'animation l√† o√π elle s'√©tait arr√™t√©e, et une fois le survol
termin√©, elle fera une pause l√† o√π elle √©tait, pour recommencer son animation si nous la survolons √† nouveau¬†:

![Carr√© pivotant au passage de la souris](https://user.oc-static.com/upload/2021/02/10/16129505768598_Gif142.gif)

`animation-play-state` donne √† nos utilisateurs la possibilit√© d'interagir avec nos animations üî•. Ce qui pourrait √™tre plut√¥t cool, √†
condition de ne pas en faire trop. Utilisons `animation-play-state`¬†pour transformer nos barres de chargement en un petit jeu qui va aider
nos utilisateurs √† patienter en attendant la r√©ponse du serveur.

Pour l'instant, nos deux ensembles de barres sont verrouill√©s l'un et l'autre dans une sorte de danse¬†:

![Barres ondulantes synchronis√©es](https://user.oc-static.com/upload/2021/02/10/1612950588033_Gif143.gif)

Et si on changeait ces d√©lais sur la deuxi√®me s√©rie de barres, pour que chacune ait un temps de d√©part al√©atoire¬†?

![Barres ondulantes d√©lai](https://user.oc-static.com/upload/2021/02/10/16129506197045_Gif144.gif)

Maintenant, tout est d√©synchronis√©¬†! Mais cela nous permet d'int√©grer une certaine interactivit√© pour nos utilisateurs et de les divertir un
peu pendant qu'ils attendent que les choses se chargent.

Nous pourrions utiliser la pseudoclasse :hover pour agir comme un bouton pause. Mais l‚Äôutilisateur pourra resynchroniser les deux ensembles
de barres en survolant chaque barre, jusqu'√† ce qu'elle soit synchronis√©e avec son acolyte. La premi√®re √©tape consiste √† donner des d√©lais
al√©atoires sur les barres invers√©es, ce qui peut se faire via la fonction `random()`¬†de Sass¬†:

```scss
$cd-bars: #15DEA5;
$cd-bars-inv: #0E397F;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    &__bar {
        animation: bars $anim-dur backwards infinite ease-in-out alternate;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
            &--#{$i}-inv {
                animation-delay: $anim-delay * $i + random(100)*15ms;
                animation-direction: alternate-reverse;
                animation-fill-mode: forwards;
                background-color: $cd-bars-inv;
            }
        }
    }
}
```

La fonction al√©atoire g√©n√®re un entier compris entre 1 et le nombre choisi comme argument, qui dans notre cas de figure est 100. Nous
g√©n√©rons donc un nombre al√©atoire entre 1 et 100, puis nous le multiplions par 15ms et l'ajoutons √† notre retard incr√©mentiel, cr√©ant ainsi
un animation-delay al√©atoire pour chacune des barres invers√©es¬†:

![Barres ondulantes d√©lai al√©atoire](https://user.oc-static.com/upload/2021/02/10/16129506320049_Gif145.gif)

Maintenant, tout ce que nous avons √† faire est d'ajouter notre bouton pause en assignant √† `.load__bar`¬†une pseudoclasse `:hover`¬†permettant
de r√©gler animation-play-state sur ¬´¬†paused¬†¬ª¬†:

```scss
$cd-bars: #15DEA5;
$cd-bars-inv: #0E397F;
$size: 3vh;
$anim-dur: 1000ms;
$anim-delay: $anim-dur / 5;
.load {
    &__bar {
        animation: bars $anim-dur backwards infinite ease-in-out alternate;
        @for $i from 1 through 5 {
            &--#{$i} {
                animation-delay: $anim-delay * $i;
            }
            &--#{$i}-inv {
                animation-delay: $anim-delay * $i + random(100)*15ms;
                animation-direction: alternate-reverse;
                animation-fill-mode: forwards;
                background-color: $cd-bars-inv;
                &:hover {
                    animation-play-state: paused;
                }
            }
        }
    }
}
```

Pendant que nous y sommes, ajoutons quelques¬†instructions directement dans notre HTML.

```html
<div class="container">
    <span>
        Survolez les barres bleues pour les synchroniser</span>
    <div class="load">
        <div class="load__bar load__bar--1"></div>
        <div class="load__bar load__bar--2"></div>
        <div class="load__bar load__bar--3"></div>
        <div class="load__bar load__bar--4"></div>
        <div class="load__bar load__bar--5"></div>
    </div>
    <div class="load">
        <div class="load__bar load__bar--1-inv"></div>
        <div class="load__bar load__bar--2-inv"></div>
        <div class="load__bar load__bar--3-inv"></div>
        <div class="load__bar load__bar--4-inv"></div>
        <div class="load__bar load__bar--5-inv"></div>
    </div>
    <span>avec leurs √©quivalents verts au dessus.</span>
</div>
```

Et c'est tout¬†! Maintenant, nos barres vont d√©marrer de fa√ßon al√©atoire, et c'est l'utilisateur qui pourra les resynchroniser en les
survolant avec sa souris :

![Barres ondulantes jeu survol souris](https://user.oc-static.com/upload/2021/02/15/16133818585532_Gif146.gif)

Pas mal du tout !

De quoi tenir votre utilisateur alerte pour un petit moment.

Si vous voulez les manipuler directement, jetez un ≈ìil [√† mon CodePen](https://codepen.io/atoulmet/pen/WNeEWdx).

_Essayez de changer le temps de anim-delay üòÄ_

### En r√©sum√©

- nous pouvons r√©p√©ter un ensemble de keyframes autant de fois que nous le souhaitons en utilisant la propri√©t√© `animation-iteration-count`,
avec le nombre de cycles comme valeur ;
- nous pouvons r√©gler nos keyframes pour qu'ils se r√©p√®tent √† l'infini en utilisant la propri√©t√© `animation-iteration-count`¬†avec le mot cl√©
¬´¬†infinite¬†¬ª ;
- la propri√©t√© `animation-direction`¬†nous permet de lire un ensemble de keyframes normalement, avec le mot cl√© ¬´¬†normal ¬ª ;
- la propri√©t√© `animation-direction`¬†nous permet de lire un ensemble de keyframes vers l'arri√®re avec le mot cl√© ¬´¬†reverse¬†¬ª ;
- la propri√©t√© `animation-direction`¬†nous permet de lire un ensemble de keyframes avec des allers-retours avec le mot cl√© ¬´¬†alternate¬†¬ª ;
- et enfin, la propri√©t√© `animation-direction`¬†nous permet de lire un ensemble de keyframes avec des allers-retours, mais en commen√ßant par
la fin avec le mot cl√© ¬´¬†alternate-reverse¬†¬ª ;
- nous pouvons mettre en pause une animation avec keyframe en assignant √† la propri√©t√© `animation-play-state`¬†la valeur r√©gl√©e sur ¬´¬†paused¬†¬ª ;
- nous pouvons reprendre la lecture d'une animation avec keyframe en assignant la propri√©t√© `animation-play-state`¬†avec la valeur r√©gl√©e sur
¬´¬†running¬†¬ª.

_Nous avons maintenant fait un tour d‚Äôensemble plut√¥t utile de l'animation CSS et des propri√©t√©s de transition¬†! Toutes les propri√©t√©s que le
CSS peut vous offrir sont d√©sormais √† votre disposition pour l'animation. Vous avez s√ªrement h√¢te de les mettre en pratique pour donner vie √†
vos pages. Mais avant de conclure, nous allons apprendre √† ma√Ætriser un nouvel outil qui nous aidera √† construire et peaufiner plus rapidement
vos animations en revenant √† DevTools. Rendez-vous au chapitre suivant !_

-----

## Affinez vos animations CSS avec DevTools

[Affinez vos animations CSS avec DevTools - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340942-affinez-vos-animations-css-avec-devtools)

<Vimeo vimeoId="508777445" />

<br />

Tout au long de ce cours, nous avons construit beaucoup de transitions et d'animations. Et, pour chacune d'entre elles, nous sommes revenus
plusieurs fois sur le rythme, les acc√©l√©rations, les transformations de nos animations.

"C'est un peu trop rapide, trop lent, trop X, trop Y"... Maintenant c'est mieux/c'est bien/c'est id√©al/c'est la perfection incarn√©e/ ‚û°Ô∏èins√©rez
ici une d√©claration positive.

Vous vous √™tes s√ªrement demand√© d‚Äôo√π sortaient ces propositions de transitions de X secondes¬†? Est-ce que ces X secondes ne devraient pas √™tre
Y secondes¬†? Mais est-ce que rendre un nombre de millisecondes soi-disant al√©atoire plus rapide/plus lent permet encore d'am√©liorer l'effet
obtenu ?

Vraiment¬†?

Et la r√©ponse est... peut-√™tre... ü§∑‚Äç‚ôÄÔ∏è ?

### Ajustez vos animations par l'it√©ration et les bonnes pratiques

Instant r√©v√©lation : la ¬´¬†perfection¬†¬ª n'existe pas. Chaque personne a un point de vue diff√©rent. Mais si nos pr√©f√©rences peuvent para√Ætre
assez vari√©es, elles tendent quand m√™me √† √™tre regroup√©es autour de certaines valeurs. Une personne pense peut-√™tre qu'un menu doit mettre
500ms pour s'ouvrir, alors que quelqu'un d'autre peut pr√©f√©rer 400ms. Mais nous aurions probablement du mal √† trouver quelqu'un qui pense
qu'il faudrait 15 secondes pour que la m√™me animation soit lue.

Alors, comment faire pour que nos animations soient ¬´¬†parfaites¬†¬ª¬†? Comment pouvons-nous savoir quelle devrait √™tre leur dur√©e _id√©ale_¬†? Et
lorsque cette dur√©e ne semble toujours pas ¬´¬†parfaite¬†¬ª, savons-nous de combien nous devons la ralentir ou l'acc√©l√©rer¬†?

La r√©ponse √† ces questions vient en partie de l'exp√©rience et de la pratique. Au fil du temps, l'exp√©rience en tant qu'animateurs, concepteurs
ou programmateurs, permet de d√©velopper une intuition¬†de ce qui est ¬´¬†parfait¬†¬ª. En animation, tout comme dans tout ce qui est en rapport
avec la programmation, c‚Äôest en pratiquant que l‚Äôon apprend.

Vous vous souvenez quand je vous disais que j‚Äôessayais de ne jamais faire une animation de plus de 300ms dans mes √©l√©ments fonctionnels ? Il
s‚Äôagit en fait de l‚Äôun des principes d‚ÄôUX (user experience, ou _exp√©rience utilisateur_). Car en termes d‚ÄôUX, il existe un certain nombre de
best practices qui peuvent vous guider dans vos choix.

La pratique pourrait signifier : ajouter plein de valeurs √† notre code, actualiser, changer ces nombres, actualiser √† nouveau, plisser les
yeux en regardant l'√©cran pour essayer de savoir si √ßa am√©liore les choses ou non, puis changer √† nouveau les nombres, Ctrl + R/Cmd + R,
commencer √† devenir nerveuse, changer les nombres pour un tout nouvel ensemble de nombres, actualiser, √ßa semble mieux... vraiment¬†?

L'it√©ration est essentielle dans le processus de cr√©ation d‚Äôune animation, mais relancer √† chaque fois notre code peut parfois √™tre p√©nible.
Et quand nous sommes sur une app front qui prend quelques secondes √† recharger, comme une application React, cela peut rapidement devenir
assez frustrant.

Alors, vous pouvez prendre votre mal en patience‚Ä¶ ou vous pouvez utiliser les outils d‚Äôanimation DevTools ! (Vous vous doutez bien que je
vous recommande fortement l'option 2.)

### D√©mythifiez les animations

DevTools de Chrome poss√®de un outil int√©gr√© que nous pouvons utiliser pour peaufiner et am√©liorer les transitions et les animations. Cet
outil s'appelle judicieusement ¬´¬†Animations¬†¬ª.

Mais avant de pouvoir utiliser le panneau Animations, nous devons l'ouvrir¬†:

:::info
Petit rappel : pour ouvrir DevTools, nous devons taper Ctrl-Shift-I sous Windows, ou Cmd-Opt-I sous Mac. Une fois DevTools ouvert, il faut
cliquer sur les trois points¬†en haut √† droite du panneau, descendre vers ¬´¬†More Tools¬†¬ª (_plus d'outils_) et cliquer sur ¬´¬†Animations¬†¬ª.
:::

![Ouverture du panneau animations dans DevTools](https://user.oc-static.com/upload/2019/08/26/15668476626738_15545563480631_pt03ch04_01_openAnimPanel_v002.gif)

Et voil√†, nous y sommes. Le panneau Animations. Rien de tr√®s excitant pour l'instant, sauf un message nous disant que l'application √©coute
les animations. Donnons-lui quelque chose √† √©couter en chargeant une page avec une animation¬†:

![Le panneau DevTools lorsque qu'une page avec une animation se charge](https://user.oc-static.com/upload/2021/02/10/16129510589393_Gif148.gif)

Nous avons un menu anim√©, la bo√Æte principale qui s'ouvre en coulissant, puis les √©l√©ments du menu qui glissent en position. Au fur et √†
mesure que l'animation est lue, une bo√Æte grise s'efface, remplie de quelques lignes color√©es.

√âtrange... Laissons-nous tenter et cliquons¬†:

![Le panneau Devtools au clic sur la boite grise](https://user.oc-static.com/upload/2019/08/26/15668477332601_15545564074413_pt03ch04_03_clickThumbnail_v001.gif)

Et voil√†¬†! Notre animation de menu se r√©p√®te, bien que la page n'ait pas √©t√© recharg√©e. Dans le panneau Animations, une timeline d'√©l√©ments
anim√©s appara√Æt, avec un logo de lecture lisant les segments pendant que l'animation progresse.

Mais √† quoi servent ces lignes color√©es sur l'image miniature¬†?¬†

Chaque ligne repr√©sente un √©l√©ment HTML anim√© avec sa propre couche dans la timeline. Si nous survolons le nom de l'√©l√©ment ou si nous
cliquons sur son graphique d'animation, Chrome le met en surbrillance sur la page¬†:

![Illustration de la surbrillance dans Devtools](https://user.oc-static.com/upload/2019/08/26/15668478903004_15545564313588_pt03ch04_04_clickElement_v001.gif)

On dirait donc que nous avons un √©l√©ment de menu, avec une div pour chaque √©l√©ment de menu, quelques √©l√©ments d√©coratifs pour am√©liorer
l'animation et des √©l√©ments de menu.

Dans chaque couche, des points repr√©sentent les √©tapes cl√©s pour voir o√π chaque animation commence et se termine, ainsi que les courbes
d'acc√©l√©ration, repr√©sent√©es par un graphique de vitesse, o√π le pic du profil est la vitesse maximale.

L'√©l√©ment de menu avec la classe `.menu`¬†qui lui est appliqu√©e commence √† 0 seconde et dure environ 600ms, en tout cas √† premi√®re vue. En
fait, si nous cliquons sur la couche, non seulement l'√©l√©ment est mis en surbrillance, mais ses balises et son style sont √©galement¬†affich√©s
dans le panneau √âl√©ments ci-dessous¬†:

![Illustration du panneau √©l√©ments dans Devtools](https://user.oc-static.com/upload/2019/08/26/15668479285784_15545564651766_pt03ch04_05_animProps_v002.gif)

Avec le style de .menu qui nous est pr√©sent√©, nous pouvons voir qu'il a en effet une dur√©e d'animation de 600ms, ainsi que la fonction de
timing par d√©faut, et un `animation-fill-mode`¬†r√©gl√© sur ¬´¬†both¬†¬ª. Il utilise √©galement un ensemble de keyframes appel√© ¬´¬†menu¬†¬ª et poss√®de
un keyframe entre le d√©but et la fin, ce qui est indiqu√© par le point creux au milieu de l'animation.

Les animations attach√©es aux √©l√©ments .menu__open-accent utilisent toujours le m√™me ensemble de keyframes que l'animation du menu principal.
On peut le voir gr√¢ce au nom ‚Äúmenu‚Äù qui est indiqu√© au-dessus du profil de vitesse. Elles sont les seules √† avoir des dur√©es et des d√©lais
diff√©rents. Si nous cliquons sur l'une d'elles, nous verrons exactement quels sont sa dur√©e et son d√©lai¬†:

![Propri√©t√©s duration et delay dans les Elements](https://user.oc-static.com/upload/2019/08/26/15668481964151_15545564932301_pt03ch04_06_accentProps_v002_1.gif)

Vous pouvez¬†faire des allers-retours avec l'animation en d√©pla√ßant le curseur sur la timeline. Cela donne une tr√®s bonne id√©e de la fa√ßon
dont les diff√©rents √©l√©ments agissent et interagissent les uns avec les autres¬†:

![D√©placement du curseur sur la timeline](https://user.oc-static.com/upload/2019/08/26/15668482559065_15545565166639_pt03ch04_07_scrubbing.gif)

En cliquant¬†sur le bouton de lecture situ√© √† gauche de la timeline, on peut voir notre animation en temps r√©el¬†:

![Clic sur le bouton lecture](https://user.oc-static.com/upload/2019/08/26/15668482911548_15545565375392_pt03ch04_08_play100_v001.gif)

Ceci n'est possible que si l'option 100% est surlign√©e pr√®s du haut du panneau. 100% indique la vitesse de lecture. Nous pouvons donc
√©galement choisir de lire une animation √† un quart de sa vitesse normale¬†:

![Devtools Animations playback speed](https://user.oc-static.com/upload/2019/08/26/1566848471581_15545565774503_pt03ch04_09_play25_v001%20%281%29.gif)

Ou, pour une lecture tr√®s ralentie, nous pouvons m√™me la r√©gler pour qu'elle soit lue √† 10¬†% de sa vitesse normale¬†:

![Devtools Animations playback slow](https://user.oc-static.com/upload/2019/08/26/15668485350069_15545566258087_pt03ch04_10_play10_v001.gif)

:::info
Une excellente fa√ßon d'am√©liorer ses comp√©tences en animation consiste √† d√©composer les animations que vous aimez.¬†Vous voyez¬†imm√©diatement
si¬†vous aimez quelque chose en particulier, mais avec l‚Äôoutil Animations des DevTools,¬†vous pouvez¬†aller plus loin et les diss√©quer √©tape par
√©tape.

En bref, l'outil d'animation peut nous aider pour¬†:
1. Voir rapidement tous les √©l√©ments utilis√©s dans une animation.
2. Comprendre comment ils sont combin√©s et mis en sc√®ne pour cr√©er le rendu final.
3. Rep√©rer l√† o√π il y a un probl√®me.
4. Et commencer √† trouver une solution¬†!

Ainsi, au-del√† d'une meilleure compr√©hension de la composition des animations, comment est-ce que DevTools peut nous aider √† am√©liorer nos
animations¬†?

Regardons √† nouveau notre animation de menu¬†:

![Devtools Animations playback slow 2](https://user.oc-static.com/upload/2019/08/26/15668485695034_15545566757547_pt03ch04_10_play10_v001.gif)

√áa vous para√Æt enthousiasmant, n'est-ce pas¬†? Mais il y a encore quelque chose qui me chiffonne.

Ce n'est pas que cette application soit¬†_mauvaise_... Mais, quand on regarde la timeline, on voit qu‚Äôelle est tr√®s lin√©aire. L'animation se
d√©roule de mani√®re tr√®s r√©guli√®re et graduelle. Chaque √©l√©ment du menu commence lorsque le pr√©c√©dent est √† mi-chemin. Tout semble un peu trop
robotique et sans vie¬†:

![Devtools Animations steps](https://user.oc-static.com/upload/2019/08/26/15668486304178_15545567133209_pt03ch04_11_uniformity_v001%20%280-00-01-07%29_1.png)

OK, cette animation n'est pas la meilleure qui soit. J‚Äôai compris¬†! üôà Alors, revenons √† l'√©diteur et changeons un peu les d√©lais et les
dur√©es des √©l√©ments du menu, et esp√©rons que les choses aient l'air un peu plus naturelles.

Croisons les doigts. Mais vous n‚Äô√™tes cependant pas certain d‚Äôobtenir le r√©sultat attendu. Pour avoir une animation avec un timing adapt√©,
rien ne remplace l'exp√©rimentation. Et exp√©rimenter en faisant de nombreux allers-retours entre notre √©diteur et notre navigateur, c'est un
peu comme essayer de courir dans des sables mouvants¬†: une exp√©rience lente, frustrante, avec le risque constant de s'enliser.

Alors, plut√¥t qu'un destin fait de frustrations et de d√©sespoir, pourquoi ne pas simplement faire glisser son curseur sur les DevTools¬†? √áa
para√Æt plus tentant, n'est-ce-pas ?

### R√©glez vos animations directement dans les DevTools

Eh oui,¬†vous pouvez ajuster vos animations tr√®s simplement en cliquant et en faisant glisser les √©l√©ments de la timeline. Vous voulez faire
durer votre animation plus longtemps ou au contraire l‚Äôacc√©l√©rer¬†? Cliquez sur son point de d√©part ou sa destination et faites-le glisser vers
la gauche ou la droite :

![Devtools Animations duration drag and drop](https://user.oc-static.com/upload/2019/08/26/15668486799632_15545567554873_pt03ch04_12_outPointDrag_v002.gif)

Et d'un seul coup, nous avons modifi√© la dur√©e de l'animation pour le premier √©l√©ment de menu. Dans le volet Elements, les valeurs de dur√©e
et de d√©lai de l'animation ont √©t√© mises √† jour.

En cliquant √† nouveau sur ce bouton de lecture,¬†nous pouvons voir¬†que notre menu est maintenant lu en utilisant la nouvelle dur√©e.

![Devtools Animations drag and drop duration](https://user.oc-static.com/upload/2019/08/26/15668487262798_15545567826443_pt03ch04_13_modPlayback_v001.gif)

Nous pouvons donc ajuster nos dur√©es et effectuer quelques petites modifications jusqu'√† ce que tout semble parfait. C'est beaucoup plus
rapide et plus facile que de faire des allers-retours entre le navigateur et l'√©diteur, vous ne trouvez pas¬†?


:::caution
Le panneau d'animation nous permet d'ajuster les propri√©t√©s de l'animation telles que la dur√©e. Mais les pourcentages des keyframes ne font
pas partie des propri√©t√©s de l'animation¬†: ces pourcentages font partie de¬†l'animation @keyframes en tant que telle. La modification d'un
pourcentage d'un keyframe se refl√®te dans chaque instance d'une animation qui utilise ces keyframes. Donc, si nous voulons ajuster les
pourcentages des keyframes, nous devons le faire √† la main.
:::

En plus de faire glisser les extr√©mit√©s des animations pour ajuster leur dur√©e, nous pouvons √©galement ajuster leurs d√©lais en faisant glisser
(en mode drag-and-drop) le profil de l'animation¬†:

![Devtools Animations drag and drop delay](https://user.oc-static.com/upload/2019/08/26/1566848786371_15545568254129_pt03ch04_14_clipDrag_v001.gif)

Apr√®s avoir d√©plac√© une animation sur la timeline dans un sens ou dans l'autre, sa valeur de d√©lai d'animation est mise √† jour dans le volet
Elements ci-dessus. Et en cliquant sur le bouton de lecture, vous verrez appara√Ætre notre animation modifi√©e avec son nouveau d√©lai¬†:

![Observation directe du r√©sultat d'un changement dans DevTools](https://user.oc-static.com/upload/2019/08/26/15668488338333_15545568586413_pt03ch04_15_dragPlayback_v001.gif)

:::note ?
_Que se passe-t-il si nous actualisons la page √† ce stade¬†?_
:::

Si on regarde notre code source, rien n'a chang√©. Cela signifie que si nous actualisons notre page, tout reviendrait √† la version pr√©c√©dente
de nos animations, et toutes nos modifications seraient perdues¬†!

![Devtools Animations refresh page](https://user.oc-static.com/upload/2019/08/26/15668488646528_15545568971949_pt03ch04_16_pageRefresh_v001.gif)

Quand nous modifions des animations dans le panneau d'animation, nous modifions des √©l√©ments dans ce qu'on appelle le DOM (vous vous souvenez,
je vous en avais parl√©), qui, pour simplifier, est le rendu par le navigateur de nos HTML et CSS, etc. Les modifications que nous avons
apport√©es aux panneaux Animation et Elements n'affectent donc que l'interpr√©tation du rendu de notre code. Si nous voulons conserver la
version de notre animation que nous cr√©ons dans le panneau Animation, nous devrons mettre √† jour manuellement notre code pour le faire
correspondre.

:::note ?
Euh... mais... il se passe tout plein de trucs... des dur√©es, des d√©lais... cela fait beaucoup de choses √† suivre...
:::

C'est vrai. Heureusement, Chrome suit mieux que nous. En haut dans l'onglet de l'√©l√©ment, align√© √† droite du s√©lecteur qui contient le d√©lai
que nous venons de modifier, il y a un lien vers l'emplacement dans le fichier CSS.¬†Cliquons dessus. Devtools passe directement au volet
Sources et le met en surbrillance dans le code. Et si nous faisons un clic droit sur le fichier CSS,¬†il est possible de¬†choisir ¬´¬†Local
Modifications¬†¬ª (_modifications locales_) dans le menu contextuel, ce qui ouvre un panneau Modifications √† c√¥t√© de notre panneau Animations :

![Animation des changements](https://user.oc-static.com/upload/2019/08/26/15668491227766_15545569362614_pt03ch04_17_localMods_v001_3%20%281%29.gif)

Dans le panneau ¬´¬†Changes¬†¬ª, on peut voir les logs de ¬´¬†diff¬†¬ª. Cela correspond aux diff√©rences entre le code source et les modifications
effectu√©es dans les DevTools. Les valeurs originales sont surlign√©es en rouge, et les valeurs mises √† jour sont surlign√©es en vert.

Nous pouvons rapidement voir les propri√©t√©s que nous devons mettre √† jour, et les valeurs sur lesquelles nous devons les mettre √† jour. Une
fois que nous avons ajust√© nos animations pour qu‚Äôelles correspondent √† l‚Äôeffet recherch√©, nous pouvons ainsi passer √† ce panneau et
l'utiliser pour mettre √† jour notre code source.

La comparaison avec les ‚Äúdiffs‚Äù fonctionne comme les syst√®mes de contr√¥le de version, o√π les modifications apport√©es au code existant sont
stock√©es et utilis√©es pour cr√©er la version la plus r√©cente d'un document. Si vous avez d√©j√† eu un conflit de merge sur Git, vous avez
probablement compar√© les diff√©rences entre les deux documents pour r√©soudre ce conflit.

### √âvaluez vos animations

Maintenant que nous connaissons l‚Äôoutil Animation sur le bout des doigts, jetons un coup d‚Äô≈ìil √† notre menu¬†:

![Menu animation devtools](https://user.oc-static.com/upload/2019/08/26/15668491605298_15545569983309_pt03ch04_08_play100_v001%20%282%29.gif)

Retour √† l'animation de votre menu

Pour l'instant, il y a quelques √©l√©ments qui ne vont pas.
1. Les √©l√©ments du menu s'affichent trop tard.
2. Les borders de l'√©l√©ment de menu arrivent √©galement un peu trop tard.
3. Le d√©calage est trop important entre les diff√©rents √©l√©ments de menu qui s'animent √† l'int√©rieur. Ils donnent l'impression de s'animer
l'un apr√®s l'autre, plut√¥t que d'√™tre d√©cal√©s.
4. La dur√©e des animations menu__item semble √™tre un peu trop rapide.

Toutes ces remarques viennent vraiment d‚Äôune sensibilit√©. Nous assignons des valeurs en pensant qu'elles seraient de bons points de d√©part
pour les diff√©rentes animations, mais elles peuvent et doivent √™tre ajust√©es en fonction des pr√©f√©rences. Nous n'allons pas entrer dans les
d√©tails des dur√©es et des d√©lais de chaque animation.

Diff√©rentes choses peuvent vous sembler parfaites ou imparfaites. C‚Äôest donc le moment pour vous de faire vos propres exp√©riences. Ouvrez le
panneau Animations, cliquez, glissez-d√©placez, modifiez et exp√©rimentez √† votre guise. Revenez quand vous serez satisfait de votre r√©sultat.

### Comparez vos animations

Vous voil√† de retour¬†? Parfait¬†! J'esp√®re que vous avez une animation qui vous pla√Æt. De mon c√¥t√©, voici la version que je pr√©f√®re¬†!

![Devtools menu final](https://user.oc-static.com/upload/2019/08/26/15668492166283_15545570580813_pt03ch04_18_finalResult_v001.gif)

Et voil√† le rendu final !

Dans l'ensemble, l'animation principale .menu est un peu plus lente, de m√™me que les animations de .menu__item, qui sont maintenant
√©chelonn√©es de mani√®re plus rapproch√©e.

Modifier son animation est un v√©ritable processus. Arriver √† une animation que l'on trouve ¬´¬†parfaite¬†¬ª n'est pas quelque chose que l'on
parvient √† faire du premier coup. Gr√¢ce √† notre exp√©rience et √† notre instinct, nous pouvons commencer √† nous faire une id√©e de ce que les
valeurs de l'animation devraient¬†_probablement_ √™tre, mais ce n'est que le point de d√©part. √Ä partir de l√†, il s'agit de tester et de t√¢tonner
pour arriver √† un r√©sultat dont nous sommes satisfaits.

![Diff√©rences avec tous les changements effectu√©s](https://user.oc-static.com/upload/2019/08/26/15668497833648_1554557862722_pt03ch04_21_diffed_v001%20%280-00-03-02%29.png)

Tous les changements effectu√©s

Les dur√©es ont √©t√© un peu modifi√©es, mais les changements les plus importants concernent la dur√©e des `animation-delay`. Tous les √©l√©ments de
.menu__item arrivent plus t√¥t, avec .menu__item--1 √† peine 25 millisecondes plus t√¥t, et .menu__item--3 presque 400ms plus t√¥t.

Dans l'ensemble, cela permet d‚Äôavoir une animation plus dynamique et plus accrocheuse. Voici ces changements, int√©gr√©s dans le code final¬†:

```html
<div class="container">
    <menu class="menu">
        <div class="menu__item menu__item--1 menu__item--current">
            Home
            <div class="menu__item-accent menu__item-accent--active"></div>
        </div>
        <div class="menu__item menu__item--2">
            About
            <div class="menu__item-accent"></div>
        </div>
        <div class="menu__item menu__item--3">
            Contact
            <div class="menu__item-accent"></div>
        </div>
        <div class="menu__open-accent--1"></div>
        <div class="menu__open-accent--2"></div>
    </menu>
</div>
```

```scss
$cd-navy: #0E397F;
$cd-mint: #15dea5;
@mixin menu__open-accent($dur, $delay) {
    content: "";
    position: absolute;
    left: 0;
    right: 0;
    top:0;
    bottom: 0;
    background: #f4f9f8;
    transform-origin: top left;
    animation: menu $dur $delay both;
    z-index: -1;
}
.menu {
    min-width: 33vh;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 1rem;
    background:$cd-mint;
    overflow: hidden;
    transform-origin: top left;
    position: relative;
    animation: menu 661ms both;
    z-index: -10;
    &__open-accent--1 {
        @include menu__open-accent(450ms, 275ms);
    }
    &__open-accent--2 {
        @include menu__open-accent(450ms, 150ms);
        background: $cd-navy;
        z-index: -2;
    }
    &__item {
        padding: .75rem;
        margin: .25rem;
        background: #fff;
        animation: menu__item 810ms cubic-bezier(.1,.9,.1,1) both;
        position: relative;
        &-accent {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            width: .25rem;
            background-color: $cd-mint;
            animation: menu__accent 400ms both;
            &--active {
                background-color: $cd-navy
            }
        }
        &--1 {
            animation-delay: 475ms;
            > div {
                animation-delay: 712ms;
            }
        }
        &--2 {
            animation-delay: 546ms;
            > div {
                animation-delay: 805ms;
            }
        }
        &--3 {
            animation-delay: 632ms;
            > div {
                animation-delay: 914ms;
            }
        }
    }
}
@keyframes menu {
    0% {
        transform: scale(0,.07);
    }
    33% {
        transform: scale(1,.07);
        animation-timing-function: cubic-bezier(.73,.01,.2,.99)
    }
}
@keyframes menu__item {
    0% {
        transform: translateX(\-110%);
    }
}
@keyframes menu__accent {
    0% {
        transform: scaleY(0);
    }
}
```

Votre code peut vous sembler tr√®s similaire, ou il peut y avoir d'√©normes diff√©rences. Quoi qu'il en soit, vous avez cr√©√© une animation qui
vous convient √† _vous_, et c‚Äôest tr√®s important. Maintenant une √©tape essentielle : s‚Äôassurer que votre animation convient √©galement aux
autres. Le meilleur moyen de savoir si c'est le cas est de demander des feedbacks autour de vous.

La cr√©ation d'une animation ne consiste pas seulement √† cocher des cases sur une liste d'√©l√©ments √† livrer. Elle vient √©galement √©tayer et
am√©liorer notre compr√©hension de ce qui esth√©tique ou non. Chaque keyframe, chaque ajustement, chaque erreur nous permet d'√™tre plus
performants √† l'avenir. Chaque animation que nous cr√©ons nous permet d'am√©liorer notre art.

F√©licitations, vous √™tes maintenant de v√©ritables animateurs dans l‚Äô√¢me. Vous donnez vie aux pages web üë©‚Äçüé® !

### En r√©sum√©

- It√©rer, c‚Äôest le secret d'une bonne animation. Le simple fait d'ajouter quelques chiffres et d'appuyer sur Enregistrer est rarement
suffisant ;
- Notre exp√©rience nous donne une bonne intuition quant aux valeurs de d√©part qui paraissent bien pour nos propri√©t√©s d'animation ;
- Le panneau Animations de DevTools nous permet d'affiner rapidement les animations, d'improviser et d'exp√©rimenter jusqu'√† ce que nous
trouvions la bonne dur√©e ou le bon d√©lai pour un √©l√©ment ;
- Le panneau Changes (Modifications) nous permet de voir les propri√©t√©s que nous avons modifi√©es ainsi que leurs nouvelles valeurs, de fa√ßon
√† mettre √† jour notre code source en cons√©quence.

_Dans le prochain chapitre, nous ferons un petit tour d‚Äôhorizon de vos nouvelles comp√©tences üöÄ_

-----

## R√©sum√© du cours

[R√©sum√© du cours - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340949-resume-du-cours)

<Vimeo vimeoId="508777494" />

<br />

Prenez un instant pour r√©fl√©chir √† o√π vous en √©tiez il n‚Äôy a pas si longtemps... C‚Äôest assez fou, non¬†?

En quelques chapitres seulement, vous avez appris l‚Äôessentiel pour donner vie √† vos pages web.

Ensemble, nous avons appris comment :
- appliquer les principes de l‚Äôanimation au CSS ;
- cr√©er des transitions CSS simples ;
- mais aussi des transitions complexes ;
- cr√©er des animations ayant de nombreuses √©tapes avec les keyframes ;
- cr√©er une animation qui boucle √† l‚Äôinfini avec les propri√©t√©s d‚Äôit√©ration et de direction.

Il est maintenant temps de vous lancer dans vos propres animations avec keyframes. Pour cela, vous avez la derni√®re activit√© de ce cours.
J‚Äôesp√®re que vous en profiterez pour exprimer votre cr√©ativit√© d‚Äôanimateurs et animatrices !

:::info
Personnellement, quand j'ai besoin de cr√©er une nouvelle animation, je recherche toujours ce qui existe d√©j√†. Voil√† les sites que je consulte
en priorit√© :
- [Awwwards](https://www.awwwards.com/websites/animation/) : ce site recense les plus beaux sites Internet. La cat√©gorie "animation" a de
quoi faire r√™ver n'importe quel animateur üòç ;
- [Dribbble](https://dribbble.com/) : vous pouvez chercher le mot cl√© qui correspond le plus √† ce que vous voulez cr√©er, et rassembler vos
r√©sultats dans un panier (_bucket_ en anglais). Tr√®s pratique !
- [Codepen](https://codepen.io/) : ce site est parfait lorsque vous cherchez une animation sur un √©l√©ment bien sp√©cifique, comme un burger
menu, par exemple ;
- [UI Movement](https://uimovement.com/) : votre dose d'inspiration quotidienne en UI (User Interface), qui recense de nombreuses animations ;
- et encore bien plus en vous perdant dans le web. Alors bonnes d√©couvertes √† vous üë©‚ÄçüöÄ !
:::

-----

## Quiz : R√©alisez des animations dynamiques

[R√©alisez des animations dynamiques - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/exercises/3624)

#### Comp√©tences √©valu√©es

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> R√©aliser des animations dynamiques

-----

#### Description

Dans ce quiz, vous allez cr√©er vos premi√®res animations @keyframes.<br />
Ce quiz n'est **pas**¬†comme les deux pr√©c√©dents. Il v√©rifie vos connaissances mais aussi¬†**votre pratique sur un exemple concret**. Veillez √†
suivre les questions dans l'ordre et effectuer les t√¢ches demand√©es. Ce quiz ressemble √† un TP et¬†**vous prendra donc s√ªrement plus de temps**
que les deux autres, c'est normal !<br />
Les premi√®res questions sont des questions g√©n√©rales sur les comp√©tences apprises dans la partie 3. Pour les questions 6, 7, 8, 9 et 10, vous
allez devoir travailler sur le [repository GitHub](https://github.com/atoulmet/openclassrooms_css-animations) dont vous aviez eu besoin pour
le quiz de la deuxi√®me partie.<br />
V√©rifiez le fichier README.md pour obtenir quelques instructions suppl√©mentaires sur comment le faire tourner.<br />
Alors √† vous de jouer ! üí™


#### Question 1 : Quels¬†snippets de code me permettent de cr√©er une animation @keyframes ?

*Attention, plusieurs r√©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
@keyframes mon-animation {
    0%: {
        transform: scale(1);
    }
    100%: {
        transform: scale(1.2);
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
@keyframes mon-animation {
    100% {
        transform: scale(1.2);
    }
    0% {
        transform: scale(1);
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
@keyframes mon-animation {
    from {
        transform: scale(1);
    }
    to {
        transform: scale(1.2);
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
@keyframes mon-animation {
    from: {
        transform: scale(1);
    }
    to: {
        transform: scale(1.2);
    }
}
```

*La premi√®re r√©ponse semble exacte ; pourtant, elle utilise les ":" pour d√©finir chaque keyframe. Cette syntaxe n'est pas correcte.*

*En revanche, les deuxi√®me et troisi√®me r√©ponses permettent bien de cr√©er une animation. M√™me si l'√©tape 100% est d√©clar√©e avant l'√©tape 0%,
l'animation interpr√®te le pourcentage d√©clar√©.*<br />
*Pour ce qui est de la quatri√®me r√©ponse, elle reprend √©galement les ":" qui sont une mauvaise syntaxe.*

-----

#### Question 2 : Une animation @keyframes peut √™tre d√©clench√©e en CSS‚Ä¶

*Attention, plusieurs r√©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> par le survol d'un √©l√©ment par la souris avec la pseudoclasse <code>:hover</code><br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> au moment d'un clic sur un √©l√©ment avec <code>:active</code><br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> d√®s le chargement d'une page<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> juste avant la fermeture de la page<br />
<br />

*Tout comme pour les transitions, les animations @keyframes peuvent √™tre d√©clench√©es par les pseudoclasses ad√©quates. Les pseudoclasses :hover
et :active sont parfaites pour d√©clencher nos animations @keyframes. Mais il existe aussi une sp√©cificit√© des animations @keyframes : elles
peuvent √™tre √©galement d√©clench√©es d√®s le chargement de la page sur laquelle elles se trouvent. Pour cela, il suffit juste de pr√©ciser les
valeurs minimales pour cr√©er une animation.*

*En revanche, il n'existe pas de propri√©t√© CSS permettant de d√©clencher une animation juste au moment de la fermeture de la page. Pour cela,
il faudrait avoir recours √† d'autres technologies, telles que JavaScript.*

-----

#### Question 3 : J'ai besoin d'aide.

**Lorsque je code un bouton avec une animation @keyframes, l'animation n'est pas du tout fluide. J'ai le code suivant :**

```html
<div class="grow-element">
    Je grossis
</div>
```

```scss
@keyframes grow {
    0% {
        transform: scale(1);
    }
    100% {
        transform: scale(1.2);
    }
}
.grow-element {
    border: 1px solid black;
    width: 100px;
    cursor: pointer;
}
.grow-element:active {
    animation: grow 200ms;
}
```

**Quand je clique dessus, mon √©l√©ment grossit bien comme je le souhaite. Mais lorsque j'arrive √† la fin de mon animation, catastrophe.
L'animation s'arr√™te de mani√®re brutale, et revient √† la valeur de d√©part, avant m√™me que j'arr√™te de cliquer. Comment faire pour fluidifier
tout √ßa, et qu'il reste √† une √©chelle de 1.2 tant que je maintiens mon clic activ√© ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Pr√©ciser la valeur backwards pour animation-fill-mode<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Changer le timing de mon animation<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Utiliser une valeur de scale de 1.1 au lieu de 2<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Pr√©ciser la valeur forwards pour animation-fill-mode<br />
<br />

*C'est bien la propri√©t√© **animation-fill-mode** qui me permet d'√©tendre mon animation CSS avant et apr√®s la fin de son ex√©cution. Avec la
valeur backwards, l'animation appliquera les valeurs d√©finies par la premi√®re _keyframe_. Elle les retiendra pendant la dur√©e indiqu√©e par
[animation-delay](https://developer.mozilla.org/fr/docs/Web/CSS/animation-delay), mais ici, c'est √† la fin de notre animation que nous voulons
√©tendre les propri√©t√©s. Il s'agit donc de la valeur forwards.*<br />
*Changer le timing de mon animation me permettrait de la peaufiner, mais ne me permet pas de corriger l'arr√™t brutal de mon animation pour
autant. De m√™me, si je modifie la valeur de scale, mon √©l√©ment grossira de mani√®re moins forte, mais l'arr√™t de l'animation sera tout aussi
brutal. C'est donc bien la r√©ponse 4 qui est correcte ici üòé.*

-----

#### Question 4 : Trouvez l'intrus !

**Mon outil Animation dans mes DevTools me permet tr√®s facilement de :**
    
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> voir rapidement tous les √©l√©ments utilis√©s dans une animation.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> comprendre comment les √©l√©ments¬†sont combin√©s et mis en sc√®ne pour cr√©er le rendu final.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> modifier les pourcentages d'un keyframe.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> rep√©rer l√† o√π il y a un probl√®me.<br />
<br />

*L'outil Animation des DevTools est tr√®s pratique. Il permet en effet d'it√©rer beaucoup plus simplement sur les animations @keyframes, en
ajustant les propri√©t√©s de l'animation telles que la dur√©e. Mais les pourcentages des keyframes ne font pas partie des propri√©t√©s de
l'animation¬†: ces pourcentages font partie des keyframes en tant que tels. Ils ne peuvent donc pas √™tre modifi√©s depuis l'outil Animation.*

-----

#### Question 5 : Quelles affirmations sont exactes ?

*Attention, plusieurs r√©ponses sont possibles.*
    
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> Les fonctions de timing ne peuvent √™tre appliqu√©es qu'aux transitions.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Par d√©faut, chaque keyframe prend la fonction de timing du s√©lecteur o√π la fonction a √©t√© assign√©e.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> La valeur par d√©faut de la fonction de timing de chaque keyframe toujours ease.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Le fait de d√©clarer une fonction de timing dans une des √©tapes d'un keyframe permet d'appliquer un timing sp√©cifique √† ce keyframe.<br />
<br />

*Comme nous l'avons vu dans le chapitre 2 de notre troisi√®me partie, il est tout √† fait possible d'appliquer une fonction de timing √† nos
animations @keyframes. Vous pouvez aussi bien d√©clarer une valeur √† la propri√©t√© animation-timing-function dans le s√©lecteur o√π vous assignez
votre fonction, ou bien directement dans l'un de vos keyframes. Par d√©faut, les valeurs assign√©es au timing de chaque keyframe seront celles
d√©clar√©es dans le s√©lecteur o√π vous assignez votre fonction. Si cette valeur est par d√©faut ease, elle ne reste pas toujours √† sa valeur par
d√©faut. Les r√©ponses exactes sont donc la 2 et la 4.*

-----

#### Question 6 : Maintenant, je veux que vous retourniez sur le repository GitHub li√© √† ce cours. Encore une fois, lisez le readme.md pour obtenir plus d'informations sur comment faire marcher le code.

**Vous devriez avoir une sc√®ne comme celle-ci :**

![Capture d'√©cran repository Github](https://user.oc-static.com/upload/2019/08/27/15669306000626_15562876576348_Scene%20%281%29.png)

**Pour cette question, concentrons-nous sur la montgolfi√®re.**

**J'ai d√©fini une animation :**

```scss
@keyframes balloon {
    0% {
        bottom: 20%;
    }
    100% {
        bottom: 70%;
    }
}
```

**Quel snippet de code CSS me permet de faire monter et descendre la montgolfi√®re √† l'infini de mani√®re fluide ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation-timing-function: ease-in-out;
animation-direction: reverse;
animation-iteration-count: infinite;
animation-name: balloon;
animation-duration: 0s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
animation-direction: alternate-reverse;
animation-timing-function: ease-in-out;
animation-iteration-count: infinite;
animation-name: balloon;
animation-duration: 5s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation-timing-function: ease-in-out;
animation-iteration-count: infinite;
animation-name: balloon;
animation-duration: 5s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation-direction: alternate-reverse;
animation-timing-function: ease-in-out;
animation-iteration-count: 8;
animation-name: balloon;
animation-duration: 5s;
```

*Ici, c'est bien la deuxi√®me r√©ponse qui nous permet d'obtenir l'effet suivant (attention, le format GIF utilis√© ici me limite en temps
d'animation et en qualit√©) :*

![Animation montgolfi√®re](https://user.oc-static.com/upload/2019/08/27/15669305180794_ezgif.com-optimize%20%2812%29.gif)

*La r√©ponse 1, en revanche, ne permet m√™me pas de cr√©er une animation, puisque sa dur√©e est de 0 seconde. Et m√™me si sa dur√©e √©tait pr√©cis√©e,
la valeur "reverse" de "animation-direction" ne permet pas de cr√©er l'effet de mont√©e-descente : au lieu de √ßa, la montgolfi√®re part d'en haut,
descend tout en bas, puis se t√©l√©porte par magie tout en haut.*

*La troisi√®me r√©ponse quant √† elle ne pr√©cise m√™me pas la propri√©t√© "animation-direction". L'effet est donc similaire √† celui de la r√©ponse 1 :
la montgolfi√®re part du sol, monte dans le ciel, puis se t√©l√©porte en bas. La derni√®re r√©ponse n'est pas correcte non plus : elle ne pr√©cise
pas que l'animation doit boucler √† l'infini, car elle donne la valeur de 8 √† ¬†animation-iteration-count.*

-----

#### Question 7 : Reprenons l'exemple ci-dessus.

**Quel(s) snippet(s) de code me permet(tent) de reproduire le m√™me effet ?**

*Attention, plusieurs r√©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
animation: balloon 0s 5s ease-in-out alternate-reverse infinite;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
animation: balloon 5s 0ms alternate-reverse infinite;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
animation: balloon 5000ms ease-in-out alternate-reverse infinite;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
animation: balloon 5s 0s ease-in-out alternate-reverse infinite;
```

*Ici, les r√©ponses 3 et 4 permettent de reproduire l'animation de la question pr√©c√©dente. Souvenez-vous : la propri√©t√© raccourcie animation
permet de d√©finir les m√™mes propri√©t√©s que animation-name, animation-duration, animation-timing-function, animation-delay,
animation-iteration-count, animation-direction, animation-fill-mode, animation-play-state. Mais pour cela, il faut bien respecter l'ordre des
valeurs. La r√©ponse 1 inverse animation-duration et animation-delay : ici, animation-duration est √† 0, ce qui ne permet pas de cr√©er une
animation. Par ailleurs, il faut bien garder √† l'esprit que les animations, tout comme les transitions, ont des valeurs par d√©faut. Pour la
propri√©t√© animation-timing-function, la valeur par d√©faut est 'ease' : elle ne permet pas de reproduire le snippet de code de la question
pr√©c√©dente. En revanche, dans la r√©ponse 4, aucune valeur n'est pr√©cis√©e pour animation-delay, et sa valeur par d√©faut est 0 : cela correspond
bien üöÄ.*

-----

#### Question 8 : Au tour, cette fois-ci, de la voiture !

**Je veux cr√©er un effet o√π ma voiture d√©marre tranquillement jusqu'au passage pi√©ton. Elle y marque un bref arr√™t, avant de repartir
tranquillement vers la partie droite de mon √©cran.**<br />
**Dans ma classe .car, j'ai le code suivant :**

```scss
animation: car-animation 3s;
```

**Quelle animation @keyframes me permet d'y parvenir ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
@keyframes car-animation {
    0% {
        left: 0;
    }
    30%, 40% {
        left: 20%;
    }
    100% {
        left: 80%;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
@keyframes car-animation {
    0% {
        left: 0;
    }
    10% {
        left: 50%;
    }
    100% {
        left: 80%;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
@keyframes car-animation {
    0% {
        left: 80%;
    }
    30% {
        left: 40%;
    }
    100% {
        left: 80%;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
@keyframes car-animation {
    from {
        left: 0;
    }
    30%, 40% {
        left: 20%;
    }
    100% {
        left: 80%;
    }
}
```

*C'est bien l'animation num√©ro 1 qui permet, gr√¢ce aux keyframes d√©clar√©s, de cr√©er l'animation voulue. Si vous h√©sitez pour cr√©er un effet,
n'h√©sitez pas √† it√©rer !*

-----

#### Question 9 : Testons maintenant les freins de notre voiture.

**Je veux pouvoir interagir avec ma voiture : √† chaque fois que ma souris la survole, elle doit s'arr√™ter net.**<br />
**Quelle propri√©t√© et quelle valeur associ√©e dois-je pr√©ciser dans le :hover pour y parvenir simplement ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation-play: none;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation-play-state: pause;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
animation-play-state: paused;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation-timing-function: stop;
```

*Il s'agit bien de la propri√©t√© animation-play-state. En revanche, ni none ni pause ne sont des valeurs possibles pour cette propri√©t√©. La
bonne r√©ponse est bien la 3 ici. Pour ce qui est du quatri√®me choix possible, je tenais √† pr√©ciser que stop n'est pas non plus une fonction
de timing üôà.*
*Si vous avez un doute, n'h√©sitez surtout pas √† aller consulter la doc des propri√©t√©s CSS, comme [ici](https://developer.mozilla.org/fr/docs/Web/CSS/animation-play-state).*

-----

#### Question 10 : Restons sur la voiture. Je veux cette fois-ci que ma voiture marque un d√©lai de 3 secondes avant de se lancer puis de sortir de l'√©cran et de rester en dehors de l'√©cran. Comme dans le GIF ci-dessous :

![Animation voiture activit√©](https://user.oc-static.com/upload/2019/08/27/1566931460763_ezgif.com-resize%20%284%29.gif)

**Mon animation @keyframes est la suivante :**

```scss
@keyframes car-animation {
    0% {
        left: 0;
    }
    30%,
    40% {
        left: 20%;
    }
    100% {
        left: 110%;
    }
}
```

**Et mon CSS :**

```scss
.car {
    height: 60px;
    width: 200px;
    position: absolute;
    bottom: 80px;
    left: 10%;
    background-image: URL("../images/car.png");
    background-position: center;
    background-repeat: no-repeat;
    background-size: contain;
    z-index: 99;
}
```

**Quel snippet de code me permet d'obtenir l'effet ci-dessus ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation: car-animation 3s backwards;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation: car-animation 3s 3s backwards;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
animation: car-animation 3s 3s both;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
animation: car-animation 3s 3s forwards;
```

*Ici, le choix num√©ro 1 ne pr√©cise pas de d√©lai, la voiture ne peut donc pas marquer un arr√™t de 3 secondes. Le choix num√©ro 2 √©tend bien
l'effet durant la propri√©t√© animation-delay, ce qui veut dire que la voiture marquera bien l'arr√™t √† la position de la premi√®re keyframe de
notre animation. Mais d√®s l'animation termin√©e, elle retourne √† sa position initiale. √Ä l'inverse, forwards permet de prolonger l'effet de la
derni√®re keyframe apr√®s la fin de l'animation, me permettant de laisser la voiture en dehors de l'√©cran, mais son arr√™t du d√©but ne se fait
pas au bon endroit. C'est donc bien la r√©ponse 3 qui me permet de reproduire l'effet voulu.*
