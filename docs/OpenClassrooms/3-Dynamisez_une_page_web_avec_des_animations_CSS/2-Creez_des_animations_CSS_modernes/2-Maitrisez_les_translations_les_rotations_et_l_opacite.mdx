---
sidebar_position: 3
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# Ma√Ætrisez les translations, les rotations et l‚Äôopacit√©

## Optimisez les performances de votre navigateur pour vos animations CSS

[Optimisez les performances de votre navigateur pour vos animations CSS - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340918-optimisez-les-performances-de-votre-navigateur-pour-vos-animations-css)

<Vimeo vimeoId="508777206" />

<br />

### Assurez-vous d‚Äôavoir des animations fluides

Comme je vous le disais dans la vid√©o d'introduction, les animations que nous voyons sur nos √©crans ne sont pas de v√©ritables mouvements. Il
s'agit en fait de **successions d'images** allant suffisamment vite pour qu'elles soient interpr√©t√©es par notre cerveau comme des objets en
mouvement.

Je vous parlais √©galement de **Frames Per Second** (FPS). Voyons ce que cela donne sur nos √©crans ü§ì

:::info
Les images par seconde, ou _FPS_, repr√©sentent le nombre d‚Äôimages individuelles affich√©es en une seconde. Plus les¬†FPS sont √©lev√©es, plus le
mouvement para√Æt fluide. Comme nous allons bient√¥t le voir, en animation web, on vise 60 FPS, mais en raison des limitations techniques de GIF,
nous utilisons des exemples √† 50 FPS.
:::

Dans l‚Äôanimation suivante, une balle qui va et vient au rythme de 50 images par secondes (ou 50 FPS) :

![Une animation CSS √† 50 fps](https://user.oc-static.com/upload/2021/02/09/16128907707836_Gif053.gif)

Le mouvement para√Æt bien fluide. Maintenant, voici la m√™me animation, mais avec 10 FPS au lieu de 50 :

![Une animation CSS √† 10 fps](https://user.oc-static.com/upload/2021/02/09/16128907798918_Gif054.gif)

Le mouvement de la balle para√Æt vraiment moins fluide √† 10 FPS qu‚Äô√† 50. On peut m√™me distinguer les **images** qui composent l‚Äôanimation. Au lieu
de para√Ætre naturelle, l‚Äôanimation ressemble plut√¥t √† une **tentative d‚Äôimitation de mouvement**. L‚Äôimage **saccad√©e** ne trompe pas notre
cerveau. Au contraire, l'exp√©rience est plut√¥t d√©sagr√©able, ce qui nous distrait de l‚Äôanimation.

:::note ?
Mais alors, quel est le nombre d‚Äôimages par seconde des transitions que nous avons cr√©√©es jusqu‚Äôici ? üßê
:::

En animation traditionnelle, le nombre d‚Äôimages par seconde est fixe et toutes les images sont cr√©√©es avant que l‚Äôanimation ne soit lanc√©e. Mais
les animations CSS sont affich√©es en **temps r√©el** par le navigateur, qui met √† jour l‚Äôanimation avec les nouvelles images d√®s qu‚Äôil les a
calcul√©es.

Cela signifie que le nombre d‚Äôimages par seconde de nos animations est **variable**. Par exemple, disons que le navigateur met 0,04 seconde √†
calculer une image d‚Äôune animation, puis 0,03 seconde √† calculer la suivante.

Mais cela ne nous donne pas le FPS pour autant.

:::note ?
Comment le calculer ?
:::

Pour d√©terminer le nombre d‚Äôimages par seconde, on divise une seconde par la dur√©e de calcul, en secondes. Donc 1/0,04 = 25 FPS.

Ce qui veut dire que le nombre d‚Äôimages par seconde de l‚Äôanimation est de 25 FPS pour la premi√®re image, et 30 pour la deuxi√®me.

La question n‚Äôest pas tant comment calculer le nombre d‚Äôimages par seconde de notre animation, mais comment s'assurer de respecter le nombre
id√©al, √† savoir **60 FPS**.

La plupart des √©crans ont un taux de rafra√Æchissement de 60 hz, ou 60 images par seconde. Si on cr√©e une animation avec 75 FPS, le spectateur
n‚Äôen verrait que 60 parce que l‚Äô√©cran ne rafra√Æchit par l‚Äôimage assez vite pour afficher les 75. 60 FPS est donc le taux d‚Äôimages par seconde le
plus fluide que le spectateur pourra voir sur ses √©crans.

De fait, nous devons nous assurer que le navigateur mette moins d'un soixanti√®me de seconde, ou 0,016 seconde (16 millisecondes) pour calculer
les images de notre animation.

:::noe ?
Alors comment faire pour garder ce temps de calcul √† 16 millisecondes maximum ?
:::

Pour cela, il suffit de suivre certaines bonnes pratiques dans la mani√®re d'√©crire vos animations CSS.

### Comprenez comment le navigateur passe des codes HTML et CSS √† une page web

Pour passer des codes CSS et HTML‚Ä¶ √† une page web, le navigateur passe par plusieurs √©tapes pour afficher une page. Voici les √©tapes qui nous
int√©ressent pour le rendu de nos animations :
1. **Style** : le navigateur **re√ßoit** le code HTML. Il va l'**interpr√©ter** pour comprendre la structure du DOM (Document Object Model). Ainsi,
pour chaque balise HTML, il cr√©e un √©l√©ment du DOM, un peu comme un arbre de n≈ìuds. Il parcourt ensuite le CSS, et d√©termine quelles r√®gles
s‚Äôappliquent √† quels √©l√©ments. √Ä partir de l√†, il va cr√©er la structure qui s'affichera.

:::info
Le DOM, qui signifie **_Document Object Model_** ("mod√®le d'objet de document", en fran√ßais), est une repr√©sentation du HTML d'une page web. Il
faut voir le DOM comme un **arbre** o√π chaque √©l√©ment peut avoir z√©ro ou plusieurs enfants, qui peuvent avoir eux-m√™mes z√©ro ou plusieurs enfants,
qui peuvent avoir z√©ro ou plusieurs enfants... Si vous voulez en savoir plus, il y a un super cours dessus¬†: [√âcrivez du JavaScript pour le web](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5543068-comprenez-ce-quest-le-dom)¬†üöÄ.
:::

2. **Layout** (mise en page) : maintenant que le navigateur conna√Æt les styles et les √©l√©ments √† afficher, il **d√©termine** la **taille** des
√©l√©ments et o√π les placer.
3. **Paint** (peinture) : le navigateur transforme les √©l√©ments en **pixels** en utilisant les styles de l‚Äô√©tape 1, et les positions et
dimensions d√©duites de l‚Äô√©tape 2.
4. **Composition** : le navigateur combine tous les √©l√©ments pour **composer** la page qui s‚Äôaffiche dans le navigateur.

Ces diff√©rentes √©tapes sont importantes pour comprendre quelles propri√©t√©s modifier pour nos animations. En effet, le navigateur applique
diff√©rentes propri√©t√©s CSS √† diff√©rentes √©tapes du processus. Typiquement, width et height sont appliqu√©es pendant l'√©tape du layout. En revanche,
color et box-shadow sont appliqu√©es √† l'√©tape paint.

:::info
Le site **[csstriggers.com](http://csstriggers.com/)** (en anglais, mais vous retrouverez les mots cl√©s que nous avons vus ici) pr√©sente les
√©tapes de chaque propri√©t√© associ√©e aux layout, paint et composition. Pas mal si vous avez un doute sur une propri√©t√© pour la performance de
votre animation !
:::

Chaque √©tape n√©cessite un **temps de calcul** au navigateur. Il est donc plus judicieux de passer par le moins d'√©tapes possible si on veut
respecter le seuil des 16 millisecondes pour chaque √©tape de notre animation.

:::note ?
Concr√®tement, comment √ßa se passe ?
:::

Reprenons l'exemple de notre bouton dans la partie pr√©c√©dente.

Mon bouton fait 30px par 100px. Au survol de la souris, je veux qu'il s'√©largisse de 10px. Si je change la propri√©t√© ¬†`width`, cela veut dire que
mon navigateur recalcule le layout, le paint et la composition. Pas tr√®s optimal, n'est-ce pas ? üôà

Et √† chaque mouvement de souris, il faudra tout **recalculer**. Or, plus le navigateur doit faire de calculs, plus il mettra de temps, ce qui
baisse le nombre d‚Äôimages par seconde, et **d√©grade** consid√©rablement l'exp√©rience utilisateur.

Quand le nombre d‚Äôimages par seconde devient tellement faible qu‚Äôon commence √† distinguer les images une par une et que le mouvement semble
"**rouiller**", on appelle √ßa ‚Äú**jank**‚Äù. C'est le pire ennemi d‚Äôun animateur. La cl√© pour √©viter le jank est de se limiter √† animer des
propri√©t√©s qui ne d√©clenchent pas de calculs de layout ou de paint.

En d‚Äôautres termes, il ne faut animer que des propri√©t√©s qui font partie de l‚Äô√©tape **composition**. Les plus adapt√©es sont donc `transform`¬†et
`opacity`.

Revenons √† notre bouton qui faisait grossir une boule en utilisant la fonction `scale()`¬†de la propri√©t√© `transform`¬†:

![Animation d'un cercle qui grossit et r√©tr√©cit](https://user.oc-static.com/upload/2021/02/09/16128907937053_Gif055.gif)

Les changements de dimension de la boule n‚Äôaffectent pas la position du bouton. En effet, la propri√©t√© transform effectue ses op√©rations √†
l‚Äô√©tape composition, ce qui ne cause aucun changement de layout (mise en page) ou de paint, donc moins de calcul pour le navigateur, et donc un
**meilleur FPS**.

G√©nial, n‚Äôest-ce pas ?

Alors, avez-vous r√©ussi √† faire grossir votre bouton ?

### En r√©sum√©

- √† l'√©cran, il n'y a pas de v√©ritable mouvement, mais une **succession d'images** s'encha√Ænant suffisamment rapidement pour √™tre interpr√©t√©es
par notre cerveau comme du mouvement ;
- cette succession d'images s'appelle les FPS (Frame Per Second, ce qui signifie _images par seconde_) ;
- plus le FPS est **√©lev√©**, plus l'animation est **fluide** ;
- le taux d‚Äôimages par seconde id√©al est **60 FPS** ;
- les quatre √©tapes de la cr√©ation d‚Äôune page web sont :
    - **Style** : le navigateur comprend la structure HTML du code qu'il re√ßoit et pr√©pare le style qui sera appliqu√©,
    - **Layout** (mise en page) : le navigateur d√©termine la mise en page et la taille des √©l√©ments en fonction du style qu'il a re√ßu,
    - **Paint** : il transforme les √©l√©ments en pixels,
    - Composition : il combine tous les √©l√©ments pour composer la page qui s‚Äôaffiche ;
- pour assurer la **fluidit√©** des animations, il faut se contenter d‚Äôanimer des propri√©t√©s de l‚Äô√©tape composition. Les plus utiles sont
`transform`¬†et `opacity`.

_Maintenant que vous comprenez tous les enjeux li√©s au choix des propri√©t√©s de ces animations, nous allons pouvoir explorer la propri√©t√© transform.
Nous verrons les nombreuses fonctions qu‚Äôelle met √† notre disposition pour cr√©er des animations fluides._

-----

## Cr√©ez des animations fluides avec la propri√©t√© CSS transform

[Cr√©ez des animations fluides avec la propri√©t√© CSS transform - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340919-creez-des-animations-fluides-avec-la-propriete-css-transform)

<Vimeo vimeoId="508777226" />

<br />

Pour nous assurer que nos animations soient aussi fluides que possibles, nos deux propri√©t√©s alli√©es sont `transform`¬†et `opacity`. Seulement deux
propri√©t√©s, √ßa vous para√Æt limit√© ?

D√©trompez-vous ! Car elles nous permettent en r√©alit√© de r√©aliser une multitude d'effets d'animation.

### D√©couvrez le potentiel de¬†`transform`

La propri√©t√© `transform`¬†s'av√®re un v√©ritable couteau suisse en termes d'animation. En effet, elle dispose de plus de **20 fonctions diff√©rentes**
pour **d√©placer**, **faire pivoter**, **d√©former** et **changer la taille** des √©l√©ments.

Dans les chapitres pr√©c√©dents, nous avons utilis√© `transform`¬†pour modifier la taille d‚Äôun bouton et d‚Äôun cercle. Nous connaissons donc sa
syntaxe et sa fonction `scale()`.

```scss
.btn {
    :hover + .ball {
        transform: scale(1);
    }
}
```

Mais pour exploiter toute la puissance de la propri√©t√© transform, nous allons commencer √† utiliser plusieurs de ses fonctions. Dans ce chapitre,
nous allons couvrir les fonctions `transform`¬†les plus utiles, et voir comment les lier entre elles pour cr√©er des animations plus complexes, tout
en respectant l'objectif de 60 FPS.

### Modifiez la taille d'un √©l√©ment avec `scale`

Pour utiliser la propri√©t√© `transform`¬†sur un √©l√©ment, nous devons lui fournir la fonction (ou les fonctions, comme on va le voir) qui
**d√©clenche** les transformations souhait√©es. Par exemple, pour faire passer un objet √† 200 % de sa taille de d√©part, on utilise la fonction
`scale()`¬†param√©tr√©e √† 2 :

```scss
.btn {
    &:hover + .box {
        transform: scale(2);
    }
}
.box {
    transition: transform 330ms ease-in-out;
}
```

Plut√¥t que d‚Äôexprimer `scale()`¬†en pourcentages, on indique des nombres, 0 pour 0 %, et 1 √©gal √† 100 %. `scale(2)`¬†fait donc grossir notre
√©l√©ment √† 200% de sa taille :

![Une animation d'un carr√© qui grossit et r√©tr√©cit sans fluidit√©](https://user.oc-static.com/upload/2021/02/09/16128909432431_Gif056.gif)

Donner une seule valeur √† la fonction `scale()`¬†modifie la **taille** de l‚Äô√©l√©ment de mani√®re **uniforme**, aussi bien en hauteur qu'en largeur.
Mais on peut √©galement lui pr√©ciser deux valeurs, une pour modifier la largeur (X), et une autre pour modifier la hauteur (Y).

Par exemple, ici, nous souhaitons garder un **volume constant**. Il faut donc affiner la largeur de la bo√Æte en m√™me temps que nous allongeons sa
longueur. Passons l‚Äô√©chelle de X √† 300%, et Y √† 50% :

```scss
.btn {
    &:hover + .box {
        transform: scale(3, 0.5);
    }
}
.box {
    transition: transform 330ms ease-in-out;
}
```

Maintenant, notre bo√Æte s‚Äô√©tire horizontalement :

![Une animation d'un carr√© qui devient un rectangle allong√©](https://user.oc-static.com/upload/2021/02/09/16128909603487_Gif057.gif)

:::note ?
Et si je veux modifier¬†ma bo√Æte dans une seule direction ? üßê
:::

On pourrait faire quelque chose comme √ßa :

```scss
.btn {
    &:hover + .box {
        transform: scale(2, 1);
    }
}
.box {
    transition: transform 330ms ease-in-out;
}
```

√áa fonctionne : l‚Äôaxe X est √† 200% et l‚Äôaxe Y √† 100%‚Ä¶ Mais il existe une m√©thode plus propre et plus explicite.

Quand on veut modifier l‚Äô√©chelle dans une seule direction, on peut utiliser les fonctions `scaleX()`¬†et `scaleY()`.¬†`scaleX()`¬†permet de modifier
un objet horizontalement, et `scaleY()`¬†verticalement.

Alors, pour passer l‚Äô√©chelle de notre bouton √† 200% horizontalement, nous pouvons utiliser `scaleX(2)`¬†:

```scss
.btn {
    &:hover + .box {
        transform: scaleX(2);
    }
}
.box {
    transition: transform 330ms ease-in-out;
}
```

![Une animation d'un carr√© qui devient un rectangle allong√©](https://user.oc-static.com/upload/2021/02/09/16128909734538_Gif058.gif)

F√©licitations ! Vous ma√Ætrisez maintenant une des fonctions les plus utiles de transform üéâ !

D√©couvrons maintenant la suite !

### Modifiez la position d'un √©l√©ment

La fonction `translate`¬†est le moyen id√©al pour modifier la **position d'un √©l√©ment** dans une animation web. `translate()`¬†prend deux valeurs en
param√®tres. La premi√®re indique la distance √† laquelle on veut se d√©placer sur l‚Äôaxe X, et la seconde la distance sur l‚Äôaxe Y.¬†Elle accepte
[diff√©rentes unit√©s](https://developer.mozilla.org/fr/docs/Apprendre/CSS/Introduction_%C3%A0_CSS/Values_and_units), comme¬†les px, les vh ou les em.
Nous pouvons donc d√©placer notre bo√Æte de 150 px vers la droite et 7 vh vers le haut, comme √ßa :

```scss
.btn {
    &:hover + .box {
        transform: translate(150px, \-7vh);
    }
}
```

```scss
.box {
    transition: transform 330ms ease-in-out;
}
```

Ce qui nous donne :

![Une animation d'un carr√© qui se d√©place en diagonale](https://user.oc-static.com/upload/2021/02/09/16128909912686_Gif059.gif)

Vous pouvez √©galement utiliser des **pourcentages**. Pour certaines propri√©t√©s CSS, les pourcentages sont calcul√©s par rapport √† leur √©l√©ment
parent. Par exemple, `width: 50%`¬†signifie la moiti√© de la largeur du parent :

![Une illustration de width: 50%](https://user.oc-static.com/upload/2019/08/25/15667221900415_Capture%20d%E2%80%99e%CC%81cran%202019-08-25%20a%CC%80%2010.36.19.png)

Mais quand on utilise des pourcentages avec `translate()`, ces pourcentages sont li√©s √† l‚Äô√©l√©ment lui-m√™me. Disons que notre √©l√©ment fait 100px de
large :

```scss
.btn {
    &:hover + .box {
        transform: translate(100px, 0);
    }
}
.box {
    width: 100px;
    height: 100px;
    transition: transform 330ms ease-in-out;
}
```

Si on se d√©place de 100 % sur l‚Äôaxe X, on se d√©place de 100 px vers la droite :

![Une animation d'un carr√© qui se d√©place √† l'horizontale](https://user.oc-static.com/upload/2021/02/09/16128910089039_Gif060.gif)

Comme nous l'avons vu avec `scale()`, il est possible de **d√©placer** des √©l√©ments sur l‚Äôaxe X et Y s√©par√©ment, gr√¢ce aux fonctions `translateX()`
et `translateY()`.

Ajoutons un peu de texte que nous allons faire appara√Ætre dans la bo√Æte :

```html
<div class="container">
    <button class="btn">Transform!</button>
    <div class="box">
        Boop!
    </div>
</div>
```

La structure convient, mais pour animer le texte s√©par√©ment de son √©l√©ment parent, nous devons l‚Äôenvelopper dans un **conteneur**. Pla√ßons-le
donc au sein d‚Äôun `<span>` :

```html
<div class="container">
    <button class="btn">Transform!</button>
    <div class="box">
        <span>Boop!</span>
    </div>
</div>
```

`<span>`¬†donne √† la propri√©t√© `transform`¬†un √©l√©ment auquel s‚Äôaccrocher pour le manipuler. R√©glons maintenant notre propri√©t√© `transform`¬†pour
qu‚Äôelle utilise `translateY()`. Cela permet d'avoir notre texte hors de la bo√Æte au d√©but de l'animation, puis de le faire d√©filer dedans :

```scss
.btn {
    &:hover + .box {
        transform: scale(1);
        span {
            transform: translateY(0);
        }
    }
}
```


```scss
.box {
    transform: scale(0.1);
    transition: transform 330ms ease-in-out;
    overflow: hidden;
    span {
        display: inline-block;
        transform: translateY(250%);
        transition: transform 280ms ease-out 50ms;
    }
}
```

Vous avez remarqu√© le changement de la valeur de display en `inline-block`¬†? En effet, la valeur de display par d√©faut de `<span>`¬†est inline. Or,
`transform`¬†ne peut pas manipuler d‚Äô√©l√©ments inline. Nous devons donc modifier le mode d‚Äôaffichage en¬†`block`¬†ou `inline-block`¬†avant d‚Äôobtenir
des r√©sultats.

:::info
Pour en apprendre plus sur les diff√©rentes valeurs de display, vous pouvez regarder le chapitre du cours sur le¬†HTML et le¬†CSS :
[Apprenez √† cr√©er votre site web avec HTML5 et CSS3](https://openclassrooms.com/fr/courses/1603881-apprenez-a-creer-votre-site-web-avec-html5-et-css3/1606402-decouvrez-dautres-techniques-de-mise-en-page)
:::

Vous avez peut-√™tre aussi remarqu√© que le texte n'appara√Æt pas tant qu'il n'est pas dans la bo√Æte : c'est la propri√©t√© `overflow: hidden;`¬†qui
nous permet cela.

Nous avons aussi ajout√© √† notre **transition** `span`¬†un petit d√©lai et raccourci sa dur√©e, pour qu‚Äôelle agisse un peu comme une animation
secondaire (principe d‚Äôanimation num√©ro 8 ! ü§ò).

![Une animation d'un petit carr√© qui grossit](https://user.oc-static.com/upload/2021/02/09/16128910224453_Gif061.gif)

### Faites pivoter vos √©l√©ments avec¬†`rotate()`

Maintenant que vous ma√Ætrisez translate¬†et scale, voyons la derni√®re fonction du trio gagnant : `rotate()`¬†!

On peut param√©trer `rotate()`¬†en plusieurs unit√©s. Nous verrons ici les plus simples √† utiliser : les degr√©s exprim√©s en "deg" et les turns. Un
turn correspond √† 360 degr√©s, ce qui est plut√¥t intuitif. Il s'agit donc de tours sur soi-m√™me.

Faisons un test ! Prenons deux bo√Ætes, chacune avec ses propres unit√©s de rotation :

```html
<div class="container">
    <button class="btn">Transform!</button>
    <div class="boxes">
        <div class="boxes__base boxes--rotDegrees">rotate(360deg)</div>
        <div class="boxes__base boxes--rotTurns">rotate(1turn)</div>
    </div>
</div>
```

Les deux bo√Ætes sont plac√©es dans la div `.boxes`. Rappelez-vous que pour animer les propri√©t√©s d‚Äôun objet en CSS, elles doivent se trouver √†
c√¥t√© de l‚Äô√©l√©ment suivant dans la hi√©rarchie. Nous pouvons donc maintenant s√©lectionner les bo√Ætes individuellement et les animer s√©par√©ment :

```scss
.btn {
    &:hover + .boxes {
        & > .boxes--rotDegrees {
            transform: rotate(0deg);
        }
        & > .boxes--rotTurns {
            transform: rotate(0turn);
        }
    }
}
```

```scss
.boxes {
    &--rotDegrees {
        transform: rotate(-360deg);
        transition: transform 500ms ease-in-out;
    }
    &--rotTurns {
        background: pink;
        transform: rotate(-1turn);
        transition: transform 500ms ease-in-out;
    }
}
```

Chaque bo√Æte d√©marre en position de rotation n√©gative de 360 deg/1 turn. Au survol du bouton, cela d√©clenche la transition. On les fait alors
tourner vers la position 0 deg/0 turn sur une demi-seconde, en utilisant la fonction de temporisation ease-in-out.

![L'animation de deux carr√©s qui font une rotation](https://user.oc-static.com/upload/2021/02/09/16128910370748_Gif062.gif)

Le r√©sultat final est exactement le m√™me pour les deux bo√Ætes. √Ä vous de choisir entre degr√©s et turns selon vos pr√©f√©rences. Pour ma part, j'ai
tendance √† pr√©f√©rer turn lorsque mon √©l√©ment fait au moins un tour sur lui-m√™me, et deg lorsqu'il s'agit de valeurs inf√©rieures √† un tour.

### Combinez les fonctions scale, position et rotate !

Reprenons la bo√Æte que nous avions utilis√©e en combinant scale et translate. Nous pouvons maintenant complexifier le tout en ajoutant une rotation
au texte.

```scss
.btn {
    &:hover + .box {
        transform: scale(1);
        transform: rotate(0deg);
        span {
            transform: translateY(0);
        }
    }
}

.box {
    overflow: hidden;
    transform: scale(.1);
    transform: rotate(-90deg);
    transition: transform 330ms ease-in-out;
    span {
        transform: translateY(250%);
        transition: transform 280ms ease-out 50ms;
        display: block;
    }
}
```

Maintenant, pendant que la bo√Æte s‚Äôagrandit et que le texte appara√Æt, elle devrait √©galement tourner d‚Äôun quart de tour, de -90 deg √† 0 deg :

![L'animation d'un carr√© qui pivote mais dont l'√©criture dispara√Æt](https://user.oc-static.com/upload/2021/02/18/16136588170894_gif063_2.gif)

Zuuuuuuut ! üò≠ On a tout cass√© !

La bo√Æte¬†pivote, mais notre animation scale a disparu. Comme si la transformation rotate() √©crasait la transformation `scale()`...

Mettons un commentaire sur notre¬†`rotate()`¬†pour v√©rifier que nous n‚Äôavons pas caus√© un probl√®me dans le¬†`scale()`¬†:

```scss
.btn {
    &:hover + .box {
        transform: scale(1);
        // transform: rotate(0deg);
        span {
            transform: translateY(0);
        }
    }
}
.box {
    overflow: hidden;
    transform: scale(.1);
    // transform: rotate(-90deg);
    transition: transform 330ms ease-in-out;
    span {
        transform: translateY(250%);
        transition: transform 280ms ease-out 50ms;
        display: block;
    }
}
```

![L'animation d'un petit carr√© qui grossit](https://user.oc-static.com/upload/2021/02/09/16128910675525_Gif064.gif)

Bon. Pourtant,¬†`scale()`¬†semble toujours fonctionner.

Le probl√®me vient du fait qu‚Äôon ne peut assigner qu‚Äôune seule propri√©t√© `transform`¬†√† un √©l√©ment. Je vous conseille de le noter dans un coin de
votre t√™te si vous voulez √©viter de vous arracher les cheveux üôÉ.

:::note ?
Alors, comment faire pour avoir plusieurs transformations dans une seule propri√©t√© `transform`¬†?
:::

Pour cela, faites une liste de toutes les fonctions que vous voulez utiliser dans la propri√©t√© `transform`.

Pour cr√©er un effet qui combine rotation et changement d'√©chelle, nous devons indiquer la fonction `rotate()`¬†√† la suite de `scale()`¬†dans la
propri√©t√© `transform`¬†:

```scss
.btn {
    &:hover + .box {
        transform: scale(1) rotate(0deg);
        span {
            transform: translateY(0);
        }
    }
}
.box {
    overflow: hidden;
    transform: scale(.1) rotate(\-90deg);
    transition: transform 330ms ease-in-out;
    span {
        transform: translateY(250%);
        transition: transform 280ms ease-out 50ms;
        display: block;
    }
}
```

Ce qui donne :

![L'animation d'un carr√© qui grossit avec du texte √† l'int√©rieur](https://user.oc-static.com/upload/2021/02/09/16128910816927_Gif065.gif)

Yaaaay ! On a r√©ussi ! Vous avez le droit √† une petite danse de la victoire üï∫.

:::caution !
L‚Äôutilisation de plusieurs fonctions a un b√©mol : l‚Äôordre dans lequel on assigne les fonctions peut avoir un gros impact sur le r√©sultat final. Il
faut savoir que le navigateur effectue les calculs de chaque fonction dans l‚Äôordre, **de droite √† gauche**.
:::

Ici, l'ordre selon lequel vous effectuez la rotation et le changement d‚Äô√©chelle ne va pas poser de probl√®me. En effet, les deux n‚Äôont pas d‚Äôeffet
l‚Äôun sur l‚Äôautre. Une rotation de 90 degr√©s suivie d‚Äôun agrandissement de 200 % aura le m√™me effet qu‚Äôun agrandissement de 200 % suivi d‚Äôune
rotation de 90 degr√©s.

Pour¬†`scale`¬†et¬†`translate`, en revanche, c‚Äôest tr√®s diff√©rent. Si on d√©place un √©l√©ment de 200 % avant de l‚Äôagrandir √† 200 %, cela aura un
r√©sultat tr√®s diff√©rent par rapport au fait de l‚Äôagrandir avant de le d√©placer :

```scss
.btn {
    &:active + .box {
        & > .box__base--tranxScale {
            transform: translateX(200%) scale(2);
        }
        & > .box__base--scaleTranx {
            transform: scale(2) translateX(200%);
        }
    }
}
.box {
    &__base {
        &--tranxScale {
            background-color: #15dea5;
            transition: transform 330ms ease-in-out;
        }
        &--scaleTranx {
            background-color: pink;
            transition: transform 330ms ease-in-out;
        }
    }
}
```

On applique `.box__base-tranxScale`¬†√† la premi√®re bo√Æte : elle va commencer par appliquer la transformation `scale()`,¬†suivie de `translateX()`.

La deuxi√®me bo√Æte fonctionne avec¬†`.box__base--scaleTranx()`¬†et appliquera la transformation `translateX()`, suivie de¬†`scale()`¬†:

![L'animation de deux carr√©s qui se d√©placent vers la droite et grossissent](https://user.oc-static.com/upload/2021/02/09/16128910946731_Gif066.gif)

La bo√Æte num√©ro 2 va bien plus loin que la premi√®re. Plus exactement deux fois plus loin. Pourquoi ? Parce que le navigateur ex√©cute les fonctions
transform dans l‚Äôordre, et il utilise le layout de d√©part comme point d‚Äôorigine pour les transformations.

En d√©composant l‚Äôordre des op√©rations de ces transformations, on voit bien la premi√®re bo√Æte passer √† 200% d‚Äô√©chelle puis se d√©placer sur la
droite de 200% de la taille originelle de la bo√Æte :

![L'animation d'un carr√© qui grossit et se d√©place vers la droite](https://user.oc-static.com/upload/2021/02/09/16128911094395_Gif067.gif)

La bo√Æte num√©ro 2, quant √† elle, se d√©place de la m√™me distance de 200%, mais au lieu de s‚Äôagrandir depuis le centre de sa nouvelle position,
elle s‚Äôagrandit vers l‚Äôext√©rieur en partant du centre d'origine avant son d√©placement :

![L'animation d'un carr√© qui se d√©place vers la droite et grossit](https://user.oc-static.com/upload/2021/02/09/16128911347225_Gif068.gif)

La bo√Æte 2 s‚Äôest d√©plac√©e vers la droite de 200%, puis la translation a √©t√©, dans les faits, doubl√©e par l‚Äô√©chelle, la faisant de fait se
d√©placer de 400% vers la droite ü§®.

### Penchez du bon c√¥t√© de la force

Position, scale, et rotation. Voil√† un arsenal d√©j√† respectable.

Mais vous avez s√ªrement d√©j√† scroll√© vers le bas de la page : vous savez bien que nous n'avons pas fini ! Voyons maintenant la fonction `skew()` !

Dans le m√™me esprit que position et scale, vous pouvez d√©sormais incliner des objets horizontalement ou verticalement. Pour cela,¬†`skew()` penche
les bords horizontaux ou verticaux, ou m√™me les deux, en utilisant les fonctions `skewX()`,¬†`skewY()`,¬†et¬†`skew()`¬†:

```scss
.box {
    &--skewX {
        transform: skewX(45deg);
    }
    &--skewY {
        transform: skewY(45deg);
    }
    &--skew {
        transform: skew(45deg, 45deg);
    }
}
```

![Les fonctions skewX(), skewY() et skew()](https://user.oc-static.com/upload/2021/02/09/16128911542346_Gif069.gif)

### Passez dans une nouvelle dimension

C‚Äôest √† peu pr√®s tout pour les capacit√©s de transform‚Ä¶ en 2D.

Eh oui ! Vous n‚Äôauriez pas oubli√© une dimension, par hasard ? üòè

Les fonctions pour les transformations en 3D sont proches des versions 2D, √† ceci pr√®s qu'elles ont √©galement la capacit√© de transformer sur
l‚Äôaxe Z. Faisons un rapide tour d'horizon des fonctions 3D disponibles avec `transform`¬†:

![Une animation des fonctions 3D disponibles avec transform](https://user.oc-static.com/upload/2021/02/15/16133837187089_Gif070.gif)

:::info
Pour effectuer une transformation d‚Äô√©chelle en 3D sur l‚Äôaxe Z, il faut d‚Äôabord l‚Äôavancer vers l‚Äôavant ou l‚Äôarri√®re en utilisant `translateZ()`
ou `translate3d()`. Sinon,¬†`scaleZ()`¬†ou¬†`scale3d()`¬†verrait son √©chelle modifi√©e de 0‚Ä¶ ce qui n‚Äôaurait aucun effet, √©videmment.
:::

Si les fonctions 3D ressemblent beaucoup aux fonctions 2D, vous avez peut-√™tre remarqu√© une nouvelle fonction : `perspective()`.

La valeur qu‚Äôon donne √† `perspective()`¬†indique au navigateur √† quelle "distance" se trouve le spectateur. Comme dans le monde r√©el, plus un
objet est proche, plus le mouvement aura l‚Äôair important, alors qu‚Äô√† l‚Äôinverse, un objet distant semblera plus statique.

```scss
.box {
    &--perspective75px {
        transform: perspective(75px) rotateX(45deg);
    }
    &--perspective150px {
        transform: perspective(150px) rotateX(45deg);
    }
    &--perspective300px {
        transform: perspective(300px) rotateX(45deg);
    }
}
```

Avec une perspective de 75 px, on se retrouve bien plus proche de la bo√Æte qu‚Äô√† 150 ou 300px. La rotation 3D semble donc bien plus marqu√©e que
les transformations dont la perspective est plus grande.

![Des animations perspectives avec diff√©rents pixels](https://user.oc-static.com/upload/2021/02/09/16128913219948_Gif071.gif)

On peut utiliser la perspective et les transformations 3D pour ajouter de la profondeur et des effets visuels √† nos animations.

Vous voyez bien que plus le cours avance, plus nous repoussons les limites de ce qu'il est possible de faire en animations CSS ! Bient√¥t, votre
cr√©ativit√© n'aura plus de limite. üßô‚Äç‚ôÇÔ∏è

### En r√©sum√©

- la propri√©t√© `transform`¬†nous permet de manipuler et animer nos sites de presque toutes les mani√®res, et comme tout se passe pendant l‚Äô√©tape
composition, les animations sont bien fluides sur tous les supports ;
- on peut d√©placer des √©l√©ments avec les fonctions translate :¬†`translate()`, `translateX()`, `translateY()`¬†et `translate3d()`¬†;
- on peut agrandir avec les fonctions scale : `scale()`, `scaleX()`, `scaleY()`¬†et `scale3d()`¬†;
- et on peut les faire pivoter gr√¢ce aux fonctions rotate : `rotate()`, `rotateX()`, `rotateY()`¬†et `rotateZ()`¬†;
- si on ajoute une deuxi√®me propri√©t√© `transform`, elle annule la premi√®re. On ne peut donc d√©finir qu‚Äôune seule propri√©t√© `transform`¬†dans un
m√™me s√©lecteur ;
- pour effectuer plusieurs transformations, on peut les lister dans une m√™me propri√©t√© transform comme¬†:

```scss
transform: translateX(200%) scale(2);
```

- une propri√©t√© avec plusieurs fonctions ex√©cute les fonctions dans l‚Äôordre, de droite √† gauche ;
- les fonctions de transformations en 3D comme¬†`translate3d()`, `rotateZ()`¬†et `scale3d()`¬†ont √©galement besoin de la fonction perspective pour
indiquer au navigateur la distance √† laquelle l'utilisateur se trouve : plus la distance est grande, moins l'animation sera marqu√©e.

_Dans le chapitre suivant, nous verrons comment effectuer des animations un peu plus sp√©cifiques, telles qu'un mouvement de balancier. Rendez-vous
au chapitre suivant !_

-----

## Modifiez le point d‚Äôancrage d‚Äôun √©l√©ment gr√¢ce √† transform-origin

[Modifiez le point d‚Äôancrage d‚Äôun √©l√©ment gr√¢ce √† transform-origin - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340920-modifiez-le-point-d-ancrage-d-un-element-grace-a-transform-origin)

<Vimeo vimeoId="508777270" />

<br />

`Transform`¬†nous permet de cr√©er une **multitude** d'effets de mouvement : nous pouvons absolument tout faire‚Ä¶

Sauf un mouvement de balancier‚Ä¶

Ou changer d‚Äô√©chelle du haut vers le bas‚Ä¶ üôÉ

Mais comme toujours en CSS, il y a une solution !

### D√©couvrez le point d'ancrage

Par d√©faut, toutes les fonctions de¬†`transform`¬†partent du **centre** de l‚Äô√©l√©ment. Donc quand on change l‚Äô√©chelle d‚Äôun objet, il s‚Äôagrandit
vers l‚Äôext√©rieur :

![Le changement d'√©chelle se fait depuis le centre](https://user.oc-static.com/upload/2021/02/09/16128913910144_Gif073.gif)

Et quand on fait **pivoter** un √©l√©ment, il reste sur son axe :

![Le pivotement se fait sur un axe](https://user.oc-static.com/upload/2021/02/09/16128914606847_Gif074.gif)

Et souvent, c‚Äôest tr√®s bien. Mais parfois, √ßa ne suffit pas.

La propri√©t√© `transform-origin`¬†est l√† pour √ßa ! Elle permet de d√©placer un **point d‚Äôancrage** o√π on veut, pour faire partir nos animations de
ce point.

Nous pouvons par exemple d√©placer le point d‚Äôorigine d'un √©l√©ment √† son sommet et le faire grandir :

![Un exemple de la propri√©t√© transform-origin](https://user.oc-static.com/upload/2021/02/09/16128914904677_Gif075.gif)

Nous pouvons mettre le point dans un coin et **faire balancer** l‚Äôobjet :

![Exemple de la propri√©t√© transform-origin](https://user.oc-static.com/upload/2021/02/09/16128915071518_Gif076.gif)

Dans ce chapitre, allons apprendre √† ma√Ætriser la propri√©t√© `transform-origin`¬†pour apprendre √† faire tout cela. C'est parti !

### D√©placez le centre

C'est √† nouveau la propri√©t√© `transform`¬†qui sera notre alli√©e ici.

Cr√©ons donc une barre de chargement, avec une image vide qui se remplit pendant le chargement : sa progression ne correspond pas r√©ellement au
pourcentage de chargement, mais sert de transition entre deux blocs de contenu.

```html
<div class="container">
    <div class="btn">Charger!</div>
    <div class="progress">
        <div class="progress__bar"></div>
    </div>
</div>
```

Nous avons stylis√© l‚Äôimage avec une bordure et un peu de marge int√©rieure, et la barre avec une couleur de fond, qui s‚Äôaffiche comme √ßa :

![Barre de chargement pleine](https://user.oc-static.com/upload/2019/08/26/15668421113643_Capture%20d%E2%80%99e%CC%81cran%202019-08-26%20a%CC%80%2019.54.53.png)

Maintenant, ajoutons la propri√©t√© `transform`¬†√† notre barre, et servons-nous de la fonction scale-x qui nous est d√©j√† famili√®re sur 0 :

```scss
.progress {
    &__bar {
        transform: scaleX(0);
    }
}
```

Et voil√† notre barre de progression vide !

![Barre de chargement vide](https://user.oc-static.com/upload/2019/08/26/15668421300869_Capture%20d%E2%80%99e%CC%81cran%202019-08-26%20a%CC%80%2019.54.47.png)

Nous pouvons utiliser le pseudos√©lecteur `:active`¬†pour la remplir afin d'agrandir la barre √† 100% de largeur quand on clique sur le bouton
‚ÄúCharger‚Äù.

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
```

```scss
.progress {
    &__bar {
        transform: scaleX(0);
    }
}
```

Maintenant, quand on clique sur le bouton, la barre de chargement se remplit‚Ä¶¬†imm√©diatement.

![Barre de chargement imm√©diat](https://user.oc-static.com/upload/2021/02/09/16128917971846_Gif077.gif)

Mais nous sommes dans un cours d'animation ici ! Nous voulons donc remplir la barre petit √† petit. Pour cela, ajoutons donc une transition, en
l‚Äôanimant sur une dur√©e de 2 secondes :


```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform: scaleX(0);
        transition: transform 2000ms;
    }
}
```

Voyons voir comment notre barre se comporte maintenant :

![La barre de chargement qui se remplit depuis le centre, dans les deux sens](https://user.oc-static.com/upload/2021/02/09/16128918089565_Gif078.gif)

Heuuuu, ce n'est pas exactement l'effet que nous recherchions. Quoique, on va peut-√™tre lancer une nouvelle mode ? üòè

Les barres de chargement se remplissent normalement depuis la gauche vers la droite. Ici, la barre se remplit, mais en partant du milieu. Pour
corriger notre barre, nous pouvons maintenant **tester** la propri√©t√© `transform-origin`.

`transform-origin`¬†nous permet de d√©placer le centre d'origine de notre transformation, selon les valeurs que nous lui assignons.

Pour d√©placer le centre d‚Äôorigine, on peut utiliser des **unit√©s** comme les **pixels**, ou un pourcentage des dimensions d‚Äôun √©l√©ment, de la
m√™me mani√®re que pour la fonction `translate`. Dans les deux cas, l‚Äôaxe X est mesur√© √† partir de la bordure gauche de l‚Äô√©l√©ment, et l‚Äôaxe Y est
mesur√© depuis le bord sup√©rieur.

Le point d‚Äôorigine par d√©faut, au centre de l‚Äô√©l√©ment, peut donc √™tre √©crit de cette mani√®re : `transform-origin: 50% 50%`¬†;

Ici, nous voulons placer le **point d‚Äôorigine** de notre barre de chargement sur sa bordure gauche, pour qu‚Äôelle progresse vers la droite. Nous
devons donc mettre l'origine de x √† 0% :

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform-origin: 0% 50%;
        transform: scaleX(0);
        transition: transform 1000ms;
    }
}
```

On devrait voir la barre √™tre vide au d√©part. Puis au clic sur le bouton, elle devrait s‚Äôagrandir vers la droite jusqu‚Äô√† remplir le cadre :

![Une animation CSS d'une barre de chargement compl√®te](https://user.oc-static.com/upload/2021/02/09/16128918195266_Gif079.gif)

Parfait ! Mettons notre touche finale en ajoutant notre propre fonction de timing `cubic-bezier()`. Nous voulons que la barre commence avec un
ease-in peu prononc√©, mais que son ease-out soit bien perceptible √† la fin. Le profil de la courbe ressemblerait √† quelque chose comme √ßa :

![La courbe de notre animation](https://user.oc-static.com/upload/2019/08/06/15650825274307_image24.png)

Les valeurs de notre courbe d‚Äôacc√©l√©ration sont `cubic-bezier(.32, 0, .07, 1)`. Rentrons-les dans notre fonction de timing :

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform-origin: 0% 50%;
        transform: scaleX(0);
        transition: transform 1000ms cubic-bezier(.32,0,.07,1);
    }
}
```

![La barre de chargement fonctionne](https://user.oc-static.com/upload/2021/02/09/1612891847843_Gif080.gif)

Et c'est encore une r√©ussite pour vous ! Bravo !üí™

### Utilisez la bonne valeur

Les valeurs de `transform-origin`¬†ne se limitent pas √† des longueurs ou des pourcentages.

On peut aussi utiliser des mots cl√©s CSS pour d√©finir les points d‚Äôancrage, comme `left`¬†pour le mettre sur le bord gauche, ou `right`¬†pour le
mettre √† droite :

```scss
.box--left-origin {
// positionne l'origine du c√¥t√© gauche
    transform-origin: left 50%;
}
.box--right-origin {
// positionne l'origine du c√¥t√© droit
    transform-origin: right 50%;
}
```

![Animation de Transform-origin left et right](https://user.oc-static.com/upload/2021/02/09/16128918891629_Gif081.gif)

On peut aussi utiliser `top`¬†et `bottom`¬†:

```scss
.box--top-origin {
// positionne l'origine au sommet de l'√©l√©ment
    transform-origin: 50% top;
}
```

```scss
.box--bottom-origin {
// positionne l'origine en bas de l'√©l√©ment
    transform-origin: 50% bottom;
}
```

![Animation de transform-origin top et bottom](https://user.oc-static.com/upload/2021/02/09/16128919050559_Gif082.gif)

Concr√®tement, les mots cl√©s `left`¬†et `top`¬†correspondent √† 0%, tandis que `right`¬†et¬†`bottom`¬†correspondent √† 100%. Mais l'utilisation de ces
mots cl√©s permet d'√™tre explicite dans la mani√®re d'√©crire notre code.

Le dernier mot cl√© est `center`. Il peut √™tre assign√© √† l‚Äôaxe X ou Y, et correspond √† une valeur de 50 :

```scss
.box--left-origin {
// positionne l'origine au centre de l'√©l√©ment
    transform-origin: center center;
}
```

![Animation de transform-origin center](https://user.oc-static.com/upload/2021/02/09/1612891919281_Gif083.gif)

Jusqu‚Äô√† maintenant, nous avons toujours assign√© deux valeurs √† `transform-origin`, une pour X et l‚Äôautre pour Y. Mais une seule valeur peut
aussi suffire. Si cette valeur est un nombre, elle s‚Äôappliquera √† l‚Äôaxe X et laissera Y √† la valeur par d√©faut de 50 %.

Dans le cas de notre barre de progression, c'est surtout la valeur de X qui nous int√©resse. La valeur de 50 % pour l‚Äôaxe Y est donc superflue.
Retirons cette valeur, ce qui simplifie le code et montre plus explicitement que nous modifions l'axe X quand nous relirons le code dans le
futur :

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform-origin: 0%;
        transform: scaleX(0);
        transition: transform 1000ms cubic-bezier(.32,0,.07,1);
    }
}
```

Notre code est plus propre et fonctionne toujours de la m√™me mani√®re dans le navigateur :

![La barre de chargement fonctionne de la m√™me fa√ßon](https://user.oc-static.com/upload/2021/02/09/16128919347965_Gif084.gif)

Et le navigateur n'a pas fini de nous √©tonner :¬†si on assigne un simple mot cl√© √† `transform-origin`, le navigateur va comprendre de lui-m√™me √†
quel axe l‚Äôappliquer, et laisser l‚Äôautre axe sur sa valeur par d√©faut.

Il est plus explicite d‚Äôutiliser le mot cl√© `left`¬†plut√¥t que de mettre un `transform-origin` √† 0%, car cela nous indique instantan√©ment que
nous avons d√©plac√© le `transform-origin` sur le c√¥t√© gauche. Revenons une derni√®re fois √† notre barre de chargement et rempla√ßons la valeur
num√©rique de `transform-origin`¬†par le mot cl√© `left`, pour rendre notre code aussi clair et concis que possible :

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0);
        transition: transform 1000ms cubic-bezier(.32,0,.07,1);
    }
}
```

### Passez dans la troisi√®me dimension

Nous avons vu que la propri√©t√© `transform`¬†permet de **manipuler** des √©l√©ments en deux dimensions... mais aussi en trois. Et `transform-origin`
fonctionne parfaitement avec des valeurs X et Y en 2D. Mais comment faire pour changer le point d‚Äôorigine de transformations 3D ?

Vous l‚Äôavez peut-√™tre devin√© üòé : on ajoute une troisi√®me valeur √† la liste ! On peut utiliser les valeurs X et Y comme en 2D, avec des
pourcentages ou des mots-cl√©s, mais l‚Äôaxe Z DOIT obligatoirement √™tre d√©fini avec des unit√©s r√©elles comme les pixels, les centim√®tres, etc.

```scss
.btn {
    perspective: 500px;
    &:active {
        & > .btn__flip {
            transform: rotateX(-90deg);
        }
    }
    &__flip {
        transform-style: preserve-3d;
        transform-origin: center bottom 7.5vw;
        transition: transform 500ms cubic-bezier(.7, 0, .23, 1);
        &--off {
            transform: rotateX(0deg) translateZ(7.5vw);
        }
        &--on {
            transform: rotateX(90deg) translateZ(7.5vw);
        }
    }
}
```

Alors, tentons de combiner les fonctions de transformation 3D avec des valeurs transform-origin 3D pour cr√©er des objets √† trois dimensions,
comme des boutons √† plusieurs faces !

![Un bouton en 3D](https://user.oc-static.com/upload/2021/02/09/16128919491569_Gif085.gif)

Vous trouverez le code source de notre bouton sur [ce CodePen](https://codepen.io/atoulmet/pen/aboJmOx).

_Avez-vous essayer de changer la vitesse de l'animation ou la couleur des faces du bouton ?_

Et chose promise, chose due. Je vous parlais dans la vid√©o d'introduction d'un fameux sabre Jedi : voici ce que donne une animation CSS de sabre
Jedi avec la propri√©t√©¬†`transform-origin`. Le [code source est ici](https://codepen.io/atoulmet/pen/RwbRRaK).

![Animation d'un sabre Jedi qui s'allume](https://user.oc-static.com/upload/2021/02/09/16128919632702_Gif086.gif)

Encore une fois, n'h√©sitez pas √† manipuler les valeurs indiqu√©es.

### En r√©sum√©

- `transform-origin`¬†permet de **repositionner** le point d‚Äôancrage, qui se trouve par d√©faut au centre de l‚Äô√©l√©ment ;
- on peut **r√©gler** ce point d‚Äôorigine en utilisant des unit√©s comme px, rem, vh, etc. ;
- il est aussi possible d'utiliser des pourcentages pour X et Y ;
- ou encore, on peut utiliser des mots cl√©s : `left`¬†et¬†`right`¬†pour l‚Äôaxe X, `top`¬†et `bottom`¬†pour l‚Äôaxe Y, et `center`¬†pour les deux ;
- il est possible de ne pas indiquer la valeur de l'axe Y ou, quand on utilise des mots cl√©s, de mettre uniquement une valeur : le navigateur
comprend de lui-m√™me √† quel axe la valeur s'applique ;
- quand on change le point d‚Äôorigine en 3D, la valeur de Z doit √™tre exprim√©e en unit√©s (et non en pourcentages) !

_Cr√©er des animations, c'est bien, mais pouvoir analyser leurs performances, c'est mieux. C'est ce que vous allez d√©couvrir dans le chapitre
suivant._

-----

## Analysez la performance de vos animations avec Chrome DevTools

[Analysez la performance de vos animations avec Chrome DevTools - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340921-analysez-la-performance-de-vos-animations-avec-chrome-devtools)

<Vimeo vimeoId="508777299" />

<br />

Nous avons pass√© un temps consid√©rable √† apprendre comment optimiser nos animations, mais‚Ä¶

Comment savoir si √ßa marche ?

Pour le moment, vous avez d√ª me croire sur parole concernant les propri√©t√©s √† bannir.

Car toutes vos animations sont probablement parfaitement fluides sur votre machine‚Ä¶ (oui oui, je dis "machine" pour "ordinateur" ü§ñ) mais si
vous apprenez √† d√©velopper, c'est que vous √™tes probablement sur un ordinateur **puissant**, √©quip√© d‚Äôune carte graphique moderne (sans vouloir
vous juger sans vous conna√Ætre). Mais comment savoir si l‚Äôanimation sera bien fluide sur la tablette bas de gamme achet√©e en soldes par votre
grand-p√®re ?

Heureusement pour nous, Chrome propose toute une suite d‚Äôoutils int√©gr√©s. Vous les avez peut-√™tre d√©j√† utilis√©s en inspectant le code source
d‚Äôun site web, ou en ouvrant la console. Mais ce n‚Äôest qu'une toute petite partie de l'ensemble de ces outils, aussi appel√©s DevTools.

**DevTools** met √† notre disposition de nombreux outils. Notamment un qui simule le fonctionnement de nos animations sur un vieux smartphone. Il
permet √©galement d'**analyser** en d√©tail les performances de notre animation, afin d'identifier les probl√®mes potentiels et de les corriger.

Dans ce chapitre, nous apprendrons √† ma√Ætriser l'outil de performance de **Chrome DevTools** pour que nos animations soient aussi fluides que
possible.

### Faites appara√Ætre des √©l√©ments cach√©s

Ici, nous avons une petite application. Elle repr√©sente une s√©rie de cartes, chaque carte munie d‚Äôune photo et de quelques blocs de texte. Il y
a √©galement un bouton qui r√©v√®le une troisi√®me carte cach√©e :

![Animation d'un bloc de texte cach√© derri√®re un autre](https://user.oc-static.com/upload/2019/08/06/15650844369654_pt02ch04-fall1.gif)

L‚Äôapparition de la carte cach√©e est constitu√©e de plusieurs transitions : l‚Äôapparition de la carte elle-m√™me, et une deuxi√®me transition qui
pousse l‚Äôautre carte sur la droite.

```scss
$easing: cubic-bezier(.49,.18,.23,1);
$width: 33vh;
$height: 72vh;
$margin-right: 4vh;
$wid-marg: $width + $margin-right;
.card {
    width: $width;
    height: $height;
    overflow: hidden;
    &:not(:last-child) {
        margin-right: $margin-right;
    }
    &--anim {
        transform: translateX($width-marg);
        transition: transform 700ms $easing;
    }
    &__contents {
        width: $width;
        overflow: hidden;
        &--anim {
            transform: translateX($wid-marg*-1);
            transition: transform 700ms $easing;
        }
    }
}
.btn {
    &--reveal {
        &:hover {
            & + .card {
                &--anim {
                    transform: translateX(0);
                }
                .card__contents--anim {
                    transform: translateX(0);
                }
            }
        }
    }
}
```

On a aussi ajout√© quelques mouvements secondaires (souvenez-vous des 12 principes) avec plusieurs transitions pour r√©v√©ler les blocs de texte de
la carte :

```scss
</>
$easing: cubic-bezier(.49,.18,.23,1);
$width: 33vh;
$height: 72vh;
$margin-right: 4vh;
$wid-marg: $width + $margin-right;
.card {
    width: $width;
    height: $height;
    overflow: hidden;
    &:not(:last-child) {
        margin-right: $margin-right;
    }
    &--anim {
        transform: translateX($width-marg);
        transition: transform 700ms $easing;
    }
    &__contents {
        width: $width;
        overflow: hidden;
        &--anim {
            transform: translateX($wid-marg*-1);
            transition: transform 700ms $easing;
        }
    }
    &__block {
        overflow: hidden;
        // une boucle cr√©√©e avec sass qui it√®re de 1 √† 3, en utilisant l'index
        // comme suffixe pour le nom --anim mod
        // ainsi que comme valeur pour multiplier la valeur de transition delay
        @for $i from 1 through 3 {
            &--anim-#{$i} {
                transform: translateX(-108%);
                transition: transform 500ms $easing 50ms*$i;
            }
        }
        &:not(:first-child) {
            margin-top: 1rem;
        }
    }
}
.btn {
    &--reveal {
        &:hover {
            & + .card {
                &--anim {
                    transform: translateX(0);
                }
                .card__contents--anim {
                    transform: translateX(0);
                }
                .card__block--anim {
                    transform: translateX(0);
                }
            }
        }
    }
}
```

Toutes ces animations sont bien fluides sur notre ordinateur, mais √ßa ne suffit pas. Nous voulons qu‚Äôelles soient fluides sur tous les √©crans,
y compris sur des supports anciens ou bas de gamme. Au total, l‚Äôapparition de la carte est constitu√©e de 5 transitions distinctes. Comment nous
assurer qu‚Äôelles fonctionneront bien de mani√®re fluide chez tout le monde ?

Vous pouvez laisser un bon d'achat pour commander un appareil moderne sur votre site, mais √ßa risque peut-√™tre d'√™tre co√ªteux ü§î.

Mais il existe un moyen plus facile et moins on√©reux de tester et d'analyser nos animations.

Mesdames et Messieurs, permettez-moi de vous pr√©senter Chrome Devtools ! ü•≥

Eh oui, je vous en parlais, c‚Äôest ce qui appara√Æt quand on clique sur ‚ÄúInspecter‚Äù sur une page web. Il fait bien plus que nous aider √†
comprendre comment une page est organis√©e.

Au-del√† de l‚Äôonglet **Elements**, DevTools comporte toute une s√©rie d‚Äôautres onglets pour inspecter, d√©boguer et analyser divers aspects de nos
sites. Ici, c'est l‚Äôonglet **Performance** qui va nous int√©resser. Il nous permet d‚Äôenregistrer et d‚Äôanalyser comment une page se charge, r√©agit,
et s‚Äôanime.

√áa para√Æt √™tre pas mal pour √©valuer la performance de nos animations, non ? Alors ouvrons DevTools et voyons √ßa !

### Ouvrez la bo√Æte √† outils DevTools

Avant de commencer l‚Äôexploration de l‚Äôonglet **Performance**, nous devons ouvrir DevTools. Vous avez probablement l‚Äôhabitude de faire un clic
droit sur un √©l√©ment d‚Äôune page et de choisir ‚ÄúInspecter‚Äù.

Mais il existe un moyen plus rapide pour le faire. DevTools peut √™tre ouvert par le raccourci clavier Ctrl+Shift+I sous Windows, ou Cmd+Opt+I
sur Mac.

Une fois DevTools ouvert, en haut de la fen√™tre, on peut trouver une s√©rie de boutons qui am√®nent √† diff√©rents onglets. Si l‚Äôonglet Performance
n‚Äôest pas visible √† droite de l‚Äôonglet √âl√©ments, selon la taille de votre fen√™tre, vous pouvez l‚Äôouvrir en cliquant sur la double fl√®che √†
droite, et en s√©lectionnant ‚ÄúPerformance‚Äù dans le menu qui appara√Æt :

![Une vid√©o montrant comment acc√©der √† l'onglet Performance](https://user.oc-static.com/upload/2021/02/15/16133895775464_2C4_1.gif)

Maintenant que l‚Äôonglet Performance est ouvert, nous arrivons sur une fen√™tre plut√¥t spartiate¬†en apparence. En effet, celle-ci contient juste
quelques boutons et des instructions disant que nous pouvons cliquer sur le bouton ‚ÄúRecord‚Äù pour enregistrer, ou cliquer sur le bouton du
dessous pour enregistrer le chargement de la page :

![Illustration du bouton record](https://user.oc-static.com/upload/2021/02/15/16133895917719_2C4_2.gif)

Mais avant de cliquer sur l‚Äôun de ces boutons, ajustons un peu notre installation. En haut de la fen√™tre se trouve une case ‚ÄúScreenshots‚Äù. Si on
coche la case, Chrome prendra une capture d‚Äô√©cran de chaque image de l‚Äôenregistrement, nous permettant ainsi de visionner le d√©roulement de
l‚Äôanimation image par image. Cette option n‚Äôest pas toujours n√©cessaire pour analyser les performances d‚Äôun site, comme quand il s‚Äôagit de
performances r√©seau, mais l‚Äôanimation est un domaine tr√®s visuel, l‚Äôoption screenshot peut donc s'av√©rer particuli√®rement utile. Nous allons
donc cocher cette case Screenshots :

![Une image montrant comment acc√©der √† Screenshots](https://user.oc-static.com/upload/2019/08/06/15650858539635_image51.png)

Nous voil√† presque pr√™ts √† commencer l‚Äôenregistrement. Mais avant, il nous reste une derni√®re chose √† faire. Rappelez-vous que nous voulons voir
nos animations telles qu‚Äôelles apparaissent sur des appareils plus lents. Or, si on enregistre maintenant, on verra seulement l‚Äôanimation
s‚Äôex√©cuter sur notre ordinateur. Pour rem√©dier √† cela, l‚Äôonglet Performance nous permet de brider la vitesse de notre processeur.

En cliquant sur la roue de param√©trages dans le coin en haut √† droite, quatre options apparaissent, dont l‚Äôoption ‚ÄúCPU throttling‚Äù. Simulons
l‚Äôappareil le plus lent possible en choisissant 6X, qui limite notre processeur √† une vitesse six fois plus lente que ses capacit√©s (n'oubliez
surtout pas de d√©cocher cette case quand vous aurez termin√©, sinon votre navigateur pourrait tr√®s rapidement vous rendre compl√®tement fou üòÇ) :

![Vid√©o montrant comment acc√©der √† l'option CPU throttling](https://user.oc-static.com/upload/2019/08/06/15650859455803_image20.gif)

### Observez les performances dans le d√©tail

Nous voil√† fin pr√™ts √† commencer l‚Äôinspection de nos animations ! Les performances de la page ne nous pr√©occupent pas pour l‚Äôinstant, donc nous
pouvons imm√©diatement appuyer sur le bouton **Record**. Quand on clique sur ce bouton Record, une fen√™tre de dialogue appara√Æt pour nous informer
que l‚Äôenregistrement du site a commenc√©. Nous pouvons donc maintenant interagir avec notre bouton pour lancer les transitions. Une fois que les
animations sont termin√©es, on peut cliquer sur le bouton ‚ÄúStop‚Äù dans la fen√™tre de progression :

![Une vid√©o montrant l'analyse de l'animation](https://user.oc-static.com/upload/2019/08/06/15650860661535_pt02ch04-fall2.gif)

Et c‚Äôest tout ! DevTools prend un instant pour traiter les donn√©es recueillies, puis les affiche dans l‚Äôonglet Performance.

D√©composons maintenant tout cela √©tape par √©tape.

![D√©tail de l'outil Performances des Devtools](https://user.oc-static.com/upload/2019/09/01/15673473741049_Capture%20d%E2%80%99e%CC%81cran%202019-09-01%20a%CC%80%2016.15.55.png)

Tout en haut, on trouve l‚Äôavancement de l‚Äôenregistrement, en millisecondes. Sur cette ligne, des graphiques verts suivent les¬†FPS de notre site ;
les **plateaux** correspondent aux **√©v√©nements** d‚Äôanimation que nous allons d√©tailler dans un instant. Et juste sous cette ligne d‚Äôavancement
se trouve une succession des images que DevTools a enregistr√©es.

Quand on passe la souris sur un des aper√ßus, il s‚Äôagrandit et nous montre exactement √† quoi ressemblait le site √† ce moment pr√©cis :

![Une animation d'un bloc de texte cach√© derri√®re un autre](https://user.oc-static.com/upload/2019/08/06/15650861771846_pt02ch04-fall3.gif)

Regardons notre animation de plus pr√®s en zoomant sur une des zones vertes. Pour cela, cliquez puis faites glisser votre souris sur la zone qui
vous int√©resse, ou bien utilisez la molette de la souris :

![L'animation analys√©e dans Devtools](https://user.oc-static.com/upload/2019/08/06/15650862998667_pt02ch04-fall4.gif)

Maintenant que nous sommes entr√©s dans les d√©tails de la partie animation de l‚Äôenregistrement, concentrons-nous sur les cases vertes plus bas.
Elles correspondent aux images de notre animation. En passant la souris dessus, nous pouvons voir le temps de calcul de chaque image, et le
nombre de¬†FPS¬†:

![La calcul du FPS de l'animation](https://user.oc-static.com/upload/2021/02/15/161339026635_Gif091%20%282%29.gif)

On peut constater des changements assez faibles entre chaque image, ce qui est normal, mais globalement, chaque image est proche de notre
objectif de 60¬†FPS : c'est parfait ! Nous pouvons donc affirmer avec certitude que nos transitions seront bien fluides, m√™me sur un appareil six
fois plus lent que notre ordinateur.

### Passez vos images au crible

Allons voir ce qui se passe lorsque le navigateur calcule une image dans une animation. Pour cela, choisissez une image et zoomez au maximum.

![Le zoom pour mieux visualiser le moment de l'animation que l'on cherche](https://user.oc-static.com/upload/2021/02/15/16133901802579_Gif092%20%281%29.gif)

Maintenant que nous avons isol√© une image dans l‚Äôanimation, int√©ressons-nous √† la section ‚Äú**Main**‚Äù de l‚Äôonglet Performance. Cette section
permet de voir tous les calculs qui ont transform√© notre code en une page web anim√©e. Les calculs sont r√©partis en cat√©gories identifi√©es par
des codes couleurs.

Les blocs violets repr√©sentent les calculs de base qui permettent l‚Äôaffichage d‚Äôune page web, comme l‚Äôanalyse du CSS et le calcul des styles.

![Repr√©sentation des blocs violets](https://user.oc-static.com/upload/2019/08/06/15650867171194_image47.png)

Les blocs jaunes indiquent des calculs de l'√©tape layout, mais‚Ä¶ hourra, il n‚Äôy en a pas ici ! Qu'est-ce que je vous avais dit ? üòè Gr√¢ce √† la
propri√©t√© `transform`, nous avons √©vit√© tout calcul de layout, bien trop gourmand en calcul, ce qui aurait d√©grad√© notre FPS.

Mais si notre image ne comporte pas de calculs de layout, elle comprend bien une case verte, qui repr√©sente un calcul de paint ou de composition.
En passant la souris dessus, nous voyons qu‚Äôil s‚Äôagit bien d‚Äôun calcul de composition. Notre animation n‚Äôa pas non plus besoin de calculs de
paint :

![Calcul de paint ou de composition](https://user.oc-static.com/upload/2019/08/06/1565086815764_image44.png)

Plus besoin de me croire sur parole maintenant : vous le constatez par vous-m√™me ! La propri√©t√© transform nous permet de cr√©er des animations
abouties en √©vitant des calculs complexes pour notre navigateur. Et moins de calculs signifie plus d‚Äôimages par seconde, donc une meilleure
fluidit√© ! üöÄ

### En r√©sum√©

- **Chrome DevTools** est l'outil de pr√©dilection des d√©veloppeurs. Il permet d'**inspecter** le code source d'une page, d'**analyser** les
performances de notre page, de **brider** la performance de notre machine pour simuler un appareil plus lent. Pour cette derni√®re option, activez
l‚Äôoption ‚ÄúCPU throttling‚Äù ;
- l'outil **Performance** permet d'analyser les performances d‚Äôune page, notamment le taux d‚Äôimages par seconde d‚Äôune animation ;
- on peut utiliser l‚Äôonglet Performance pour analyser nos animations, ce qui permet de rep√©rer les probl√®mes dans notre code qui pourraient
causer des probl√®mes de fluidit√© sur certains supports ;
- **zoomer** sur une image pr√©cise d‚Äôune animation permet de d√©tailler les calculs effectu√©s par le navigateur, que nous avions vus dans le
chapitre sur le fonctionnement du navigateur.

_Dans le chapitre suivant, nous aborderons enfin l'autre propri√©t√© dont nous disposons pour assurer un FPS optimal : opacity. Nous apprendrons √†
ma√Ætriser cette propri√©t√© pour cr√©er des animations en couleur sans d√©clencher de calcul de type paint dans le navigateur. Alors, √† tout de suite !_

-----

## Animez les couleurs de mani√®re performante avec opacity

[Animez les couleurs de mani√®re performante avec opacity - Cr√©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340922-animez-les-couleurs-de-maniere-performante-avec-opacity)

<Vimeo vimeoId="508777316" />

<br />

La propri√©t√© `transform`¬†permet de r√©pondre √† la plus grande partie de nos besoins en animation, mais poss√®de une lacune : la gestion de la
couleur.

Pourtant, la couleur d‚Äôun √©l√©ment est un aspect fondamental de l‚Äôanimation. Alors comment faire ?

:::note ?
Est-ce que √ßa veut dire qu‚Äôon doit laisser tomber l‚Äôanimation de couleur ? üò±
:::

Pas de panique,¬†la propri√©t√© `opacity`¬†sera notre solution.

Pour cela, il nous faudra adopter une approche un peu diff√©rente dans la mani√®re d'√©crire notre code.

Jusqu‚Äôici, nous avons √©crit notre HTML structurellement, c‚Äôest-√†-dire que chaque √©l√©ment fait partie int√©grante de notre layout.

Ici, nous allons devoir mettre la fonctionnalit√© en avant, en cr√©ant des √©l√©ments non pas pour le layout, mais uniquement pour servir notre
animation.

Dans ce chapitre, nous allons voir comment organiser notre code pour cr√©er des animations de couleurs en utilisant uniquement la propri√©t√©
opacity.

### √âvitez le paint (attention peinture fra√Æche)

Revenons sur notre bouton. Cette fois-ci, au survol de la souris, il change de couleur :

![Une animation CSS d'un bouton qui change de couleur](https://user.oc-static.com/upload/2021/02/18/16136589804856_Gif093.gif)

Ce type d'animation est parfait pour permettre √† l‚Äôutilisateur de comprendre qu‚Äôil peut interagir avec cet √©l√©ment. Les changements de couleur
sont une composante essentielle de l'exp√©rience utilisateur sur un site. Mais plut√¥t que de faire changer la couleur instantan√©ment, l‚Äôajout
d‚Äôune courte transition pourrait rendre l‚Äô√©tat `:hover`¬†un peu plus fluide et naturel.

Si on regarde le code, on peut constater que le bouton est un √©l√©ment `<button>`¬†auquel est assign√©e la classe `.btn`¬†:

```scss
<button class="btn">Survole moi!</button>
```

Et la variable¬†`$clr-btn`¬†donne √† `.btn`¬†une couleur d‚Äôarri√®re-plan `#15DEA5`.¬†La pseudoclasse `:hover`¬†permet d'assombrir le bouton de 5% en
utilisant la fonction Sass `darken()`¬†:

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    &:hover {
        background-color: darken($clr-btn, 5);
    }
}
```

Nous voulons animer la `background-color`¬†de notre bouton. Pour cela, ajoutons une transition √† `.btn`, d‚Äôune dur√©e de 250 millisecondes :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    transition: background-color 250ms;
    &:hover {
        background-color: darken($clr-btn, 5);
    }
}
```

Notre bouton prend maintenant une couleur plus sombre quand la souris passe dessus :

![Animation CSS d'un bouton qui change de couleur](https://user.oc-static.com/upload/2021/02/18/16136589961294_Gif094.gif)

Parfait ! Mission accomplie, on peut passer √† autre chose. Sauf que‚Ä¶

![Une photo montrant l'analyse du bouton anim√©](https://user.oc-static.com/upload/2019/08/06/15650923549747_image42.png)

Quelle horreur !!! Du paint !!! üò±

L‚Äôanimation de la propri√©t√© `background-color`¬†d√©clenche un nouveau calcul de paint √† chaque image de la transition. Dans ce cas, il n'y a qu'une
seule propri√©t√© √† animer sur notre page. Les performances restent donc acceptables. Mais si notre animation √©tait plus complexe, nous aurions
sans aucun doute perdu nos 60 FPS. `background-color`¬†n‚Äôest donc pas la meilleure option pour animer des changements de couleur. La propri√©t√© √†
utiliser, c‚Äôest `opacity`.

La propri√©t√© `opacity`¬†permet de modifier la transparence d‚Äôun √©l√©ment et de ses enfants sur une √©chelle de 0 √† 1, la valeur 0 repr√©sentant la
transparence totale, et la valeur 1 une opacit√© compl√®te.

:::note ?
Mais ce que je veux, c'est changer la couleur, pas le rendre transparent. Et l√† on utilise la propri√©t√© `opacity`¬†? Comment faire, alors ?
:::

Je vous ai parl√© plus t√¥t de structurer notre code HTML pour servir la fonctionnalit√© d‚Äôun √©l√©ment, plut√¥t que de se concentrer sur le layout.
Vous vous rappelez ? Que dites-vous de structurer notre bouton de mani√®re √† cr√©er deux arri√®re-plans empil√©s l‚Äôun sur l‚Äôautre ?

La couche du fond serait de la couleur normale, inactive, et la couche du dessus serait de la couleur plus sombre pour `:hover`. On pourrait
ensuite faire appara√Ætre et dispara√Ætre la couche du haut en utilisant la propri√©t√© `opacity`, en cr√©ant une animation entre les deux couleurs.

Commen√ßons par ajouter une `<div>`¬†apr√®s le texte du bouton de la `background-color`¬†plus sombre, avec `opacity`¬†√† 0, et `opacity`¬†sur 1 √† l‚Äô√©tat
:hover. Le code HTML ressemblerait √† √ßa :

```html
<button class="btn">
    Survole moi!
    <div class="btn__bg"></div>
</button>
```

et le CSS √† √ßa :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        & .btn__bg {
            opacity: 1;
        }
    }
    &__bg {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

La `<div />`¬†de la classe `.btn__bg`¬†est en position absolute. Sa `background-color`¬†est r√©gl√©e sur une version plus sombre de `$clr-btn`.¬†Nous
avons aussi ajout√© un z-index de¬†-1, et un z-index de 1 √† `.btn`¬†pour cr√©er notre empilement.

Voyons voir si √ßa fonctionne !

![Animation CSS d'un bouton qui change de couleur](https://user.oc-static.com/upload/2021/02/18/16136590106631_Gif095.gif)

L‚Äôeffet est le m√™me qu‚Äôen animant la couleur d‚Äôarri√®re-plan, tout en √©tant bien plus rapide √† calculer ! Eh oui, aucun travail de paint !

![R√©sultat de l'animation sans analyse de paint](https://user.oc-static.com/upload/2019/08/06/15650930342404_image29.png)

Tr√®s bien, cette fois-ci, la mission est accomplie, sans aucun calcul de paint.

Alors, vous avez r√©ussi ? On passe √† autre chose ?

On pourrait. Notre bouton change effectivement de couleur gr√¢ce √† la propri√©t√© opacity qui assure une performance optimale de notre navigateur.
C‚Äô√©tait notre objectif. Mais on peut toujours faire mieux !

Pour l‚Äôinstant, chaque bouton que nous ajoutons √† notre site n√©cessite d‚Äôajouter une `<div>`¬†suppl√©mentaire pour l‚Äôarri√®re-plan, ayant la classe
`.btn__bg`. Ce qui veut dire beaucoup de travail pour chaque bouton, et autant de risques de commettre une erreur.

### Exploitez la puissance du CSS

Cr√©er une nouvelle div √† chaque fois que vous faites une animation de couleur sur un √©l√©ment‚Ä¶ meh, ce n'est pas fou. Plut√¥t que de perdre votre
temps √† int√©grer la `div`¬†d‚Äôarri√®re-plan √† chaque bouton, nous pouvons exploiter la puissance du CSS pour qu‚Äôil cr√©e les √©l√©ments d‚Äôarri√®re-plan
√† notre place, comme par magie, gr√¢ce aux pseudo√©l√©ments ! Plus sp√©cifiquement le pseudo√©l√©ment¬†`::after`.

:::note ?
Mais bien s√ªr ! Enfin... c‚Äôest quoi, un pseudo√©l√©ment ?
:::

Commen√ßons par √©tudier son nom : le pr√©fixe "pseudo" d√©signe un √©l√©ment qui ressemble √† une chose mais en est en fait une autre (√ßa vous dit
quelque chose ?). Un pseudo√©l√©ment ressemble donc √† un √©l√©ment, comme une `<div>`¬†√©crite √† la main dans le code HTML, mais c‚Äôest en fait un
√©l√©ment g√©n√©r√© par le CSS et interpr√©t√© dans la page web.¬† Et on peut le styliser de la m√™me mani√®re.

Il existe plusieurs types de pseudo√©l√©ments, mais pour l‚Äôinstant nous n‚Äôallons parler que de `::after`, et de son fr√®re `::before`.

:::info
Vous pouvez consulter un r√©capitulatif complet des pseudo√©l√©ments disponibles en CSS3, et leur utilisation,¬†**[dans la documentation sur MDN](https://developer.mozilla.org/fr/docs/Web/CSS/Pseudo-elements)**.
:::

L‚Äôajout des √©l√©ments `::before`¬†ou `::after`¬†cr√©e un √©l√©ment enfant √† chaque fois que son s√©lecteur a √©t√© assign√©. L‚Äô√©l√©ment cr√©√© par `::before`
sera le premier enfant de l‚Äô√©l√©ment, et celui cr√©√© par `::after`¬†sera le dernier. Pour notre bouton, l‚Äô√©l√©ment de background vient apr√®s le texte,
donc le pseudo√©l√©ment `::after`¬†serait parfait pour remplacer notre `<div>`¬†d‚Äôarri√®re-plan.

La cr√©ation d‚Äôun pseudo√©l√©ment est identique √† celle d‚Äôune pseudoclasse : on ajoute le pseudo√©l√©ment √† un s√©lecteur, mais au lieu d‚Äôutiliser
comme pr√©fixe les deux points ( : ), un pseudo√©l√©ment en utilise deux ( :: ) :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        & .btn__bg {
            opacity: 1;
        }
    }
    &::after {
        // attribuez des valeurs de style au pseudo s√©lecteur ::after ici
    }
    &__bg {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

En CSS2, les pseudo√©l√©ments √©taient cr√©√©s avec un signe deux-points unique, comme les pseudos√©lecteurs, ce qui n‚Äô√©tait pas tr√®s clair. Pour aider
√† les distinguer, CSS3 a modifi√© la syntaxe des pseudo√©l√©ments avec le pr√©fixe double deux-points. Si vous tombez sur du CSS contenant¬†`:before`
ou¬†`:after`, c‚Äôest g√©n√©ralement le signe qu‚Äôil s‚Äôagit d‚Äôune vieille base de code.

Nous pouvons alors lui assigner du style. Nous voulons que¬†`::after`¬†ait la m√™me apparence que `.btn__bg`. Alors copions le style de `.btn__bg`
dans le pseudo√©l√©ment `::after`, avant de supprimer le s√©lecteur `.btn__bg`, dont nous n‚Äôaurons plus besoin :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        & .btn__bg {
            opacity: 1;
        }
    }
    &::after {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

Notre pseudo√©l√©ment `::after`¬†a maintenant le style qu'on voulait, mais passer la souris sur le bouton n‚Äôa pas encore d‚Äôeffet parce que la
pseudoclasse `:hover`¬†du bouton s√©lectionne toujours avec `.btn__bg` pour changer son¬†`opacity`¬†√†¬†1. Nous allons donc le mettre √† jour pour
qu‚Äôil utilise plut√¥t le pseudo√©l√©ment `::after`¬†:

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        &::after {
            opacity: 1;
        }
    }
    &::after {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: \-1;
        transition: opacity 250ms;
    }
}
```

Notre bouton n‚Äôaura plus besoin de la `<div>`¬†d‚Äôarri√®re-plan, donc tant qu‚Äô√† faire, retirons-la aussi :

```html
<button class="btn">
    Survole moi!
</button>
```

Et maintenant, apr√®s avoir actualis√© la page, quand nous interagissons avec le bouton, il devrait bien r√©agir comme avant :

![Bouton qui ne change pas de couleur au hover](https://user.oc-static.com/upload/2021/02/18/16136590272364_Gif096.gif)

Argh ! Z√©ro changement de couleur ! Ouvrons DevTools pour inspecter notre bouton :

![Le code inspect√©](https://user.oc-static.com/upload/2019/08/06/15650942922045_image26.png)

Nous devrions voir un √©l√©ment `::after` l√† o√π se trouvait notre `<div>`¬†d‚Äôarri√®re-plan‚Ä¶ mais il n‚Äôy a rien. üò§

### Ma√Ætrisez la particularit√© des pseudo√©l√©ments

Bon, c'est peut-√™tre de ma faute‚Ä¶ Vous vous rappelez quand j‚Äôai dit :

> Comme un pseudo√©l√©ment reste un √©l√©ment, on peut le styliser de la m√™me mani√®re.

Je vous ai √† moiti√© menti, car ce n‚Äô√©tait pas compl√®tement vrai‚Ä¶ üôà

Pour ma d√©fense, c‚Äô√©tait vrai √† 99,9 %‚Ä¶¬†mais les pseudo√©l√©ments n√©cessitent une propri√©t√© dont les √©l√©ments normaux n‚Äôont pas besoin. Pour un
√©l√©ment normal, on code son contenu en √©crivant la page. Mais comme `::after`¬†injecte un √©l√©ment dans la page apr√®s coup, le CSS doit dire au
navigateur ce que cet √©l√©ment contient. C‚Äôest l√† que la propri√©t√©¬†**`content`** entre en jeu. Elle est **indispensable au fonctionnement des
pseudo√©l√©ments.** (Prenez gaaaaarde √† la propri√©t√© content, elle en a rendu plus d‚Äôun compl√®tement fou, ne tombez pas dans son pi√®√®√®ge üëø).

La propri√©t√© `content`¬†nous permet de remplir un pseudo√©l√©ment de texte ou d‚Äôimages, mais dans le cas de notre bouton, nous ne voulons pas y
ajouter de contenu. Nous voulons plut√¥t que `::after`¬†agisse comme un fond de couleur. Pourtant, il est indispensable d‚Äôassigner une valeur au
pseudo√©l√©ment. Essayons donc de lui assigner une cha√Æne de caract√®res vides en utilisant des guillemets vides :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        &::after {
            opacity: 1;
        }
    }
    &::after {
        content: "";
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

Inspectons maintenant le code de notre bouton pour voir comment il se comporte. C‚Äôest mieux ! Si on jette un ≈ìil √† DevTools, on peut voir que
l‚Äô√©l√©ment `::after`¬†se trouve bien l√† o√π on avait une `<div>` :

![Le code inspect√©](https://user.oc-static.com/upload/2019/08/06/15650946116753_image28.png)

Alors, vous avez r√©ussi ?

Si jamais vous avez envie de vous arracher les cheveux parce que vos pseudo√©l√©ments n‚Äôapparaissent pas sur votre page, v√©rifiez en premier que
vous leur avez attribu√© une propri√©t√© `content`. Personnellement, √ßa m‚Äôarrive encore de devenir √† moiti√© folle avant de me rendre compte que
j‚Äôai oubli√© d‚Äôajouter la propri√©t√© content √† mes pseudo√©l√©ments.

### D√©couvrez les d√©grad√©s

L‚Äôanimation par la propri√©t√© `opacity`¬†n‚Äôest pas limit√©e aux changements de couleur. On peut aussi animer des d√©grad√©s au lieu de couleurs unies :
**![Animation de l'opacity gradient](https://user.oc-static.com/upload/2021/02/09/16128925803024_Gif097.gif)**.

Vous pouvez d'ailleurs retrouver le code source de ce bouton dans¬†[ce CodePen](https://codepen.io/atoulmet/pen/OJLjGvV).

_Essayez de modifier le d√©grad√© du bouton üôÇ_

Pour cela, il faut cr√©er un d√©grad√© pour la `background-color` du pseudo√©l√©ment `::after`, et non une couleur unie.

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        &::after {
            opacity: 1;
        }
    }
    &::after {
        content: "";
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background: radial-gradient(circle, lighten($clr-btn, 5) 0%, darken($clr-btn, 10) 100%);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

On peut aussi cr√©er des couches de couleurs sur des images :

![une image avec gradient hover opacity](https://user.oc-static.com/upload/2021/02/09/16128926002097_Gif098.gif)

```scss
$border-rad: 2rem;
$clr-primary: #15DEA5;
@mixin peudo-pos {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
.btn {
    border-radius: $border-rad;
    background-color: $clr-primary;
    position: relative;
    z-index: 1;
    &:hover {
        &::after {
            opacity: 1;
        }
        & + .img {
            &::before {
                opacity: 0;
            }
        }
    }
    &::after {
        @include pseudo-elem;
        background: radial-gradient(circle, lighten($clr-primary, 5) 0%, darken($clr-primary, 10) 100%);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
.img {
    z-index: -1;
    &::before {
        @include pseudo-elem;
        border-radius: $border-rad;
        background: $clr-primary;
        z-index: 1;
    }
}
```

Pas mal hein ? Vous avez essay√© ?

La morale de cette histoire, c‚Äôest que la propri√©t√© `opacity`¬†permet de faire des transitions de couleur sans que le navigateur fasse des calculs
de type ‚Äúpaint‚Äù. La performance reste donc optimale, et nous permet donc de garder notre objectif de 60 FPS. Pour cela, les pseudo√©l√©ments nous
√©vitent d‚Äô√©crire un code HTML r√©p√©titif, dans lequel on aurait d√ª ins√©rer de v√©ritables √©l√©ments suppl√©mentaires.¬†Plus pratique et plus propre,
que demander de plus ?

### En r√©sum√©

- animer la couleur d‚Äôune propri√©t√© d√©clenche des **calculs** de paint ;
- la propri√©t√© `opacity`¬†nous permet de faire des transitions entre des couleurs en √©vitant ces calculs ;
- la propri√©t√© `opacity`¬†re√ßoit une valeur entre 0 et 1, 0 √©tant compl√®tement transparent et 1 compl√®tement opaque ;
- pour √©viter d‚Äôavoir √† ajouter des `<div>`¬†suppl√©mentaires, que l'on aurait d√ª ajouter √† chaque fois dans le HTML, on peut utiliser le
pseudo√©l√©ment `::before`¬†ou `::after`¬†;
- pour cr√©er un pseudo√©l√©ment, ajoutez le nom du pseudo√©l√©ment √† un s√©lecteur, en utilisant le pr√©fixe double deux-points : `.selector::after{...}`
- les pseudo-√©l√©ments `::before`¬†et `::after`¬†cr√©ent un √©l√©ment qui est respectivement le premier ou le dernier enfant de l‚Äô√©l√©ment s√©lectionn√© ;¬†
- il est possible de cr√©er des d√©grad√©s de couleur. Il suffit d'attribuer un d√©grad√© au background-color de l'√©l√©ment d'arri√®re-plan. On fera
ensuite dispara√Ætre l'√©l√©ment superpos√© avec opacity: 0.

_Nous voil√† d√©j√† √† la fin de la deuxi√®me partie ! F√©licitations √† vous üéâ ! Vous allez maintenant pouvoir vous exercer sur le deuxi√®me quiz¬†du
cours. Une fois¬†le quiz termin√©, nous passerons √† la partie 3, o√π nous verrons enfin les keyframes. J'ai h√¢te !_

-----

## Quiz : R√©alisez des translations, des rotations et modifier l'opacit√© de vos animations

[R√©alisez des translations, des rotations et modifier l'opacit√© de vos animations - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/exercises/3601)

#### Comp√©tences √©valu√©es

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Ma√Ætriser les translations, les rotations et l‚Äôopacit√©

-----

#### Description

Bienvenue dans le deuxi√®me¬†quiz de ce cours.<br />
Cette fois-ci, c'est vous qui allez coder. Il est n√©cessaire de cloner le [repository GitHub](https://github.com/atoulmet/openclassrooms_css-animations)
correspondant √† ce cours pour r√©pondre aux six premi√®res questions. V√©rifiez le fichier README.md pour obtenir quelques instructions
suppl√©mentaires sur comment le faire tourner.

Dans les quatre questions suivantes, nous testerons votre compr√©hension g√©n√©rale des points abord√©s¬†dans la partie 2 de ce cours.

Alors, c'est parti ! üöÄ


#### Question 1 : Dans le repository, une ligne a √©t√© comment√©e pour animer la premi√®re carte. D√©commentez cette ligne de code. Quelle propri√©t√© a √©t√© anim√©e ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> <code>rotate()</code><br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> <code>width</code><br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> <code>transform</code><br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> <code>transition</code><br />
<br />

_Il aurait pu √™tre tentant de choisir la premi√®re r√©ponse. La flashcard d√©crit effectivement une rotation. Mais rotate n'est pas une propri√©t√© :
il s'agit d'une fonction de la propri√©t√© transform. La propri√©t√© width n'a quant √† elle pas du tout √©t√© anim√©e. Au contraire, je vous d√©conseille
d'utiliser cette propri√©t√© pour cr√©er vos animations, puisqu'elle n'est pas du tout performante. La propri√©t√© transition permet de d√©crire la
dur√©e, la courbe d'acc√©l√©ration, le d√©lai, etc. Mais ce n'est pas une propri√©t√© anim√©e._

-----

#### Question 2 : Lequel de ces snippets nous donne une¬†animation permettant de faire appara√Ætre la d√©finition du deuxi√®me principe de mani√®re fluide ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.principal-2 {
    .btn:active + .card > .card__front {
        transform: scale(0);
        transform: rotate(-190deg);
        transition: 0.5s ease-in-out;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.principal-2 {
    & .btn:active + .card > .card__front {
        transform: scale(0);
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.principal-2 {
    & .btn:active + .card > .card_front {
        transform: opacity(0);
        transition-duration: 0.5s;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
.principal-2 {
    .btn:active + .card > .card__front {
        opacity: 0;
        transform: rotate(60deg) scale(0);
        transition: 0.5s ease-in-out;
    }
}
```

*Dans le choix num√©ro 1, la deuxi√®me propri√©t√© transform, transform: rotate(-190deg),¬†vient annuler la premi√®re d√©claration de transform qui
pr√©cisait scale(0). Le dessus de la carte pivote bien mais ne dispara√Æt pas, ce qui ne nous permet pas de voir la d√©finition.*

*Le deuxi√®me snippet, quant √† lui ne pr√©voit pas de transition : la d√©finition appara√Æt bien, mais pas d'animation ici.*

*Dans le troisi√®me choix, il y a une toute petite erreur : au lieu de .card__front, on a ici .card_front, par ailleurs, opacity ne fait pas
partie de transform(). l'animation ne peut donc pas se lancer.*

*C'est bien la solution 4 qui permet de lancer notre animation.*

-----

#### Question 3 : Laquelle de ces animations correspond √† ce snippet de code ?

```scss
.principal-3 {
    .btn:active + .card > .card__front {
        transform: scale(2);
        opacity: 0;
        transition: all ease-in-out 0.5s;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

![pt02-quiz-q3-r1](https://user.oc-static.com/upload/2019/09/01/15673370875301_ezgif.com-optimize%20%2813%29.gif)

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

![pt02-quiz-q3-r2](https://user.oc-static.com/upload/2019/09/01/15673371075752_ezgif.com-optimize%20%2814%29.gif)

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

![pt02-quiz-q3-r3](https://user.oc-static.com/upload/2019/09/01/15673371255855_ezgif.com-video-to-gif%20%2816%29.gif)

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

![pt02-quiz-q3-r4](https://user.oc-static.com/upload/2019/09/01/15673371381181_ezgif.com-optimize%20%2815%29.gif)

*Il s'agit de l'animation num√©ro 2 !*

*En effet, l'animation num√©ro 1 ne grandit pas assez pour correspondre √† ce snippet : ici elle effectue une transformation de translate(1.2).*

*L'animation num√©ro 3, quant √† elle, ne peut pas correspondre : elle s'√©tend sur la droite alors que la propri√©t√© transform-origin n'a pas √©t√©
manipul√©e. Et enfin, l'animation 4 ne dispara√Æt pas totalement √† la fin, et sa duration est bien trop lente.*

-----

#### Question 4 : Je veux cr√©er une animation o√π la carte dispara√Æt tout en se d√©calant de 300 pixels sur la droite, et en r√©duisant son √©chelle. Dans mon s√©lecteur `.principal-4`, je pensais avoir ce qu'il me fallait, mais √ßa ne marche pas. Qu'est-ce qui pose probl√®me ici ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Ma transition est trop rapide : je n'ai pas le temps de voir l'effet.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Il n'est pas possible de pr√©ciser plusieurs fois <code>transform</code>¬†au sein d'un m√™me s√©lecteur, ou les effets pr√©c√©dents seront √©cras√©s par la derni√®re d√©claration.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Ce n'est pas possible de cr√©er une animation sur 3 propri√©t√©s diff√©rentes.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Il n'est pas possible d'animer les propri√©t√©s¬†<code>transform</code> et <code>opacity</code> dans une m√™me¬†animation.<br />
<br />

*Avec une dur√©e de 300ms, aucun souci de dur√©e de transition ici : c'est largement suffisant pour voir un effet. Par ailleurs, il est √©galement
possible de cr√©er une animation sur autant de propri√©t√©s que l'on souhaite, pas de limite √† ce niveau-l√†. De la m√™me mani√®re, il est tout √† fait
possible d'animer `opacity`¬†ET `transform`. C'est donc bien la d√©claration de `transform`¬†qui pose probl√®me. üôà*

-----

#### Question 5 : Je veux reproduire cette animation.

![pt02-quiz-q5](https://user.oc-static.com/upload/2019/09/01/15673376246868_ezgif.com-optimize%20%2816%29.gif)

**Quel snippet de code me permet d'y parvenir ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.btn:active + .card > .card__front {
    transform: rotate(180deg);
    opacity: 0;
    transition: transform ease-in-out 0.5s, opacity ease-in-out 0.2s 0.2s;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.card > .card__front {
    transform-origin: top right;
}
.btn:active + .card > .card__front {
    transform-origin: top right;
    transform: rotate(180deg);
    opacity: 0;
    transition: transform ease-in-out 0.5s, opacity ease-in-out 0.2s 0.2s;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
.card > .card__front {
    transform-origin: 20px 20px;
}
.btn:active + .card > .card__front {
    transform: rotate(180deg);
    opacity: 0;
    transition: all ease-in-out 1s;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.btn:active + .card > .card__front {
    transform-origin: top right;
    transform: rotate(180deg);
    opacity: 0;
    transition: all ease-in-out 0.2s 0.2s;
}
```

*Ici, la propri√©t√© `transform-origin`¬†est essentielle. Or, elle n'est pas pr√©sente dans le premier snippet. Ce n'est pas la bonne solution.*

*Le deuxi√®me choix, quant √† lui, part d'un `transform-origin`¬†du mauvais c√¥t√© : alors que sur mon animation le carr√© bascule vers la gauche, la
propri√©t√© est d√©finie √† right ici.*

*Le quatri√®me extrait de code pr√©cise bien `transform-origin: top right;`, mais il le fait directement dans la pseudoclasse `:active`, ce qui ne
donne pas l'effet souhait√©.*

*C'est bien le troisi√®me snippet qui permet d'obtenir cette animation.*

-----

#### Question 6 : Dans le repository, une animation a √©t√© cr√©√©e pour le 6e principe, Slow in and Slow out. Comme nous l'avons vu dans le chapitre "Analysez la performance de vos animations avec Chrome DevTools", ouvrez l'outil Performance des DevTools pour creuser un peu cette animation. Zoomez au maximum pour voir les √©tapes qui ont √©t√© d√©clench√©es pour le calcul de notre animation. Quelles sont ces √©tapes ?

*Attention, plusieurs r√©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Paint<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Layout<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Composition (Composite)<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> Flex<br />
<br />

*Cette animation modifie les propri√©t√©s de transform, opacity, mais √©galement background-color et width/height. Elle d√©clenche donc des op√©rations
de Layout, Paint et Composition. Mon animation n'est donc pas vraiment performante ici : si je veux au maximum limiter les calculs de mon
navigateur, je dois m'en tenir aux propri√©t√©s qui d√©clenchent des calculs de Composition. Pour cela, je dois privil√©gier transform et opacity.
Pour ce qui est de flex, rien √† voir : il s'agit d'une valeur de display qui permet de faire des mises en page CSS.*

-----

#### Question 7 : Quel est le FPS optimal √† respecter pour obtenir des animations CSS aussi fluides que possible ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> 60 FPS<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 16 FPS<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 100¬†FPS<br />
<br />

*Pour cr√©er des animations aussi fluides que possible, le FPS optimal est de 60 FPS. En effet, la plupart des √©crans modernes ont une vitesse de
rafra√Æchissement des images √† 60 hz, ou 60 fois par seconde. Si notre animation a un FPS de 100, l'utilisateur verra malgr√© tout une animation √†
60 FPS car il sera limit√© par les capacit√©s de son √©cran. √Ä l'inverse, 16 FPS est beaucoup trop faible et donne vraiment une impression saccad√©e.
Pourtant, si le nombre 16 vous semble familier, c'est aussi parce qu'il s'agit de la dur√©e maximale pour calculer une image d'une animation si
l'on veut respecter le FPS optimal de 60 FPS. N'h√©sitez pas √† jeter un ≈ìil au chapitre _Optimisez les performances de votre navigateur_ pour vos
animations CSS, si vous avez un doute üòâ*

-----

#### Question 8 : Quels snippets de code permettent d'obtenir une animation sur l'opacit√© et sur transform, avec une transition de 300 millisecondes, une courbe d'acc√©l√©ration ease et un d√©lai 200 millisecondes ?

*Attention, plusieurs r√©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
transition: all 0.3s 0.2s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
transition: all 0.3s ease 0.2s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
transition: all 0.2s ease 0.3s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
transition-duration: 0.3s;
transition-delay: 0.2s
transition-property: all;
transition-timing-function: ease;
```

*Souvenez-vous : la propri√©t√© transition est une propri√©t√© raccourcie pour les propri√©t√©s [transition-property](https://developer.mozilla.org/fr/docs/Web/CSS/transition-property),
[transition-duration](https://developer.mozilla.org/fr/docs/Web/CSS/transition-duration), [transition-timing-function](https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function)
et [transition-delay](https://developer.mozilla.org/fr/docs/Web/CSS/transition-delay), dans cet ordre pr√©cis.*

*Le choix 1 ne pr√©cise pas la valeur ease comme fonction de timing, mais comme il s'agit de la valeur par d√©faut, le premier snippet convient
bien. Le choix num√©ro 2 √©galement.*

*Le choix num√©ro 3 inverse dur√©e et d√©lai de transition, il ne respecte donc pas les crit√®res recherch√©s. Et le choix num√©ro 4 correspond √† la
version d√©taill√©e de nos propri√©t√©s. Vous avez le choix de pr√©ciser des valeurs pour vos propri√©t√©s CSS une par une comme dans le choix 4, ou
avec la propri√©t√© transition. Mais vous verrez le plus souvent la propri√©t√© raccourcie ; je vous conseille donc de l'utiliser pour vous y
habituer.*

-----

#### Question 9 : Qu'est-ce qu'il ne faut surtout pas oublier pour afficher un pseudo-√©l√©ment `:before`¬†ou `:after`¬†?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Pr√©ciser une width<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> display: block;<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Pr√©ciser un content<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> z-index: 1<br />
<br />

*Les pseudo√©l√©ments sont un peu particuliers. Contrairement √† un √©l√©ment¬†HTML traditionnel, il n'est pas n√©cessaire qu'il ait une width ou une
height pour qu'il s'affiche. En revanche, il est indispensable de pr√©ciser la propri√©t√© content, m√™me s'il s'agit d'une cha√Æne de caract√®res vide.
Souvenez-vous-en bien, car cette petite particularit√© risque de vous rendre fou en cas d'oubli üôÉ.*

-----

#### Question 10 : Le navigateur suit plusieurs √©tapes pour rendre une page web. Selon la propri√©t√© appliqu√©e, une animation d√©clenche diff√©rentes √©tapes de rendu par le navigateur. Quelle est la derni√®re √©tape qui est la moins gourmande en puissance de calcul, et doit donc √™tre privil√©gi√©e pour vos animations CSS ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Paint<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Layout<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Styles<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Composition<br />
<br />

*Dans l'ordre, les √©tapes que le navigateur suit sont les suivantes :*
1. _**Style** : le navigateur va cr√©er la structure¬†HTML qui s'affichera._
2. _**Layout** (mise en page) : maintenant que le navigateur conna√Æt les styles et les √©l√©ments √† afficher, il d√©termine la taille des √©l√©ments
et o√π les placer._
3. _**Paint** (peinture) : le navigateur transforme les √©l√©ments en pixels en utilisant les styles de l‚Äô√©tape 1, et les positions et dimensions
d√©duites de l‚Äô√©tape 2._
4. _**Composition** : le navigateur combine tous les √©l√©ments pour composer la page qui s‚Äôaffiche dans le navigateur._

*C'est la derni√®re √©tape qui est la moins gourmande en puissance de calcul, donc Composition, √† privil√©gier pour vos animations. Vous pouvez
retrouver √† quelle √©tape correspond la propri√©t√© que vous animez sur le site [**csstriggers.com**](http://csstriggers.com/) (en anglais).*
