---
sidebar_position: 3
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# MaÃ®trisez les translations, les rotations et lâ€™opacitÃ©

## Optimisez les performances de votre navigateur pour vos animations CSS

[Optimisez les performances de votre navigateur pour vos animations CSS - CrÃ©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340918-optimisez-les-performances-de-votre-navigateur-pour-vos-animations-css)

<Vimeo vimeoId="508777206" />

<br />

### Assurez-vous dâ€™avoir des animations fluides

Comme je vous le disais dans la vidÃ©o d'introduction, les animations que nous voyons sur nos Ã©crans ne sont pas de vÃ©ritables mouvements. Il
s'agit en fait de **successions d'images** allant suffisamment vite pour qu'elles soient interprÃ©tÃ©es par notre cerveau comme des objets en
mouvement.

Je vous parlais Ã©galement de **Frames Per Second** (FPS). Voyons ce que cela donne sur nos Ã©crans ğŸ¤“

:::info
Les images par seconde, ou _FPS_, reprÃ©sentent le nombre dâ€™images individuelles affichÃ©es en une seconde. Plus lesÂ FPS sont Ã©levÃ©es, plus le
mouvement paraÃ®t fluide. Comme nous allons bientÃ´t le voir, en animation web, on vise 60 FPS, mais en raison des limitations techniques de GIF,
nous utilisons des exemples Ã  50 FPS.
:::

Dans lâ€™animation suivante, une balle qui va et vient au rythme de 50 images par secondes (ou 50 FPS) :

![Une animation CSS Ã  50 fps](https://user.oc-static.com/upload/2021/02/09/16128907707836_Gif053.gif)

Le mouvement paraÃ®t bien fluide. Maintenant, voici la mÃªme animation, mais avec 10 FPS au lieu de 50 :

![Une animation CSS Ã  10 fps](https://user.oc-static.com/upload/2021/02/09/16128907798918_Gif054.gif)

Le mouvement de la balle paraÃ®t vraiment moins fluide Ã  10 FPS quâ€™Ã  50. On peut mÃªme distinguer les **images** qui composent lâ€™animation. Au lieu
de paraÃ®tre naturelle, lâ€™animation ressemble plutÃ´t Ã  une **tentative dâ€™imitation de mouvement**. Lâ€™image **saccadÃ©e** ne trompe pas notre
cerveau. Au contraire, l'expÃ©rience est plutÃ´t dÃ©sagrÃ©able, ce qui nous distrait de lâ€™animation.

:::note ?
Mais alors, quel est le nombre dâ€™images par seconde des transitions que nous avons crÃ©Ã©es jusquâ€™ici ? ğŸ§
:::

En animation traditionnelle, le nombre dâ€™images par seconde est fixe et toutes les images sont crÃ©Ã©es avant que lâ€™animation ne soit lancÃ©e. Mais
les animations CSS sont affichÃ©es en **temps rÃ©el** par le navigateur, qui met Ã  jour lâ€™animation avec les nouvelles images dÃ¨s quâ€™il les a
calculÃ©es.

Cela signifie que le nombre dâ€™images par seconde de nos animations est **variable**. Par exemple, disons que le navigateur met 0,04 seconde Ã 
calculer une image dâ€™une animation, puis 0,03 seconde Ã  calculer la suivante.

Mais cela ne nous donne pas le FPS pour autant.

:::note ?
Comment le calculer ?
:::

Pour dÃ©terminer le nombre dâ€™images par seconde, on divise une seconde par la durÃ©e de calcul, en secondes. Donc 1/0,04 = 25 FPS.

Ce qui veut dire que le nombre dâ€™images par seconde de lâ€™animation est de 25 FPS pour la premiÃ¨re image, et 30 pour la deuxiÃ¨me.

La question nâ€™est pas tant comment calculer le nombre dâ€™images par seconde de notre animation, mais comment s'assurer de respecter le nombre
idÃ©al, Ã  savoir **60 FPS**.

La plupart des Ã©crans ont un taux de rafraÃ®chissement de 60 hz, ou 60 images par seconde. Si on crÃ©e une animation avec 75 FPS, le spectateur
nâ€™en verrait que 60 parce que lâ€™Ã©cran ne rafraÃ®chit par lâ€™image assez vite pour afficher les 75. 60 FPS est donc le taux dâ€™images par seconde le
plus fluide que le spectateur pourra voir sur ses Ã©crans.

De fait, nous devons nous assurer que le navigateur mette moins d'un soixantiÃ¨me de seconde, ou 0,016 seconde (16 millisecondes) pour calculer
les images de notre animation.

:::noe ?
Alors comment faire pour garder ce temps de calcul Ã  16 millisecondes maximum ?
:::

Pour cela, il suffit de suivre certaines bonnes pratiques dans la maniÃ¨re d'Ã©crire vos animations CSS.

### Comprenez comment le navigateur passe des codes HTML et CSS Ã  une page web

Pour passer des codes CSS et HTMLâ€¦ Ã  une page web, le navigateur passe par plusieurs Ã©tapes pour afficher une page. Voici les Ã©tapes qui nous
intÃ©ressent pour le rendu de nos animations :
1. **Style** : le navigateur **reÃ§oit** le code HTML. Il va l'**interprÃ©ter** pour comprendre la structure du DOM (Document Object Model). Ainsi,
pour chaque balise HTML, il crÃ©e un Ã©lÃ©ment du DOM, un peu comme un arbre de nÅ“uds. Il parcourt ensuite le CSS, et dÃ©termine quelles rÃ¨gles
sâ€™appliquent Ã  quels Ã©lÃ©ments. Ã€ partir de lÃ , il va crÃ©er la structure qui s'affichera.

:::info
Le DOM, qui signifie **_Document Object Model_** ("modÃ¨le d'objet de document", en franÃ§ais), est une reprÃ©sentation du HTML d'une page web. Il
faut voir le DOM comme un **arbre** oÃ¹ chaque Ã©lÃ©ment peut avoir zÃ©ro ou plusieurs enfants, qui peuvent avoir eux-mÃªmes zÃ©ro ou plusieurs enfants,
qui peuvent avoir zÃ©ro ou plusieurs enfants... Si vous voulez en savoir plus, il y a un super cours dessusÂ : [Ã‰crivez du JavaScript pour le web](https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5543068-comprenez-ce-quest-le-dom)Â ğŸš€.
:::

2. **Layout** (mise en page) : maintenant que le navigateur connaÃ®t les styles et les Ã©lÃ©ments Ã  afficher, il **dÃ©termine** la **taille** des
Ã©lÃ©ments et oÃ¹ les placer.
3. **Paint** (peinture) : le navigateur transforme les Ã©lÃ©ments en **pixels** en utilisant les styles de lâ€™Ã©tape 1, et les positions et
dimensions dÃ©duites de lâ€™Ã©tape 2.
4. **Composition** : le navigateur combine tous les Ã©lÃ©ments pour **composer** la page qui sâ€™affiche dans le navigateur.

Ces diffÃ©rentes Ã©tapes sont importantes pour comprendre quelles propriÃ©tÃ©s modifier pour nos animations. En effet, le navigateur applique
diffÃ©rentes propriÃ©tÃ©s CSS Ã  diffÃ©rentes Ã©tapes du processus. Typiquement, width et height sont appliquÃ©es pendant l'Ã©tape du layout. En revanche,
color et box-shadow sont appliquÃ©es Ã  l'Ã©tape paint.

:::info
Le site **[csstriggers.com](http://csstriggers.com/)** (en anglais, mais vous retrouverez les mots clÃ©s que nous avons vus ici) prÃ©sente les
Ã©tapes de chaque propriÃ©tÃ© associÃ©e aux layout, paint et composition. Pas mal si vous avez un doute sur une propriÃ©tÃ© pour la performance de
votre animation !
:::

Chaque Ã©tape nÃ©cessite un **temps de calcul** au navigateur. Il est donc plus judicieux de passer par le moins d'Ã©tapes possible si on veut
respecter le seuil des 16 millisecondes pour chaque Ã©tape de notre animation.

:::note ?
ConcrÃ¨tement, comment Ã§a se passe ?
:::

Reprenons l'exemple de notre bouton dans la partie prÃ©cÃ©dente.

Mon bouton fait 30px par 100px. Au survol de la souris, je veux qu'il s'Ã©largisse de 10px. Si je change la propriÃ©tÃ© Â `width`, cela veut dire que
mon navigateur recalcule le layout, le paint et la composition. Pas trÃ¨s optimal, n'est-ce pas ? ğŸ™ˆ

Et Ã  chaque mouvement de souris, il faudra tout **recalculer**. Or, plus le navigateur doit faire de calculs, plus il mettra de temps, ce qui
baisse le nombre dâ€™images par seconde, et **dÃ©grade** considÃ©rablement l'expÃ©rience utilisateur.

Quand le nombre dâ€™images par seconde devient tellement faible quâ€™on commence Ã  distinguer les images une par une et que le mouvement semble
"**rouiller**", on appelle Ã§a â€œ**jank**â€. C'est le pire ennemi dâ€™un animateur. La clÃ© pour Ã©viter le jank est de se limiter Ã  animer des
propriÃ©tÃ©s qui ne dÃ©clenchent pas de calculs de layout ou de paint.

En dâ€™autres termes, il ne faut animer que des propriÃ©tÃ©s qui font partie de lâ€™Ã©tape **composition**. Les plus adaptÃ©es sont donc `transform`Â et
`opacity`.

Revenons Ã  notre bouton qui faisait grossir une boule en utilisant la fonction `scale()`Â de la propriÃ©tÃ© `transform`Â :

![Animation d'un cercle qui grossit et rÃ©trÃ©cit](https://user.oc-static.com/upload/2021/02/09/16128907937053_Gif055.gif)

Les changements de dimension de la boule nâ€™affectent pas la position du bouton. En effet, la propriÃ©tÃ© transform effectue ses opÃ©rations Ã 
lâ€™Ã©tape composition, ce qui ne cause aucun changement de layout (mise en page) ou de paint, donc moins de calcul pour le navigateur, et donc un
**meilleur FPS**.

GÃ©nial, nâ€™est-ce pas ?

Alors, avez-vous rÃ©ussi Ã  faire grossir votre bouton ?

### En rÃ©sumÃ©

- Ã  l'Ã©cran, il n'y a pas de vÃ©ritable mouvement, mais une **succession d'images** s'enchaÃ®nant suffisamment rapidement pour Ãªtre interprÃ©tÃ©es
par notre cerveau comme du mouvement ;
- cette succession d'images s'appelle les FPS (Frame Per Second, ce qui signifie _images par seconde_) ;
- plus le FPS est **Ã©levÃ©**, plus l'animation est **fluide** ;
- le taux dâ€™images par seconde idÃ©al est **60 FPS** ;
- les quatre Ã©tapes de la crÃ©ation dâ€™une page web sont :
    - **Style** : le navigateur comprend la structure HTML du code qu'il reÃ§oit et prÃ©pare le style qui sera appliquÃ©,
    - **Layout** (mise en page) : le navigateur dÃ©termine la mise en page et la taille des Ã©lÃ©ments en fonction du style qu'il a reÃ§u,
    - **Paint** : il transforme les Ã©lÃ©ments en pixels,
    - Composition : il combine tous les Ã©lÃ©ments pour composer la page qui sâ€™affiche ;
- pour assurer la **fluiditÃ©** des animations, il faut se contenter dâ€™animer des propriÃ©tÃ©s de lâ€™Ã©tape composition. Les plus utiles sont
`transform`Â et `opacity`.

_Maintenant que vous comprenez tous les enjeux liÃ©s au choix des propriÃ©tÃ©s de ces animations, nous allons pouvoir explorer la propriÃ©tÃ© transform.
Nous verrons les nombreuses fonctions quâ€™elle met Ã  notre disposition pour crÃ©er des animations fluides._

-----

## CrÃ©ez des animations fluides avec la propriÃ©tÃ© CSS transform

[CrÃ©ez des animations fluides avec la propriÃ©tÃ© CSS transform - CrÃ©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340919-creez-des-animations-fluides-avec-la-propriete-css-transform)

<Vimeo vimeoId="508777226" />

<br />

Pour nous assurer que nos animations soient aussi fluides que possibles, nos deux propriÃ©tÃ©s alliÃ©es sont `transform`Â et `opacity`. Seulement deux
propriÃ©tÃ©s, Ã§a vous paraÃ®t limitÃ© ?

DÃ©trompez-vous ! Car elles nous permettent en rÃ©alitÃ© de rÃ©aliser une multitude d'effets d'animation.

### DÃ©couvrez le potentiel deÂ `transform`

La propriÃ©tÃ© `transform`Â s'avÃ¨re un vÃ©ritable couteau suisse en termes d'animation. En effet, elle dispose de plus de **20 fonctions diffÃ©rentes**
pour **dÃ©placer**, **faire pivoter**, **dÃ©former** et **changer la taille** des Ã©lÃ©ments.

Dans les chapitres prÃ©cÃ©dents, nous avons utilisÃ© `transform`Â pour modifier la taille dâ€™un bouton et dâ€™un cercle. Nous connaissons donc sa
syntaxe et sa fonction `scale()`.

```scss
.btn {
    :hover + .ball {
        transform: scale(1);
    }
}
```

Mais pour exploiter toute la puissance de la propriÃ©tÃ© transform, nous allons commencer Ã  utiliser plusieurs de ses fonctions. Dans ce chapitre,
nous allons couvrir les fonctions `transform`Â les plus utiles, et voir comment les lier entre elles pour crÃ©er des animations plus complexes, tout
en respectant l'objectif de 60 FPS.

### Modifiez la taille d'un Ã©lÃ©ment avec `scale`

Pour utiliser la propriÃ©tÃ© `transform`Â sur un Ã©lÃ©ment, nous devons lui fournir la fonction (ou les fonctions, comme on va le voir) qui
**dÃ©clenche** les transformations souhaitÃ©es. Par exemple, pour faire passer un objet Ã  200 % de sa taille de dÃ©part, on utilise la fonction
`scale()`Â paramÃ©trÃ©e Ã  2 :

```scss
.btn {
    &:hover + .box {
        transform: scale(2);
    }
}
.box {
    transition: transform 330ms ease-in-out;
}
```

PlutÃ´t que dâ€™exprimer `scale()`Â en pourcentages, on indique des nombres, 0 pour 0 %, et 1 Ã©gal Ã  100 %. `scale(2)`Â fait donc grossir notre
Ã©lÃ©ment Ã  200% de sa taille :

![Une animation d'un carrÃ© qui grossit et rÃ©trÃ©cit sans fluiditÃ©](https://user.oc-static.com/upload/2021/02/09/16128909432431_Gif056.gif)

Donner une seule valeur Ã  la fonction `scale()`Â modifie la **taille** de lâ€™Ã©lÃ©ment de maniÃ¨re **uniforme**, aussi bien en hauteur qu'en largeur.
Mais on peut Ã©galement lui prÃ©ciser deux valeurs, une pour modifier la largeur (X), et une autre pour modifier la hauteur (Y).

Par exemple, ici, nous souhaitons garder un **volume constant**. Il faut donc affiner la largeur de la boÃ®te en mÃªme temps que nous allongeons sa
longueur. Passons lâ€™Ã©chelle de X Ã  300%, et Y Ã  50% :

```scss
.btn {
    &:hover + .box {
        transform: scale(3, 0.5);
    }
}
.box {
    transition: transform 330ms ease-in-out;
}
```

Maintenant, notre boÃ®te sâ€™Ã©tire horizontalement :

![Une animation d'un carrÃ© qui devient un rectangle allongÃ©](https://user.oc-static.com/upload/2021/02/09/16128909603487_Gif057.gif)

:::note ?
Et si je veux modifierÂ ma boÃ®te dans une seule direction ? ğŸ§
:::

On pourrait faire quelque chose comme Ã§a :

```scss
.btn {
    &:hover + .box {
        transform: scale(2, 1);
    }
}
.box {
    transition: transform 330ms ease-in-out;
}
```

Ã‡a fonctionne : lâ€™axe X est Ã  200% et lâ€™axe Y Ã  100%â€¦ Mais il existe une mÃ©thode plus propre et plus explicite.

Quand on veut modifier lâ€™Ã©chelle dans une seule direction, on peut utiliser les fonctions `scaleX()`Â et `scaleY()`.Â `scaleX()`Â permet de modifier
un objet horizontalement, et `scaleY()`Â verticalement.

Alors, pour passer lâ€™Ã©chelle de notre bouton Ã  200% horizontalement, nous pouvons utiliser `scaleX(2)`Â :

```scss
.btn {
    &:hover + .box {
        transform: scaleX(2);
    }
}
.box {
    transition: transform 330ms ease-in-out;
}
```

![Une animation d'un carrÃ© qui devient un rectangle allongÃ©](https://user.oc-static.com/upload/2021/02/09/16128909734538_Gif058.gif)

FÃ©licitations ! Vous maÃ®trisez maintenant une des fonctions les plus utiles de transform ğŸ‰ !

DÃ©couvrons maintenant la suite !

### Modifiez la position d'un Ã©lÃ©ment

La fonction `translate`Â est le moyen idÃ©al pour modifier la **position d'un Ã©lÃ©ment** dans une animation web. `translate()`Â prend deux valeurs en
paramÃ¨tres. La premiÃ¨re indique la distance Ã  laquelle on veut se dÃ©placer sur lâ€™axe X, et la seconde la distance sur lâ€™axe Y.Â Elle accepte
[diffÃ©rentes unitÃ©s](https://developer.mozilla.org/fr/docs/Apprendre/CSS/Introduction_%C3%A0_CSS/Values_and_units), commeÂ les px, les vh ou les em.
Nous pouvons donc dÃ©placer notre boÃ®te de 150 px vers la droite et 7 vh vers le haut, comme Ã§a :

```scss
.btn {
    &:hover + .box {
        transform: translate(150px, \-7vh);
    }
}
```

```scss
.box {
    transition: transform 330ms ease-in-out;
}
```

Ce qui nous donne :

![Une animation d'un carrÃ© qui se dÃ©place en diagonale](https://user.oc-static.com/upload/2021/02/09/16128909912686_Gif059.gif)

Vous pouvez Ã©galement utiliser des **pourcentages**. Pour certaines propriÃ©tÃ©s CSS, les pourcentages sont calculÃ©s par rapport Ã  leur Ã©lÃ©ment
parent. Par exemple, `width: 50%`Â signifie la moitiÃ© de la largeur du parent :

![Une illustration de width: 50%](https://user.oc-static.com/upload/2019/08/25/15667221900415_Capture%20d%E2%80%99e%CC%81cran%202019-08-25%20a%CC%80%2010.36.19.png)

Mais quand on utilise des pourcentages avec `translate()`, ces pourcentages sont liÃ©s Ã  lâ€™Ã©lÃ©ment lui-mÃªme. Disons que notre Ã©lÃ©ment fait 100px de
large :

```scss
.btn {
    &:hover + .box {
        transform: translate(100px, 0);
    }
}
.box {
    width: 100px;
    height: 100px;
    transition: transform 330ms ease-in-out;
}
```

Si on se dÃ©place de 100 % sur lâ€™axe X, on se dÃ©place de 100 px vers la droite :

![Une animation d'un carrÃ© qui se dÃ©place Ã  l'horizontale](https://user.oc-static.com/upload/2021/02/09/16128910089039_Gif060.gif)

Comme nous l'avons vu avec `scale()`, il est possible de **dÃ©placer** des Ã©lÃ©ments sur lâ€™axe X et Y sÃ©parÃ©ment, grÃ¢ce aux fonctions `translateX()`
et `translateY()`.

Ajoutons un peu de texte que nous allons faire apparaÃ®tre dans la boÃ®te :

```html
<div class="container">
    <button class="btn">Transform!</button>
    <div class="box">
        Boop!
    </div>
</div>
```

La structure convient, mais pour animer le texte sÃ©parÃ©ment de son Ã©lÃ©ment parent, nous devons lâ€™envelopper dans un **conteneur**. PlaÃ§ons-le
donc au sein dâ€™un `<span>` :

```html
<div class="container">
    <button class="btn">Transform!</button>
    <div class="box">
        <span>Boop!</span>
    </div>
</div>
```

`<span>`Â donne Ã  la propriÃ©tÃ© `transform`Â un Ã©lÃ©ment auquel sâ€™accrocher pour le manipuler. RÃ©glons maintenant notre propriÃ©tÃ© `transform`Â pour
quâ€™elle utilise `translateY()`. Cela permet d'avoir notre texte hors de la boÃ®te au dÃ©but de l'animation, puis de le faire dÃ©filer dedans :

```scss
.btn {
    &:hover + .box {
        transform: scale(1);
        span {
            transform: translateY(0);
        }
    }
}
```


```scss
.box {
    transform: scale(0.1);
    transition: transform 330ms ease-in-out;
    overflow: hidden;
    span {
        display: inline-block;
        transform: translateY(250%);
        transition: transform 280ms ease-out 50ms;
    }
}
```

Vous avez remarquÃ© le changement de la valeur de display en `inline-block`Â ? En effet, la valeur de display par dÃ©faut de `<span>`Â est inline. Or,
`transform`Â ne peut pas manipuler dâ€™Ã©lÃ©ments inline. Nous devons donc modifier le mode dâ€™affichage enÂ `block`Â ou `inline-block`Â avant dâ€™obtenir
des rÃ©sultats.

:::info
Pour en apprendre plus sur les diffÃ©rentes valeurs de display, vous pouvez regarder le chapitre du cours sur leÂ HTML et leÂ CSS :
[Apprenez Ã  crÃ©er votre site web avec HTML5 et CSS3](https://openclassrooms.com/fr/courses/1603881-apprenez-a-creer-votre-site-web-avec-html5-et-css3/1606402-decouvrez-dautres-techniques-de-mise-en-page)
:::

Vous avez peut-Ãªtre aussi remarquÃ© que le texte n'apparaÃ®t pas tant qu'il n'est pas dans la boÃ®te : c'est la propriÃ©tÃ© `overflow: hidden;`Â qui
nous permet cela.

Nous avons aussi ajoutÃ© Ã  notre **transition** `span`Â un petit dÃ©lai et raccourci sa durÃ©e, pour quâ€™elle agisse un peu comme une animation
secondaire (principe dâ€™animation numÃ©ro 8 ! ğŸ¤˜).

![Une animation d'un petit carrÃ© qui grossit](https://user.oc-static.com/upload/2021/02/09/16128910224453_Gif061.gif)

### Faites pivoter vos Ã©lÃ©ments avecÂ `rotate()`

Maintenant que vous maÃ®trisez translateÂ et scale, voyons la derniÃ¨re fonction du trio gagnant : `rotate()`Â !

On peut paramÃ©trer `rotate()`Â en plusieurs unitÃ©s. Nous verrons ici les plus simples Ã  utiliser : les degrÃ©s exprimÃ©s en "deg" et les turns. Un
turn correspond Ã  360 degrÃ©s, ce qui est plutÃ´t intuitif. Il s'agit donc de tours sur soi-mÃªme.

Faisons un test ! Prenons deux boÃ®tes, chacune avec ses propres unitÃ©s de rotation :

```html
<div class="container">
    <button class="btn">Transform!</button>
    <div class="boxes">
        <div class="boxes__base boxes--rotDegrees">rotate(360deg)</div>
        <div class="boxes__base boxes--rotTurns">rotate(1turn)</div>
    </div>
</div>
```

Les deux boÃ®tes sont placÃ©es dans la div `.boxes`. Rappelez-vous que pour animer les propriÃ©tÃ©s dâ€™un objet en CSS, elles doivent se trouver Ã 
cÃ´tÃ© de lâ€™Ã©lÃ©ment suivant dans la hiÃ©rarchie. Nous pouvons donc maintenant sÃ©lectionner les boÃ®tes individuellement et les animer sÃ©parÃ©ment :

```scss
.btn {
    &:hover + .boxes {
        & > .boxes--rotDegrees {
            transform: rotate(0deg);
        }
        & > .boxes--rotTurns {
            transform: rotate(0turn);
        }
    }
}
```

```scss
.boxes {
    &--rotDegrees {
        transform: rotate(-360deg);
        transition: transform 500ms ease-in-out;
    }
    &--rotTurns {
        background: pink;
        transform: rotate(-1turn);
        transition: transform 500ms ease-in-out;
    }
}
```

Chaque boÃ®te dÃ©marre en position de rotation nÃ©gative de 360 deg/1 turn. Au survol du bouton, cela dÃ©clenche la transition. On les fait alors
tourner vers la position 0 deg/0 turn sur une demi-seconde, en utilisant la fonction de temporisation ease-in-out.

![L'animation de deux carrÃ©s qui font une rotation](https://user.oc-static.com/upload/2021/02/09/16128910370748_Gif062.gif)

Le rÃ©sultat final est exactement le mÃªme pour les deux boÃ®tes. Ã€ vous de choisir entre degrÃ©s et turns selon vos prÃ©fÃ©rences. Pour ma part, j'ai
tendance Ã  prÃ©fÃ©rer turn lorsque mon Ã©lÃ©ment fait au moins un tour sur lui-mÃªme, et deg lorsqu'il s'agit de valeurs infÃ©rieures Ã  un tour.

### Combinez les fonctions scale, position et rotate !

Reprenons la boÃ®te que nous avions utilisÃ©e en combinant scale et translate. Nous pouvons maintenant complexifier le tout en ajoutant une rotation
au texte.

```scss
.btn {
    &:hover + .box {
        transform: scale(1);
        transform: rotate(0deg);
        span {
            transform: translateY(0);
        }
    }
}

.box {
    overflow: hidden;
    transform: scale(.1);
    transform: rotate(-90deg);
    transition: transform 330ms ease-in-out;
    span {
        transform: translateY(250%);
        transition: transform 280ms ease-out 50ms;
        display: block;
    }
}
```

Maintenant, pendant que la boÃ®te sâ€™agrandit et que le texte apparaÃ®t, elle devrait Ã©galement tourner dâ€™un quart de tour, de -90 deg Ã  0 deg :

![L'animation d'un carrÃ© qui pivote mais dont l'Ã©criture disparaÃ®t](https://user.oc-static.com/upload/2021/02/18/16136588170894_gif063_2.gif)

Zuuuuuuut ! ğŸ˜­ On a tout cassÃ© !

La boÃ®teÂ pivote, mais notre animation scale a disparu. Comme si la transformation rotate() Ã©crasait la transformation `scale()`...

Mettons un commentaire sur notreÂ `rotate()`Â pour vÃ©rifier que nous nâ€™avons pas causÃ© un problÃ¨me dans leÂ `scale()`Â :

```scss
.btn {
    &:hover + .box {
        transform: scale(1);
        // transform: rotate(0deg);
        span {
            transform: translateY(0);
        }
    }
}
.box {
    overflow: hidden;
    transform: scale(.1);
    // transform: rotate(-90deg);
    transition: transform 330ms ease-in-out;
    span {
        transform: translateY(250%);
        transition: transform 280ms ease-out 50ms;
        display: block;
    }
}
```

![L'animation d'un petit carrÃ© qui grossit](https://user.oc-static.com/upload/2021/02/09/16128910675525_Gif064.gif)

Bon. Pourtant,Â `scale()`Â semble toujours fonctionner.

Le problÃ¨me vient du fait quâ€™on ne peut assigner quâ€™une seule propriÃ©tÃ© `transform`Â Ã  un Ã©lÃ©ment. Je vous conseille de le noter dans un coin de
votre tÃªte si vous voulez Ã©viter de vous arracher les cheveux ğŸ™ƒ.

:::note ?
Alors, comment faire pour avoir plusieurs transformations dans une seule propriÃ©tÃ© `transform`Â ?
:::

Pour cela, faites une liste de toutes les fonctions que vous voulez utiliser dans la propriÃ©tÃ© `transform`.

Pour crÃ©er un effet qui combine rotation et changement d'Ã©chelle, nous devons indiquer la fonction `rotate()`Â Ã  la suite de `scale()`Â dans la
propriÃ©tÃ© `transform`Â :

```scss
.btn {
    &:hover + .box {
        transform: scale(1) rotate(0deg);
        span {
            transform: translateY(0);
        }
    }
}
.box {
    overflow: hidden;
    transform: scale(.1) rotate(\-90deg);
    transition: transform 330ms ease-in-out;
    span {
        transform: translateY(250%);
        transition: transform 280ms ease-out 50ms;
        display: block;
    }
}
```

Ce qui donne :

![L'animation d'un carrÃ© qui grossit avec du texte Ã  l'intÃ©rieur](https://user.oc-static.com/upload/2021/02/09/16128910816927_Gif065.gif)

Yaaaay ! On a rÃ©ussi ! Vous avez le droit Ã  une petite danse de la victoire ğŸ•º.

:::caution !
Lâ€™utilisation de plusieurs fonctions a un bÃ©mol : lâ€™ordre dans lequel on assigne les fonctions peut avoir un gros impact sur le rÃ©sultat final. Il
faut savoir que le navigateur effectue les calculs de chaque fonction dans lâ€™ordre, **de droite Ã  gauche**.
:::

Ici, l'ordre selon lequel vous effectuez la rotation et le changement dâ€™Ã©chelle ne va pas poser de problÃ¨me. En effet, les deux nâ€™ont pas dâ€™effet
lâ€™un sur lâ€™autre. Une rotation de 90 degrÃ©s suivie dâ€™un agrandissement de 200 % aura le mÃªme effet quâ€™un agrandissement de 200 % suivi dâ€™une
rotation de 90 degrÃ©s.

PourÂ `scale`Â etÂ `translate`, en revanche, câ€™est trÃ¨s diffÃ©rent. Si on dÃ©place un Ã©lÃ©ment de 200 % avant de lâ€™agrandir Ã  200 %, cela aura un
rÃ©sultat trÃ¨s diffÃ©rent par rapport au fait de lâ€™agrandir avant de le dÃ©placer :

```scss
.btn {
    &:active + .box {
        & > .box__base--tranxScale {
            transform: translateX(200%) scale(2);
        }
        & > .box__base--scaleTranx {
            transform: scale(2) translateX(200%);
        }
    }
}
.box {
    &__base {
        &--tranxScale {
            background-color: #15dea5;
            transition: transform 330ms ease-in-out;
        }
        &--scaleTranx {
            background-color: pink;
            transition: transform 330ms ease-in-out;
        }
    }
}
```

On applique `.box__base-tranxScale`Â Ã  la premiÃ¨re boÃ®te : elle va commencer par appliquer la transformation `scale()`,Â suivie de `translateX()`.

La deuxiÃ¨me boÃ®te fonctionne avecÂ `.box__base--scaleTranx()`Â et appliquera la transformation `translateX()`, suivie deÂ `scale()`Â :

![L'animation de deux carrÃ©s qui se dÃ©placent vers la droite et grossissent](https://user.oc-static.com/upload/2021/02/09/16128910946731_Gif066.gif)

La boÃ®te numÃ©ro 2 va bien plus loin que la premiÃ¨re. Plus exactement deux fois plus loin. Pourquoi ? Parce que le navigateur exÃ©cute les fonctions
transform dans lâ€™ordre, et il utilise le layout de dÃ©part comme point dâ€™origine pour les transformations.

En dÃ©composant lâ€™ordre des opÃ©rations de ces transformations, on voit bien la premiÃ¨re boÃ®te passer Ã  200% dâ€™Ã©chelle puis se dÃ©placer sur la
droite de 200% de la taille originelle de la boÃ®te :

![L'animation d'un carrÃ© qui grossit et se dÃ©place vers la droite](https://user.oc-static.com/upload/2021/02/09/16128911094395_Gif067.gif)

La boÃ®te numÃ©ro 2, quant Ã  elle, se dÃ©place de la mÃªme distance de 200%, mais au lieu de sâ€™agrandir depuis le centre de sa nouvelle position,
elle sâ€™agrandit vers lâ€™extÃ©rieur en partant du centre d'origine avant son dÃ©placement :

![L'animation d'un carrÃ© qui se dÃ©place vers la droite et grossit](https://user.oc-static.com/upload/2021/02/09/16128911347225_Gif068.gif)

La boÃ®te 2 sâ€™est dÃ©placÃ©e vers la droite de 200%, puis la translation a Ã©tÃ©, dans les faits, doublÃ©e par lâ€™Ã©chelle, la faisant de fait se
dÃ©placer de 400% vers la droite ğŸ¤¨.

### Penchez du bon cÃ´tÃ© de la force

Position, scale, et rotation. VoilÃ  un arsenal dÃ©jÃ  respectable.

Mais vous avez sÃ»rement dÃ©jÃ  scrollÃ© vers le bas de la page : vous savez bien que nous n'avons pas fini ! Voyons maintenant la fonction `skew()` !

Dans le mÃªme esprit que position et scale, vous pouvez dÃ©sormais incliner des objets horizontalement ou verticalement. Pour cela,Â `skew()` penche
les bords horizontaux ou verticaux, ou mÃªme les deux, en utilisant les fonctions `skewX()`,Â `skewY()`,Â etÂ `skew()`Â :

```scss
.box {
    &--skewX {
        transform: skewX(45deg);
    }
    &--skewY {
        transform: skewY(45deg);
    }
    &--skew {
        transform: skew(45deg, 45deg);
    }
}
```

![Les fonctions skewX(), skewY() et skew()](https://user.oc-static.com/upload/2021/02/09/16128911542346_Gif069.gif)

### Passez dans une nouvelle dimension

Câ€™est Ã  peu prÃ¨s tout pour les capacitÃ©s de transformâ€¦ en 2D.

Eh oui ! Vous nâ€™auriez pas oubliÃ© une dimension, par hasard ? ğŸ˜

Les fonctions pour les transformations en 3D sont proches des versions 2D, Ã  ceci prÃ¨s qu'elles ont Ã©galement la capacitÃ© de transformer sur
lâ€™axe Z. Faisons un rapide tour d'horizon des fonctions 3D disponibles avec `transform`Â :

![Une animation des fonctions 3D disponibles avec transform](https://user.oc-static.com/upload/2021/02/15/16133837187089_Gif070.gif)

:::info
Pour effectuer une transformation dâ€™Ã©chelle en 3D sur lâ€™axe Z, il faut dâ€™abord lâ€™avancer vers lâ€™avant ou lâ€™arriÃ¨re en utilisant `translateZ()`
ou `translate3d()`. Sinon,Â `scaleZ()`Â ouÂ `scale3d()`Â verrait son Ã©chelle modifiÃ©e de 0â€¦ ce qui nâ€™aurait aucun effet, Ã©videmment.
:::

Si les fonctions 3D ressemblent beaucoup aux fonctions 2D, vous avez peut-Ãªtre remarquÃ© une nouvelle fonction : `perspective()`.

La valeur quâ€™on donne Ã  `perspective()`Â indique au navigateur Ã  quelle "distance" se trouve le spectateur. Comme dans le monde rÃ©el, plus un
objet est proche, plus le mouvement aura lâ€™air important, alors quâ€™Ã  lâ€™inverse, un objet distant semblera plus statique.

```scss
.box {
    &--perspective75px {
        transform: perspective(75px) rotateX(45deg);
    }
    &--perspective150px {
        transform: perspective(150px) rotateX(45deg);
    }
    &--perspective300px {
        transform: perspective(300px) rotateX(45deg);
    }
}
```

Avec une perspective de 75 px, on se retrouve bien plus proche de la boÃ®te quâ€™Ã  150 ou 300px. La rotation 3D semble donc bien plus marquÃ©e que
les transformations dont la perspective est plus grande.

![Des animations perspectives avec diffÃ©rents pixels](https://user.oc-static.com/upload/2021/02/09/16128913219948_Gif071.gif)

On peut utiliser la perspective et les transformations 3D pour ajouter de la profondeur et des effets visuels Ã  nos animations.

Vous voyez bien que plus le cours avance, plus nous repoussons les limites de ce qu'il est possible de faire en animations CSS ! BientÃ´t, votre
crÃ©ativitÃ© n'aura plus de limite. ğŸ§™â€â™‚ï¸

### En rÃ©sumÃ©

- la propriÃ©tÃ© `transform`Â nous permet de manipuler et animer nos sites de presque toutes les maniÃ¨res, et comme tout se passe pendant lâ€™Ã©tape
composition, les animations sont bien fluides sur tous les supports ;
- on peut dÃ©placer des Ã©lÃ©ments avec les fonctions translate :Â `translate()`, `translateX()`, `translateY()`Â et `translate3d()`Â ;
- on peut agrandir avec les fonctions scale : `scale()`, `scaleX()`, `scaleY()`Â et `scale3d()`Â ;
- et on peut les faire pivoter grÃ¢ce aux fonctions rotate : `rotate()`, `rotateX()`, `rotateY()`Â et `rotateZ()`Â ;
- si on ajoute une deuxiÃ¨me propriÃ©tÃ© `transform`, elle annule la premiÃ¨re. On ne peut donc dÃ©finir quâ€™une seule propriÃ©tÃ© `transform`Â dans un
mÃªme sÃ©lecteur ;
- pour effectuer plusieurs transformations, on peut les lister dans une mÃªme propriÃ©tÃ© transform commeÂ :

```scss
transform: translateX(200%) scale(2);
```

- une propriÃ©tÃ© avec plusieurs fonctions exÃ©cute les fonctions dans lâ€™ordre, de droite Ã  gauche ;
- les fonctions de transformations en 3D commeÂ `translate3d()`, `rotateZ()`Â et `scale3d()`Â ont Ã©galement besoin de la fonction perspective pour
indiquer au navigateur la distance Ã  laquelle l'utilisateur se trouve : plus la distance est grande, moins l'animation sera marquÃ©e.

_Dans le chapitre suivant, nous verrons comment effectuer des animations un peu plus spÃ©cifiques, telles qu'un mouvement de balancier. Rendez-vous
au chapitre suivant !_

-----

## Modifiez le point dâ€™ancrage dâ€™un Ã©lÃ©ment grÃ¢ce Ã  transform-origin

[Modifiez le point dâ€™ancrage dâ€™un Ã©lÃ©ment grÃ¢ce Ã  transform-origin - CrÃ©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340920-modifiez-le-point-d-ancrage-d-un-element-grace-a-transform-origin)

<Vimeo vimeoId="508777270" />

<br />

`Transform`Â nous permet de crÃ©er une **multitude** d'effets de mouvement : nous pouvons absolument tout faireâ€¦

Sauf un mouvement de balancierâ€¦

Ou changer dâ€™Ã©chelle du haut vers le basâ€¦ ğŸ™ƒ

Mais comme toujours en CSS, il y a une solution !

### DÃ©couvrez le point d'ancrage

Par dÃ©faut, toutes les fonctions deÂ `transform`Â partent du **centre** de lâ€™Ã©lÃ©ment. Donc quand on change lâ€™Ã©chelle dâ€™un objet, il sâ€™agrandit
vers lâ€™extÃ©rieur :

![Le changement d'Ã©chelle se fait depuis le centre](https://user.oc-static.com/upload/2021/02/09/16128913910144_Gif073.gif)

Et quand on fait **pivoter** un Ã©lÃ©ment, il reste sur son axe :

![Le pivotement se fait sur un axe](https://user.oc-static.com/upload/2021/02/09/16128914606847_Gif074.gif)

Et souvent, câ€™est trÃ¨s bien. Mais parfois, Ã§a ne suffit pas.

La propriÃ©tÃ© `transform-origin`Â est lÃ  pour Ã§a ! Elle permet de dÃ©placer un **point dâ€™ancrage** oÃ¹ on veut, pour faire partir nos animations de
ce point.

Nous pouvons par exemple dÃ©placer le point dâ€™origine d'un Ã©lÃ©ment Ã  son sommet et le faire grandir :

![Un exemple de la propriÃ©tÃ© transform-origin](https://user.oc-static.com/upload/2021/02/09/16128914904677_Gif075.gif)

Nous pouvons mettre le point dans un coin et **faire balancer** lâ€™objet :

![Exemple de la propriÃ©tÃ© transform-origin](https://user.oc-static.com/upload/2021/02/09/16128915071518_Gif076.gif)

Dans ce chapitre, allons apprendre Ã  maÃ®triser la propriÃ©tÃ© `transform-origin`Â pour apprendre Ã  faire tout cela. C'est parti !

### DÃ©placez le centre

C'est Ã  nouveau la propriÃ©tÃ© `transform`Â qui sera notre alliÃ©e ici.

CrÃ©ons donc une barre de chargement, avec une image vide qui se remplit pendant le chargement : sa progression ne correspond pas rÃ©ellement au
pourcentage de chargement, mais sert de transition entre deux blocs de contenu.

```html
<div class="container">
    <div class="btn">Charger!</div>
    <div class="progress">
        <div class="progress__bar"></div>
    </div>
</div>
```

Nous avons stylisÃ© lâ€™image avec une bordure et un peu de marge intÃ©rieure, et la barre avec une couleur de fond, qui sâ€™affiche comme Ã§a :

![Barre de chargement pleine](https://user.oc-static.com/upload/2019/08/26/15668421113643_Capture%20d%E2%80%99e%CC%81cran%202019-08-26%20a%CC%80%2019.54.53.png)

Maintenant, ajoutons la propriÃ©tÃ© `transform`Â Ã  notre barre, et servons-nous de la fonction scale-x qui nous est dÃ©jÃ  familiÃ¨re sur 0 :

```scss
.progress {
    &__bar {
        transform: scaleX(0);
    }
}
```

Et voilÃ  notre barre de progression vide !

![Barre de chargement vide](https://user.oc-static.com/upload/2019/08/26/15668421300869_Capture%20d%E2%80%99e%CC%81cran%202019-08-26%20a%CC%80%2019.54.47.png)

Nous pouvons utiliser le pseudosÃ©lecteur `:active`Â pour la remplir afin d'agrandir la barre Ã  100% de largeur quand on clique sur le bouton
â€œChargerâ€.

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
```

```scss
.progress {
    &__bar {
        transform: scaleX(0);
    }
}
```

Maintenant, quand on clique sur le bouton, la barre de chargement se remplitâ€¦Â immÃ©diatement.

![Barre de chargement immÃ©diat](https://user.oc-static.com/upload/2021/02/09/16128917971846_Gif077.gif)

Mais nous sommes dans un cours d'animation ici ! Nous voulons donc remplir la barre petit Ã  petit. Pour cela, ajoutons donc une transition, en
lâ€™animant sur une durÃ©e de 2 secondes :


```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform: scaleX(0);
        transition: transform 2000ms;
    }
}
```

Voyons voir comment notre barre se comporte maintenant :

![La barre de chargement qui se remplit depuis le centre, dans les deux sens](https://user.oc-static.com/upload/2021/02/09/16128918089565_Gif078.gif)

Heuuuu, ce n'est pas exactement l'effet que nous recherchions. Quoique, on va peut-Ãªtre lancer une nouvelle mode ? ğŸ˜

Les barres de chargement se remplissent normalement depuis la gauche vers la droite. Ici, la barre se remplit, mais en partant du milieu. Pour
corriger notre barre, nous pouvons maintenant **tester** la propriÃ©tÃ© `transform-origin`.

`transform-origin`Â nous permet de dÃ©placer le centre d'origine de notre transformation, selon les valeurs que nous lui assignons.

Pour dÃ©placer le centre dâ€™origine, on peut utiliser des **unitÃ©s** comme les **pixels**, ou un pourcentage des dimensions dâ€™un Ã©lÃ©ment, de la
mÃªme maniÃ¨re que pour la fonction `translate`. Dans les deux cas, lâ€™axe X est mesurÃ© Ã  partir de la bordure gauche de lâ€™Ã©lÃ©ment, et lâ€™axe Y est
mesurÃ© depuis le bord supÃ©rieur.

Le point dâ€™origine par dÃ©faut, au centre de lâ€™Ã©lÃ©ment, peut donc Ãªtre Ã©crit de cette maniÃ¨re : `transform-origin: 50% 50%`Â ;

Ici, nous voulons placer le **point dâ€™origine** de notre barre de chargement sur sa bordure gauche, pour quâ€™elle progresse vers la droite. Nous
devons donc mettre l'origine de x Ã  0% :

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform-origin: 0% 50%;
        transform: scaleX(0);
        transition: transform 1000ms;
    }
}
```

On devrait voir la barre Ãªtre vide au dÃ©part. Puis au clic sur le bouton, elle devrait sâ€™agrandir vers la droite jusquâ€™Ã  remplir le cadre :

![Une animation CSS d'une barre de chargement complÃ¨te](https://user.oc-static.com/upload/2021/02/09/16128918195266_Gif079.gif)

Parfait ! Mettons notre touche finale en ajoutant notre propre fonction de timing `cubic-bezier()`. Nous voulons que la barre commence avec un
ease-in peu prononcÃ©, mais que son ease-out soit bien perceptible Ã  la fin. Le profil de la courbe ressemblerait Ã  quelque chose comme Ã§a :

![La courbe de notre animation](https://user.oc-static.com/upload/2019/08/06/15650825274307_image24.png)

Les valeurs de notre courbe dâ€™accÃ©lÃ©ration sont `cubic-bezier(.32, 0, .07, 1)`. Rentrons-les dans notre fonction de timing :

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform-origin: 0% 50%;
        transform: scaleX(0);
        transition: transform 1000ms cubic-bezier(.32,0,.07,1);
    }
}
```

![La barre de chargement fonctionne](https://user.oc-static.com/upload/2021/02/09/1612891847843_Gif080.gif)

Et c'est encore une rÃ©ussite pour vous ! Bravo !ğŸ’ª

### Utilisez la bonne valeur

Les valeurs de `transform-origin`Â ne se limitent pas Ã  des longueurs ou des pourcentages.

On peut aussi utiliser des mots clÃ©s CSS pour dÃ©finir les points dâ€™ancrage, comme `left`Â pour le mettre sur le bord gauche, ou `right`Â pour le
mettre Ã  droite :

```scss
.box--left-origin {
// positionne l'origine du cÃ´tÃ© gauche
    transform-origin: left 50%;
}
.box--right-origin {
// positionne l'origine du cÃ´tÃ© droit
    transform-origin: right 50%;
}
```

![Animation de Transform-origin left et right](https://user.oc-static.com/upload/2021/02/09/16128918891629_Gif081.gif)

On peut aussi utiliser `top`Â et `bottom`Â :

```scss
.box--top-origin {
// positionne l'origine au sommet de l'Ã©lÃ©ment
    transform-origin: 50% top;
}
```

```scss
.box--bottom-origin {
// positionne l'origine en bas de l'Ã©lÃ©ment
    transform-origin: 50% bottom;
}
```

![Animation de transform-origin top et bottom](https://user.oc-static.com/upload/2021/02/09/16128919050559_Gif082.gif)

ConcrÃ¨tement, les mots clÃ©s `left`Â et `top`Â correspondent Ã  0%, tandis que `right`Â etÂ `bottom`Â correspondent Ã  100%. Mais l'utilisation de ces
mots clÃ©s permet d'Ãªtre explicite dans la maniÃ¨re d'Ã©crire notre code.

Le dernier mot clÃ© est `center`. Il peut Ãªtre assignÃ© Ã  lâ€™axe X ou Y, et correspond Ã  une valeur de 50 :

```scss
.box--left-origin {
// positionne l'origine au centre de l'Ã©lÃ©ment
    transform-origin: center center;
}
```

![Animation de transform-origin center](https://user.oc-static.com/upload/2021/02/09/1612891919281_Gif083.gif)

Jusquâ€™Ã  maintenant, nous avons toujours assignÃ© deux valeurs Ã  `transform-origin`, une pour X et lâ€™autre pour Y. Mais une seule valeur peut
aussi suffire. Si cette valeur est un nombre, elle sâ€™appliquera Ã  lâ€™axe X et laissera Y Ã  la valeur par dÃ©faut de 50 %.

Dans le cas de notre barre de progression, c'est surtout la valeur de X qui nous intÃ©resse. La valeur de 50 % pour lâ€™axe Y est donc superflue.
Retirons cette valeur, ce qui simplifie le code et montre plus explicitement que nous modifions l'axe X quand nous relirons le code dans le
futur :

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform-origin: 0%;
        transform: scaleX(0);
        transition: transform 1000ms cubic-bezier(.32,0,.07,1);
    }
}
```

Notre code est plus propre et fonctionne toujours de la mÃªme maniÃ¨re dans le navigateur :

![La barre de chargement fonctionne de la mÃªme faÃ§on](https://user.oc-static.com/upload/2021/02/09/16128919347965_Gif084.gif)

Et le navigateur n'a pas fini de nous Ã©tonner :Â si on assigne un simple mot clÃ© Ã  `transform-origin`, le navigateur va comprendre de lui-mÃªme Ã 
quel axe lâ€™appliquer, et laisser lâ€™autre axe sur sa valeur par dÃ©faut.

Il est plus explicite dâ€™utiliser le mot clÃ© `left`Â plutÃ´t que de mettre un `transform-origin` Ã  0%, car cela nous indique instantanÃ©ment que
nous avons dÃ©placÃ© le `transform-origin` sur le cÃ´tÃ© gauche. Revenons une derniÃ¨re fois Ã  notre barre de chargement et remplaÃ§ons la valeur
numÃ©rique de `transform-origin`Â par le mot clÃ© `left`, pour rendre notre code aussi clair et concis que possible :

```scss
.btn {
    &:active {
        & + .progress {
            & > .progress__bar {
                transform: scaleX(1);
            }
        }
    }
}
.progress {
    &__bar {
        transform-origin: left;
        transform: scaleX(0);
        transition: transform 1000ms cubic-bezier(.32,0,.07,1);
    }
}
```

### Passez dans la troisiÃ¨me dimension

Nous avons vu que la propriÃ©tÃ© `transform`Â permet de **manipuler** des Ã©lÃ©ments en deux dimensions... mais aussi en trois. Et `transform-origin`
fonctionne parfaitement avec des valeurs X et Y en 2D. Mais comment faire pour changer le point dâ€™origine de transformations 3D ?

Vous lâ€™avez peut-Ãªtre devinÃ© ğŸ˜ : on ajoute une troisiÃ¨me valeur Ã  la liste ! On peut utiliser les valeurs X et Y comme en 2D, avec des
pourcentages ou des mots-clÃ©s, mais lâ€™axe Z DOIT obligatoirement Ãªtre dÃ©fini avec des unitÃ©s rÃ©elles comme les pixels, les centimÃ¨tres, etc.

```scss
.btn {
    perspective: 500px;
    &:active {
        & > .btn__flip {
            transform: rotateX(-90deg);
        }
    }
    &__flip {
        transform-style: preserve-3d;
        transform-origin: center bottom 7.5vw;
        transition: transform 500ms cubic-bezier(.7, 0, .23, 1);
        &--off {
            transform: rotateX(0deg) translateZ(7.5vw);
        }
        &--on {
            transform: rotateX(90deg) translateZ(7.5vw);
        }
    }
}
```

Alors, tentons de combiner les fonctions de transformation 3D avec des valeurs transform-origin 3D pour crÃ©er des objets Ã  trois dimensions,
comme des boutons Ã  plusieurs faces !

![Un bouton en 3D](https://user.oc-static.com/upload/2021/02/09/16128919491569_Gif085.gif)

Vous trouverez le code source de notre bouton sur [ce CodePen](https://codepen.io/atoulmet/pen/aboJmOx).

_Avez-vous essayer de changer la vitesse de l'animation ou la couleur des faces du bouton ?_

Et chose promise, chose due. Je vous parlais dans la vidÃ©o d'introduction d'un fameux sabre Jedi : voici ce que donne une animation CSS de sabre
Jedi avec la propriÃ©tÃ©Â `transform-origin`. Le [code source est ici](https://codepen.io/atoulmet/pen/RwbRRaK).

![Animation d'un sabre Jedi qui s'allume](https://user.oc-static.com/upload/2021/02/09/16128919632702_Gif086.gif)

Encore une fois, n'hÃ©sitez pas Ã  manipuler les valeurs indiquÃ©es.

### En rÃ©sumÃ©

- `transform-origin`Â permet de **repositionner** le point dâ€™ancrage, qui se trouve par dÃ©faut au centre de lâ€™Ã©lÃ©ment ;
- on peut **rÃ©gler** ce point dâ€™origine en utilisant des unitÃ©s comme px, rem, vh, etc. ;
- il est aussi possible d'utiliser des pourcentages pour X et Y ;
- ou encore, on peut utiliser des mots clÃ©s : `left`Â etÂ `right`Â pour lâ€™axe X, `top`Â et `bottom`Â pour lâ€™axe Y, et `center`Â pour les deux ;
- il est possible de ne pas indiquer la valeur de l'axe Y ou, quand on utilise des mots clÃ©s, de mettre uniquement une valeur : le navigateur
comprend de lui-mÃªme Ã  quel axe la valeur s'applique ;
- quand on change le point dâ€™origine en 3D, la valeur de Z doit Ãªtre exprimÃ©e en unitÃ©s (et non en pourcentages) !

_CrÃ©er des animations, c'est bien, mais pouvoir analyser leurs performances, c'est mieux. C'est ce que vous allez dÃ©couvrir dans le chapitre
suivant._

-----

## Analysez la performance de vos animations avec Chrome DevTools

[Analysez la performance de vos animations avec Chrome DevTools - CrÃ©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340921-analysez-la-performance-de-vos-animations-avec-chrome-devtools)

<Vimeo vimeoId="508777299" />

<br />

Nous avons passÃ© un temps considÃ©rable Ã  apprendre comment optimiser nos animations, maisâ€¦

Comment savoir si Ã§a marche ?

Pour le moment, vous avez dÃ» me croire sur parole concernant les propriÃ©tÃ©s Ã  bannir.

Car toutes vos animations sont probablement parfaitement fluides sur votre machineâ€¦ (oui oui, je dis "machine" pour "ordinateur" ğŸ¤–) mais si
vous apprenez Ã  dÃ©velopper, c'est que vous Ãªtes probablement sur un ordinateur **puissant**, Ã©quipÃ© dâ€™une carte graphique moderne (sans vouloir
vous juger sans vous connaÃ®tre). Mais comment savoir si lâ€™animation sera bien fluide sur la tablette bas de gamme achetÃ©e en soldes par votre
grand-pÃ¨re ?

Heureusement pour nous, Chrome propose toute une suite dâ€™outils intÃ©grÃ©s. Vous les avez peut-Ãªtre dÃ©jÃ  utilisÃ©s en inspectant le code source
dâ€™un site web, ou en ouvrant la console. Mais ce nâ€™est qu'une toute petite partie de l'ensemble de ces outils, aussi appelÃ©s DevTools.

**DevTools** met Ã  notre disposition de nombreux outils. Notamment un qui simule le fonctionnement de nos animations sur un vieux smartphone. Il
permet Ã©galement d'**analyser** en dÃ©tail les performances de notre animation, afin d'identifier les problÃ¨mes potentiels et de les corriger.

Dans ce chapitre, nous apprendrons Ã  maÃ®triser l'outil de performance de **Chrome DevTools** pour que nos animations soient aussi fluides que
possible.

### Faites apparaÃ®tre des Ã©lÃ©ments cachÃ©s

Ici, nous avons une petite application. Elle reprÃ©sente une sÃ©rie de cartes, chaque carte munie dâ€™une photo et de quelques blocs de texte. Il y
a Ã©galement un bouton qui rÃ©vÃ¨le une troisiÃ¨me carte cachÃ©e :

![Animation d'un bloc de texte cachÃ© derriÃ¨re un autre](https://user.oc-static.com/upload/2019/08/06/15650844369654_pt02ch04-fall1.gif)

Lâ€™apparition de la carte cachÃ©e est constituÃ©e de plusieurs transitions : lâ€™apparition de la carte elle-mÃªme, et une deuxiÃ¨me transition qui
pousse lâ€™autre carte sur la droite.

```scss
$easing: cubic-bezier(.49,.18,.23,1);
$width: 33vh;
$height: 72vh;
$margin-right: 4vh;
$wid-marg: $width + $margin-right;
.card {
    width: $width;
    height: $height;
    overflow: hidden;
    &:not(:last-child) {
        margin-right: $margin-right;
    }
    &--anim {
        transform: translateX($width-marg);
        transition: transform 700ms $easing;
    }
    &__contents {
        width: $width;
        overflow: hidden;
        &--anim {
            transform: translateX($wid-marg*-1);
            transition: transform 700ms $easing;
        }
    }
}
.btn {
    &--reveal {
        &:hover {
            & + .card {
                &--anim {
                    transform: translateX(0);
                }
                .card__contents--anim {
                    transform: translateX(0);
                }
            }
        }
    }
}
```

On a aussi ajoutÃ© quelques mouvements secondaires (souvenez-vous des 12 principes) avec plusieurs transitions pour rÃ©vÃ©ler les blocs de texte de
la carte :

```scss
</>
$easing: cubic-bezier(.49,.18,.23,1);
$width: 33vh;
$height: 72vh;
$margin-right: 4vh;
$wid-marg: $width + $margin-right;
.card {
    width: $width;
    height: $height;
    overflow: hidden;
    &:not(:last-child) {
        margin-right: $margin-right;
    }
    &--anim {
        transform: translateX($width-marg);
        transition: transform 700ms $easing;
    }
    &__contents {
        width: $width;
        overflow: hidden;
        &--anim {
            transform: translateX($wid-marg*-1);
            transition: transform 700ms $easing;
        }
    }
    &__block {
        overflow: hidden;
        // une boucle crÃ©Ã©e avec sass qui itÃ¨re de 1 Ã  3, en utilisant l'index
        // comme suffixe pour le nom --anim mod
        // ainsi que comme valeur pour multiplier la valeur de transition delay
        @for $i from 1 through 3 {
            &--anim-#{$i} {
                transform: translateX(-108%);
                transition: transform 500ms $easing 50ms*$i;
            }
        }
        &:not(:first-child) {
            margin-top: 1rem;
        }
    }
}
.btn {
    &--reveal {
        &:hover {
            & + .card {
                &--anim {
                    transform: translateX(0);
                }
                .card__contents--anim {
                    transform: translateX(0);
                }
                .card__block--anim {
                    transform: translateX(0);
                }
            }
        }
    }
}
```

Toutes ces animations sont bien fluides sur notre ordinateur, mais Ã§a ne suffit pas. Nous voulons quâ€™elles soient fluides sur tous les Ã©crans,
y compris sur des supports anciens ou bas de gamme. Au total, lâ€™apparition de la carte est constituÃ©e de 5 transitions distinctes. Comment nous
assurer quâ€™elles fonctionneront bien de maniÃ¨re fluide chez tout le monde ?

Vous pouvez laisser un bon d'achat pour commander un appareil moderne sur votre site, mais Ã§a risque peut-Ãªtre d'Ãªtre coÃ»teux ğŸ¤”.

Mais il existe un moyen plus facile et moins onÃ©reux de tester et d'analyser nos animations.

Mesdames et Messieurs, permettez-moi de vous prÃ©senter Chrome Devtools ! ğŸ¥³

Eh oui, je vous en parlais, câ€™est ce qui apparaÃ®t quand on clique sur â€œInspecterâ€ sur une page web. Il fait bien plus que nous aider Ã 
comprendre comment une page est organisÃ©e.

Au-delÃ  de lâ€™onglet **Elements**, DevTools comporte toute une sÃ©rie dâ€™autres onglets pour inspecter, dÃ©boguer et analyser divers aspects de nos
sites. Ici, c'est lâ€™onglet **Performance** qui va nous intÃ©resser. Il nous permet dâ€™enregistrer et dâ€™analyser comment une page se charge, rÃ©agit,
et sâ€™anime.

Ã‡a paraÃ®t Ãªtre pas mal pour Ã©valuer la performance de nos animations, non ? Alors ouvrons DevTools et voyons Ã§a !

### Ouvrez la boÃ®te Ã  outils DevTools

Avant de commencer lâ€™exploration de lâ€™onglet **Performance**, nous devons ouvrir DevTools. Vous avez probablement lâ€™habitude de faire un clic
droit sur un Ã©lÃ©ment dâ€™une page et de choisir â€œInspecterâ€.

Mais il existe un moyen plus rapide pour le faire. DevTools peut Ãªtre ouvert par le raccourci clavier Ctrl+Shift+I sous Windows, ou Cmd+Opt+I
sur Mac.

Une fois DevTools ouvert, en haut de la fenÃªtre, on peut trouver une sÃ©rie de boutons qui amÃ¨nent Ã  diffÃ©rents onglets. Si lâ€™onglet Performance
nâ€™est pas visible Ã  droite de lâ€™onglet Ã‰lÃ©ments, selon la taille de votre fenÃªtre, vous pouvez lâ€™ouvrir en cliquant sur la double flÃ¨che Ã 
droite, et en sÃ©lectionnant â€œPerformanceâ€ dans le menu qui apparaÃ®t :

![Une vidÃ©o montrant comment accÃ©der Ã  l'onglet Performance](https://user.oc-static.com/upload/2021/02/15/16133895775464_2C4_1.gif)

Maintenant que lâ€™onglet Performance est ouvert, nous arrivons sur une fenÃªtre plutÃ´t spartiateÂ en apparence. En effet, celle-ci contient juste
quelques boutons et des instructions disant que nous pouvons cliquer sur le bouton â€œRecordâ€ pour enregistrer, ou cliquer sur le bouton du
dessous pour enregistrer le chargement de la page :

![Illustration du bouton record](https://user.oc-static.com/upload/2021/02/15/16133895917719_2C4_2.gif)

Mais avant de cliquer sur lâ€™un de ces boutons, ajustons un peu notre installation. En haut de la fenÃªtre se trouve une case â€œScreenshotsâ€. Si on
coche la case, Chrome prendra une capture dâ€™Ã©cran de chaque image de lâ€™enregistrement, nous permettant ainsi de visionner le dÃ©roulement de
lâ€™animation image par image. Cette option nâ€™est pas toujours nÃ©cessaire pour analyser les performances dâ€™un site, comme quand il sâ€™agit de
performances rÃ©seau, mais lâ€™animation est un domaine trÃ¨s visuel, lâ€™option screenshot peut donc s'avÃ©rer particuliÃ¨rement utile. Nous allons
donc cocher cette case Screenshots :

![Une image montrant comment accÃ©der Ã  Screenshots](https://user.oc-static.com/upload/2019/08/06/15650858539635_image51.png)

Nous voilÃ  presque prÃªts Ã  commencer lâ€™enregistrement. Mais avant, il nous reste une derniÃ¨re chose Ã  faire. Rappelez-vous que nous voulons voir
nos animations telles quâ€™elles apparaissent sur des appareils plus lents. Or, si on enregistre maintenant, on verra seulement lâ€™animation
sâ€™exÃ©cuter sur notre ordinateur. Pour remÃ©dier Ã  cela, lâ€™onglet Performance nous permet de brider la vitesse de notre processeur.

En cliquant sur la roue de paramÃ©trages dans le coin en haut Ã  droite, quatre options apparaissent, dont lâ€™option â€œCPU throttlingâ€. Simulons
lâ€™appareil le plus lent possible en choisissant 6X, qui limite notre processeur Ã  une vitesse six fois plus lente que ses capacitÃ©s (n'oubliez
surtout pas de dÃ©cocher cette case quand vous aurez terminÃ©, sinon votre navigateur pourrait trÃ¨s rapidement vous rendre complÃ¨tement fou ğŸ˜‚) :

![VidÃ©o montrant comment accÃ©der Ã  l'option CPU throttling](https://user.oc-static.com/upload/2019/08/06/15650859455803_image20.gif)

### Observez les performances dans le dÃ©tail

Nous voilÃ  fin prÃªts Ã  commencer lâ€™inspection de nos animations ! Les performances de la page ne nous prÃ©occupent pas pour lâ€™instant, donc nous
pouvons immÃ©diatement appuyer sur le bouton **Record**. Quand on clique sur ce bouton Record, une fenÃªtre de dialogue apparaÃ®t pour nous informer
que lâ€™enregistrement du site a commencÃ©. Nous pouvons donc maintenant interagir avec notre bouton pour lancer les transitions. Une fois que les
animations sont terminÃ©es, on peut cliquer sur le bouton â€œStopâ€ dans la fenÃªtre de progression :

![Une vidÃ©o montrant l'analyse de l'animation](https://user.oc-static.com/upload/2019/08/06/15650860661535_pt02ch04-fall2.gif)

Et câ€™est tout ! DevTools prend un instant pour traiter les donnÃ©es recueillies, puis les affiche dans lâ€™onglet Performance.

DÃ©composons maintenant tout cela Ã©tape par Ã©tape.

![DÃ©tail de l'outil Performances des Devtools](https://user.oc-static.com/upload/2019/09/01/15673473741049_Capture%20d%E2%80%99e%CC%81cran%202019-09-01%20a%CC%80%2016.15.55.png)

Tout en haut, on trouve lâ€™avancement de lâ€™enregistrement, en millisecondes. Sur cette ligne, des graphiques verts suivent lesÂ FPS de notre site ;
les **plateaux** correspondent aux **Ã©vÃ©nements** dâ€™animation que nous allons dÃ©tailler dans un instant. Et juste sous cette ligne dâ€™avancement
se trouve une succession des images que DevTools a enregistrÃ©es.

Quand on passe la souris sur un des aperÃ§us, il sâ€™agrandit et nous montre exactement Ã  quoi ressemblait le site Ã  ce moment prÃ©cis :

![Une animation d'un bloc de texte cachÃ© derriÃ¨re un autre](https://user.oc-static.com/upload/2019/08/06/15650861771846_pt02ch04-fall3.gif)

Regardons notre animation de plus prÃ¨s en zoomant sur une des zones vertes. Pour cela, cliquez puis faites glisser votre souris sur la zone qui
vous intÃ©resse, ou bien utilisez la molette de la souris :

![L'animation analysÃ©e dans Devtools](https://user.oc-static.com/upload/2019/08/06/15650862998667_pt02ch04-fall4.gif)

Maintenant que nous sommes entrÃ©s dans les dÃ©tails de la partie animation de lâ€™enregistrement, concentrons-nous sur les cases vertes plus bas.
Elles correspondent aux images de notre animation. En passant la souris dessus, nous pouvons voir le temps de calcul de chaque image, et le
nombre deÂ FPSÂ :

![La calcul du FPS de l'animation](https://user.oc-static.com/upload/2021/02/15/161339026635_Gif091%20%282%29.gif)

On peut constater des changements assez faibles entre chaque image, ce qui est normal, mais globalement, chaque image est proche de notre
objectif de 60Â FPS : c'est parfait ! Nous pouvons donc affirmer avec certitude que nos transitions seront bien fluides, mÃªme sur un appareil six
fois plus lent que notre ordinateur.

### Passez vos images au crible

Allons voir ce qui se passe lorsque le navigateur calcule une image dans une animation. Pour cela, choisissez une image et zoomez au maximum.

![Le zoom pour mieux visualiser le moment de l'animation que l'on cherche](https://user.oc-static.com/upload/2021/02/15/16133901802579_Gif092%20%281%29.gif)

Maintenant que nous avons isolÃ© une image dans lâ€™animation, intÃ©ressons-nous Ã  la section â€œ**Main**â€ de lâ€™onglet Performance. Cette section
permet de voir tous les calculs qui ont transformÃ© notre code en une page web animÃ©e. Les calculs sont rÃ©partis en catÃ©gories identifiÃ©es par
des codes couleurs.

Les blocs violets reprÃ©sentent les calculs de base qui permettent lâ€™affichage dâ€™une page web, comme lâ€™analyse du CSS et le calcul des styles.

![ReprÃ©sentation des blocs violets](https://user.oc-static.com/upload/2019/08/06/15650867171194_image47.png)

Les blocs jaunes indiquent des calculs de l'Ã©tape layout, maisâ€¦ hourra, il nâ€™y en a pas ici ! Qu'est-ce que je vous avais dit ? ğŸ˜ GrÃ¢ce Ã  la
propriÃ©tÃ© `transform`, nous avons Ã©vitÃ© tout calcul de layout, bien trop gourmand en calcul, ce qui aurait dÃ©gradÃ© notre FPS.

Mais si notre image ne comporte pas de calculs de layout, elle comprend bien une case verte, qui reprÃ©sente un calcul de paint ou de composition.
En passant la souris dessus, nous voyons quâ€™il sâ€™agit bien dâ€™un calcul de composition. Notre animation nâ€™a pas non plus besoin de calculs de
paint :

![Calcul de paint ou de composition](https://user.oc-static.com/upload/2019/08/06/1565086815764_image44.png)

Plus besoin de me croire sur parole maintenant : vous le constatez par vous-mÃªme ! La propriÃ©tÃ© transform nous permet de crÃ©er des animations
abouties en Ã©vitant des calculs complexes pour notre navigateur. Et moins de calculs signifie plus dâ€™images par seconde, donc une meilleure
fluiditÃ© ! ğŸš€

### En rÃ©sumÃ©

- **Chrome DevTools** est l'outil de prÃ©dilection des dÃ©veloppeurs. Il permet d'**inspecter** le code source d'une page, d'**analyser** les
performances de notre page, de **brider** la performance de notre machine pour simuler un appareil plus lent. Pour cette derniÃ¨re option, activez
lâ€™option â€œCPU throttlingâ€ ;
- l'outil **Performance** permet d'analyser les performances dâ€™une page, notamment le taux dâ€™images par seconde dâ€™une animation ;
- on peut utiliser lâ€™onglet Performance pour analyser nos animations, ce qui permet de repÃ©rer les problÃ¨mes dans notre code qui pourraient
causer des problÃ¨mes de fluiditÃ© sur certains supports ;
- **zoomer** sur une image prÃ©cise dâ€™une animation permet de dÃ©tailler les calculs effectuÃ©s par le navigateur, que nous avions vus dans le
chapitre sur le fonctionnement du navigateur.

_Dans le chapitre suivant, nous aborderons enfin l'autre propriÃ©tÃ© dont nous disposons pour assurer un FPS optimal : opacity. Nous apprendrons Ã 
maÃ®triser cette propriÃ©tÃ© pour crÃ©er des animations en couleur sans dÃ©clencher de calcul de type paint dans le navigateur. Alors, Ã  tout de suite !_

-----

## Animez les couleurs de maniÃ¨re performante avec opacity

[Animez les couleurs de maniÃ¨re performante avec opacity - CrÃ©ez des animations CSS modernes - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/6340922-animez-les-couleurs-de-maniere-performante-avec-opacity)

<Vimeo vimeoId="508777316" />

<br />

La propriÃ©tÃ© `transform`Â permet de rÃ©pondre Ã  la plus grande partie de nos besoins en animation, mais possÃ¨de une lacune : la gestion de la
couleur.

Pourtant, la couleur dâ€™un Ã©lÃ©ment est un aspect fondamental de lâ€™animation. Alors comment faire ?

:::note ?
Est-ce que Ã§a veut dire quâ€™on doit laisser tomber lâ€™animation de couleur ? ğŸ˜±
:::

Pas de panique,Â la propriÃ©tÃ© `opacity`Â sera notre solution.

Pour cela, il nous faudra adopter une approche un peu diffÃ©rente dans la maniÃ¨re d'Ã©crire notre code.

Jusquâ€™ici, nous avons Ã©crit notre HTML structurellement, câ€™est-Ã -dire que chaque Ã©lÃ©ment fait partie intÃ©grante de notre layout.

Ici, nous allons devoir mettre la fonctionnalitÃ© en avant, en crÃ©ant des Ã©lÃ©ments non pas pour le layout, mais uniquement pour servir notre
animation.

Dans ce chapitre, nous allons voir comment organiser notre code pour crÃ©er des animations de couleurs en utilisant uniquement la propriÃ©tÃ©
opacity.

### Ã‰vitez le paint (attention peinture fraÃ®che)

Revenons sur notre bouton. Cette fois-ci, au survol de la souris, il change de couleur :

![Une animation CSS d'un bouton qui change de couleur](https://user.oc-static.com/upload/2021/02/18/16136589804856_Gif093.gif)

Ce type d'animation est parfait pour permettre Ã  lâ€™utilisateur de comprendre quâ€™il peut interagir avec cet Ã©lÃ©ment. Les changements de couleur
sont une composante essentielle de l'expÃ©rience utilisateur sur un site. Mais plutÃ´t que de faire changer la couleur instantanÃ©ment, lâ€™ajout
dâ€™une courte transition pourrait rendre lâ€™Ã©tat `:hover`Â un peu plus fluide et naturel.

Si on regarde le code, on peut constater que le bouton est un Ã©lÃ©ment `<button>`Â auquel est assignÃ©e la classe `.btn`Â :

```scss
<button class="btn">Survole moi!</button>
```

Et la variableÂ `$clr-btn`Â donne Ã  `.btn`Â une couleur dâ€™arriÃ¨re-plan `#15DEA5`.Â La pseudoclasse `:hover`Â permet d'assombrir le bouton de 5% en
utilisant la fonction Sass `darken()`Â :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    &:hover {
        background-color: darken($clr-btn, 5);
    }
}
```

Nous voulons animer la `background-color`Â de notre bouton. Pour cela, ajoutons une transition Ã  `.btn`, dâ€™une durÃ©e de 250 millisecondes :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    transition: background-color 250ms;
    &:hover {
        background-color: darken($clr-btn, 5);
    }
}
```

Notre bouton prend maintenant une couleur plus sombre quand la souris passe dessus :

![Animation CSS d'un bouton qui change de couleur](https://user.oc-static.com/upload/2021/02/18/16136589961294_Gif094.gif)

Parfait ! Mission accomplie, on peut passer Ã  autre chose. Sauf queâ€¦

![Une photo montrant l'analyse du bouton animÃ©](https://user.oc-static.com/upload/2019/08/06/15650923549747_image42.png)

Quelle horreur !!! Du paint !!! ğŸ˜±

Lâ€™animation de la propriÃ©tÃ© `background-color`Â dÃ©clenche un nouveau calcul de paint Ã  chaque image de la transition. Dans ce cas, il n'y a qu'une
seule propriÃ©tÃ© Ã  animer sur notre page. Les performances restent donc acceptables. Mais si notre animation Ã©tait plus complexe, nous aurions
sans aucun doute perdu nos 60 FPS. `background-color`Â nâ€™est donc pas la meilleure option pour animer des changements de couleur. La propriÃ©tÃ© Ã 
utiliser, câ€™est `opacity`.

La propriÃ©tÃ© `opacity`Â permet de modifier la transparence dâ€™un Ã©lÃ©ment et de ses enfants sur une Ã©chelle de 0 Ã  1, la valeur 0 reprÃ©sentant la
transparence totale, et la valeur 1 une opacitÃ© complÃ¨te.

:::note ?
Mais ce que je veux, c'est changer la couleur, pas le rendre transparent. Et lÃ  on utilise la propriÃ©tÃ© `opacity`Â ? Comment faire, alors ?
:::

Je vous ai parlÃ© plus tÃ´t de structurer notre code HTML pour servir la fonctionnalitÃ© dâ€™un Ã©lÃ©ment, plutÃ´t que de se concentrer sur le layout.
Vous vous rappelez ? Que dites-vous de structurer notre bouton de maniÃ¨re Ã  crÃ©er deux arriÃ¨re-plans empilÃ©s lâ€™un sur lâ€™autre ?

La couche du fond serait de la couleur normale, inactive, et la couche du dessus serait de la couleur plus sombre pour `:hover`. On pourrait
ensuite faire apparaÃ®tre et disparaÃ®tre la couche du haut en utilisant la propriÃ©tÃ© `opacity`, en crÃ©ant une animation entre les deux couleurs.

CommenÃ§ons par ajouter une `<div>`Â aprÃ¨s le texte du bouton de la `background-color`Â plus sombre, avec `opacity`Â Ã  0, et `opacity`Â sur 1 Ã  lâ€™Ã©tat
:hover. Le code HTML ressemblerait Ã  Ã§a :

```html
<button class="btn">
    Survole moi!
    <div class="btn__bg"></div>
</button>
```

et le CSS Ã  Ã§a :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        & .btn__bg {
            opacity: 1;
        }
    }
    &__bg {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

La `<div />`Â de la classe `.btn__bg`Â est en position absolute. Sa `background-color`Â est rÃ©glÃ©e sur une version plus sombre de `$clr-btn`.Â Nous
avons aussi ajoutÃ© un z-index deÂ -1, et un z-index de 1 Ã  `.btn`Â pour crÃ©er notre empilement.

Voyons voir si Ã§a fonctionne !

![Animation CSS d'un bouton qui change de couleur](https://user.oc-static.com/upload/2021/02/18/16136590106631_Gif095.gif)

Lâ€™effet est le mÃªme quâ€™en animant la couleur dâ€™arriÃ¨re-plan, tout en Ã©tant bien plus rapide Ã  calculer ! Eh oui, aucun travail de paint !

![RÃ©sultat de l'animation sans analyse de paint](https://user.oc-static.com/upload/2019/08/06/15650930342404_image29.png)

TrÃ¨s bien, cette fois-ci, la mission est accomplie, sans aucun calcul de paint.

Alors, vous avez rÃ©ussi ? On passe Ã  autre chose ?

On pourrait. Notre bouton change effectivement de couleur grÃ¢ce Ã  la propriÃ©tÃ© opacity qui assure une performance optimale de notre navigateur.
Câ€™Ã©tait notre objectif. Mais on peut toujours faire mieux !

Pour lâ€™instant, chaque bouton que nous ajoutons Ã  notre site nÃ©cessite dâ€™ajouter une `<div>`Â supplÃ©mentaire pour lâ€™arriÃ¨re-plan, ayant la classe
`.btn__bg`. Ce qui veut dire beaucoup de travail pour chaque bouton, et autant de risques de commettre une erreur.

### Exploitez la puissance du CSS

CrÃ©er une nouvelle div Ã  chaque fois que vous faites une animation de couleur sur un Ã©lÃ©mentâ€¦ meh, ce n'est pas fou. PlutÃ´t que de perdre votre
temps Ã  intÃ©grer la `div`Â dâ€™arriÃ¨re-plan Ã  chaque bouton, nous pouvons exploiter la puissance du CSS pour quâ€™il crÃ©e les Ã©lÃ©ments dâ€™arriÃ¨re-plan
Ã  notre place, comme par magie, grÃ¢ce aux pseudoÃ©lÃ©ments ! Plus spÃ©cifiquement le pseudoÃ©lÃ©mentÂ `::after`.

:::note ?
Mais bien sÃ»r ! Enfin... câ€™est quoi, un pseudoÃ©lÃ©ment ?
:::

CommenÃ§ons par Ã©tudier son nom : le prÃ©fixe "pseudo" dÃ©signe un Ã©lÃ©ment qui ressemble Ã  une chose mais en est en fait une autre (Ã§a vous dit
quelque chose ?). Un pseudoÃ©lÃ©ment ressemble donc Ã  un Ã©lÃ©ment, comme une `<div>`Â Ã©crite Ã  la main dans le code HTML, mais câ€™est en fait un
Ã©lÃ©ment gÃ©nÃ©rÃ© par le CSS et interprÃ©tÃ© dans la page web.Â  Et on peut le styliser de la mÃªme maniÃ¨re.

Il existe plusieurs types de pseudoÃ©lÃ©ments, mais pour lâ€™instant nous nâ€™allons parler que de `::after`, et de son frÃ¨re `::before`.

:::info
Vous pouvez consulter un rÃ©capitulatif complet des pseudoÃ©lÃ©ments disponibles en CSS3, et leur utilisation,Â **[dans la documentation sur MDN](https://developer.mozilla.org/fr/docs/Web/CSS/Pseudo-elements)**.
:::

Lâ€™ajout des Ã©lÃ©ments `::before`Â ou `::after`Â crÃ©e un Ã©lÃ©ment enfant Ã  chaque fois que son sÃ©lecteur a Ã©tÃ© assignÃ©. Lâ€™Ã©lÃ©ment crÃ©Ã© par `::before`
sera le premier enfant de lâ€™Ã©lÃ©ment, et celui crÃ©Ã© par `::after`Â sera le dernier. Pour notre bouton, lâ€™Ã©lÃ©ment de background vient aprÃ¨s le texte,
donc le pseudoÃ©lÃ©ment `::after`Â serait parfait pour remplacer notre `<div>`Â dâ€™arriÃ¨re-plan.

La crÃ©ation dâ€™un pseudoÃ©lÃ©ment est identique Ã  celle dâ€™une pseudoclasse : on ajoute le pseudoÃ©lÃ©ment Ã  un sÃ©lecteur, mais au lieu dâ€™utiliser
comme prÃ©fixe les deux points ( : ), un pseudoÃ©lÃ©ment en utilise deux ( :: ) :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        & .btn__bg {
            opacity: 1;
        }
    }
    &::after {
        // attribuez des valeurs de style au pseudo sÃ©lecteur ::after ici
    }
    &__bg {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

En CSS2, les pseudoÃ©lÃ©ments Ã©taient crÃ©Ã©s avec un signe deux-points unique, comme les pseudosÃ©lecteurs, ce qui nâ€™Ã©tait pas trÃ¨s clair. Pour aider
Ã  les distinguer, CSS3 a modifiÃ© la syntaxe des pseudoÃ©lÃ©ments avec le prÃ©fixe double deux-points. Si vous tombez sur du CSS contenantÂ `:before`
ouÂ `:after`, câ€™est gÃ©nÃ©ralement le signe quâ€™il sâ€™agit dâ€™une vieille base de code.

Nous pouvons alors lui assigner du style. Nous voulons queÂ `::after`Â ait la mÃªme apparence que `.btn__bg`. Alors copions le style de `.btn__bg`
dans le pseudoÃ©lÃ©ment `::after`, avant de supprimer le sÃ©lecteur `.btn__bg`, dont nous nâ€™aurons plus besoin :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        & .btn__bg {
            opacity: 1;
        }
    }
    &::after {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

Notre pseudoÃ©lÃ©ment `::after`Â a maintenant le style qu'on voulait, mais passer la souris sur le bouton nâ€™a pas encore dâ€™effet parce que la
pseudoclasse `:hover`Â du bouton sÃ©lectionne toujours avec `.btn__bg` pour changer sonÂ `opacity`Â Ã Â 1. Nous allons donc le mettre Ã  jour pour
quâ€™il utilise plutÃ´t le pseudoÃ©lÃ©ment `::after`Â :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        &::after {
            opacity: 1;
        }
    }
    &::after {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: \-1;
        transition: opacity 250ms;
    }
}
```

Notre bouton nâ€™aura plus besoin de la `<div>`Â dâ€™arriÃ¨re-plan, donc tant quâ€™Ã  faire, retirons-la aussi :

```html
<button class="btn">
    Survole moi!
</button>
```

Et maintenant, aprÃ¨s avoir actualisÃ© la page, quand nous interagissons avec le bouton, il devrait bien rÃ©agir comme avant :

![Bouton qui ne change pas de couleur au hover](https://user.oc-static.com/upload/2021/02/18/16136590272364_Gif096.gif)

Argh ! ZÃ©ro changement de couleur ! Ouvrons DevTools pour inspecter notre bouton :

![Le code inspectÃ©](https://user.oc-static.com/upload/2019/08/06/15650942922045_image26.png)

Nous devrions voir un Ã©lÃ©ment `::after` lÃ  oÃ¹ se trouvait notre `<div>`Â dâ€™arriÃ¨re-planâ€¦ mais il nâ€™y a rien. ğŸ˜¤

### MaÃ®trisez la particularitÃ© des pseudoÃ©lÃ©ments

Bon, c'est peut-Ãªtre de ma fauteâ€¦ Vous vous rappelez quand jâ€™ai dit :

> Comme un pseudoÃ©lÃ©ment reste un Ã©lÃ©ment, on peut le styliser de la mÃªme maniÃ¨re.

Je vous ai Ã  moitiÃ© menti, car ce nâ€™Ã©tait pas complÃ¨tement vraiâ€¦ ğŸ™ˆ

Pour ma dÃ©fense, câ€™Ã©tait vrai Ã  99,9 %â€¦Â mais les pseudoÃ©lÃ©ments nÃ©cessitent une propriÃ©tÃ© dont les Ã©lÃ©ments normaux nâ€™ont pas besoin. Pour un
Ã©lÃ©ment normal, on code son contenu en Ã©crivant la page. Mais comme `::after`Â injecte un Ã©lÃ©ment dans la page aprÃ¨s coup, le CSS doit dire au
navigateur ce que cet Ã©lÃ©ment contient. Câ€™est lÃ  que la propriÃ©tÃ©Â **`content`** entre en jeu. Elle est **indispensable au fonctionnement des
pseudoÃ©lÃ©ments.** (Prenez gaaaaarde Ã  la propriÃ©tÃ© content, elle en a rendu plus dâ€™un complÃ¨tement fou, ne tombez pas dans son piÃ¨Ã¨Ã¨ge ğŸ‘¿).

La propriÃ©tÃ© `content`Â nous permet de remplir un pseudoÃ©lÃ©ment de texte ou dâ€™images, mais dans le cas de notre bouton, nous ne voulons pas y
ajouter de contenu. Nous voulons plutÃ´t que `::after`Â agisse comme un fond de couleur. Pourtant, il est indispensable dâ€™assigner une valeur au
pseudoÃ©lÃ©ment. Essayons donc de lui assigner une chaÃ®ne de caractÃ¨res vides en utilisant des guillemets vides :

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        &::after {
            opacity: 1;
        }
    }
    &::after {
        content: "";
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: darken($clr-btn, 5);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

Inspectons maintenant le code de notre bouton pour voir comment il se comporte. Câ€™est mieux ! Si on jette un Å“il Ã  DevTools, on peut voir que
lâ€™Ã©lÃ©ment `::after`Â se trouve bien lÃ  oÃ¹ on avait une `<div>` :

![Le code inspectÃ©](https://user.oc-static.com/upload/2019/08/06/15650946116753_image28.png)

Alors, vous avez rÃ©ussi ?

Si jamais vous avez envie de vous arracher les cheveux parce que vos pseudoÃ©lÃ©ments nâ€™apparaissent pas sur votre page, vÃ©rifiez en premier que
vous leur avez attribuÃ© une propriÃ©tÃ© `content`. Personnellement, Ã§a mâ€™arrive encore de devenir Ã  moitiÃ© folle avant de me rendre compte que
jâ€™ai oubliÃ© dâ€™ajouter la propriÃ©tÃ© content Ã  mes pseudoÃ©lÃ©ments.

### DÃ©couvrez les dÃ©gradÃ©s

Lâ€™animation par la propriÃ©tÃ© `opacity`Â nâ€™est pas limitÃ©e aux changements de couleur. On peut aussi animer des dÃ©gradÃ©s au lieu de couleurs unies :
**![Animation de l'opacity gradient](https://user.oc-static.com/upload/2021/02/09/16128925803024_Gif097.gif)**.

Vous pouvez d'ailleurs retrouver le code source de ce bouton dansÂ [ce CodePen](https://codepen.io/atoulmet/pen/OJLjGvV).

_Essayez de modifier le dÃ©gradÃ© du bouton ğŸ™‚_

Pour cela, il faut crÃ©er un dÃ©gradÃ© pour la `background-color` du pseudoÃ©lÃ©ment `::after`, et non une couleur unie.

```scss
$border-rad: 2rem;
$clr-btn: #15DEA5;
.btn {
    border-radius: $border-rad;
    background-color: $clr-btn;
    position: relative;
    z-index: 1;
    &:hover {
        &::after {
            opacity: 1;
        }
    }
    &::after {
        content: "";
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background: radial-gradient(circle, lighten($clr-btn, 5) 0%, darken($clr-btn, 10) 100%);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
```

On peut aussi crÃ©er des couches de couleurs sur des images :

![une image avec gradient hover opacity](https://user.oc-static.com/upload/2021/02/09/16128926002097_Gif098.gif)

```scss
$border-rad: 2rem;
$clr-primary: #15DEA5;
@mixin peudo-pos {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
.btn {
    border-radius: $border-rad;
    background-color: $clr-primary;
    position: relative;
    z-index: 1;
    &:hover {
        &::after {
            opacity: 1;
        }
        & + .img {
            &::before {
                opacity: 0;
            }
        }
    }
    &::after {
        @include pseudo-elem;
        background: radial-gradient(circle, lighten($clr-primary, 5) 0%, darken($clr-primary, 10) 100%);
        opacity: 0;
        z-index: -1;
        transition: opacity 250ms;
    }
}
.img {
    z-index: -1;
    &::before {
        @include pseudo-elem;
        border-radius: $border-rad;
        background: $clr-primary;
        z-index: 1;
    }
}
```

Pas mal hein ? Vous avez essayÃ© ?

La morale de cette histoire, câ€™est que la propriÃ©tÃ© `opacity`Â permet de faire des transitions de couleur sans que le navigateur fasse des calculs
de type â€œpaintâ€. La performance reste donc optimale, et nous permet donc de garder notre objectif de 60 FPS. Pour cela, les pseudoÃ©lÃ©ments nous
Ã©vitent dâ€™Ã©crire un code HTML rÃ©pÃ©titif, dans lequel on aurait dÃ» insÃ©rer de vÃ©ritables Ã©lÃ©ments supplÃ©mentaires.Â Plus pratique et plus propre,
que demander de plus ?

### En rÃ©sumÃ©

- animer la couleur dâ€™une propriÃ©tÃ© dÃ©clenche des **calculs** de paint ;
- la propriÃ©tÃ© `opacity`Â nous permet de faire des transitions entre des couleurs en Ã©vitant ces calculs ;
- la propriÃ©tÃ© `opacity`Â reÃ§oit une valeur entre 0 et 1, 0 Ã©tant complÃ¨tement transparent et 1 complÃ¨tement opaque ;
- pour Ã©viter dâ€™avoir Ã  ajouter des `<div>`Â supplÃ©mentaires, que l'on aurait dÃ» ajouter Ã  chaque fois dans le HTML, on peut utiliser le
pseudoÃ©lÃ©ment `::before`Â ou `::after`Â ;
- pour crÃ©er un pseudoÃ©lÃ©ment, ajoutez le nom du pseudoÃ©lÃ©ment Ã  un sÃ©lecteur, en utilisant le prÃ©fixe double deux-points : `.selector::after{...}`
- les pseudo-Ã©lÃ©ments `::before`Â et `::after`Â crÃ©ent un Ã©lÃ©ment qui est respectivement le premier ou le dernier enfant de lâ€™Ã©lÃ©ment sÃ©lectionnÃ© ;Â 
- il est possible de crÃ©er des dÃ©gradÃ©s de couleur. Il suffit d'attribuer un dÃ©gradÃ© au background-color de l'Ã©lÃ©ment d'arriÃ¨re-plan. On fera
ensuite disparaÃ®tre l'Ã©lÃ©ment superposÃ© avec opacity: 0.

_Nous voilÃ  dÃ©jÃ  Ã  la fin de la deuxiÃ¨me partie ! FÃ©licitations Ã  vous ğŸ‰ ! Vous allez maintenant pouvoir vous exercer sur le deuxiÃ¨me quizÂ du
cours. Une foisÂ le quiz terminÃ©, nous passerons Ã  la partie 3, oÃ¹ nous verrons enfin les keyframes. J'ai hÃ¢te !_

-----

## Quiz : RÃ©alisez des translations, des rotations et modifier l'opacitÃ© de vos animations

[RÃ©alisez des translations, des rotations et modifier l'opacitÃ© de vos animations - OpenClassrooms](https://openclassrooms.com/fr/courses/5919246-creez-des-animations-css-modernes/exercises/3601)

#### CompÃ©tences Ã©valuÃ©es

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> MaÃ®triser les translations, les rotations et lâ€™opacitÃ©

-----

#### Description

Bienvenue dans le deuxiÃ¨meÂ quiz de ce cours.<br />
Cette fois-ci, c'est vous qui allez coder. Il est nÃ©cessaire de cloner le [repository GitHub](https://github.com/atoulmet/openclassrooms_css-animations)
correspondant Ã  ce cours pour rÃ©pondre aux six premiÃ¨res questions. VÃ©rifiez le fichier README.md pour obtenir quelques instructions
supplÃ©mentaires sur comment le faire tourner.

Dans les quatre questions suivantes, nous testerons votre comprÃ©hension gÃ©nÃ©rale des points abordÃ©sÂ dans la partie 2 de ce cours.

Alors, c'est parti ! ğŸš€


#### Question 1 : Dans le repository, une ligne a Ã©tÃ© commentÃ©e pour animer la premiÃ¨re carte. DÃ©commentez cette ligne de code. Quelle propriÃ©tÃ© a Ã©tÃ© animÃ©e ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> <code>rotate()</code><br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> <code>width</code><br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> <code>transform</code><br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> <code>transition</code><br />
<br />

_Il aurait pu Ãªtre tentant de choisir la premiÃ¨re rÃ©ponse. La flashcard dÃ©crit effectivement une rotation. Mais rotate n'est pas une propriÃ©tÃ© :
il s'agit d'une fonction de la propriÃ©tÃ© transform. La propriÃ©tÃ© width n'a quant Ã  elle pas du tout Ã©tÃ© animÃ©e. Au contraire, je vous dÃ©conseille
d'utiliser cette propriÃ©tÃ© pour crÃ©er vos animations, puisqu'elle n'est pas du tout performante. La propriÃ©tÃ© transition permet de dÃ©crire la
durÃ©e, la courbe d'accÃ©lÃ©ration, le dÃ©lai, etc. Mais ce n'est pas une propriÃ©tÃ© animÃ©e._

-----

#### Question 2 : Lequel de ces snippets nous donne uneÂ animation permettant de faire apparaÃ®tre la dÃ©finition du deuxiÃ¨me principe de maniÃ¨re fluide ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.principal-2 {
    .btn:active + .card > .card__front {
        transform: scale(0);
        transform: rotate(-190deg);
        transition: 0.5s ease-in-out;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.principal-2 {
    & .btn:active + .card > .card__front {
        transform: scale(0);
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.principal-2 {
    & .btn:active + .card > .card_front {
        transform: opacity(0);
        transition-duration: 0.5s;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
.principal-2 {
    .btn:active + .card > .card__front {
        opacity: 0;
        transform: rotate(60deg) scale(0);
        transition: 0.5s ease-in-out;
    }
}
```

*Dans le choix numÃ©ro 1, la deuxiÃ¨me propriÃ©tÃ© transform, transform: rotate(-190deg),Â vient annuler la premiÃ¨re dÃ©claration de transform qui
prÃ©cisait scale(0). Le dessus de la carte pivote bien mais ne disparaÃ®t pas, ce qui ne nous permet pas de voir la dÃ©finition.*

*Le deuxiÃ¨me snippet, quant Ã  lui ne prÃ©voit pas de transition : la dÃ©finition apparaÃ®t bien, mais pas d'animation ici.*

*Dans le troisiÃ¨me choix, il y a une toute petite erreur : au lieu de .card__front, on a ici .card_front, par ailleurs, opacity ne fait pas
partie de transform(). l'animation ne peut donc pas se lancer.*

*C'est bien la solution 4 qui permet de lancer notre animation.*

-----

#### Question 3 : Laquelle de ces animations correspond Ã  ce snippet de code ?

```scss
.principal-3 {
    .btn:active + .card > .card__front {
        transform: scale(2);
        opacity: 0;
        transition: all ease-in-out 0.5s;
    }
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

![pt02-quiz-q3-r1](https://user.oc-static.com/upload/2019/09/01/15673370875301_ezgif.com-optimize%20%2813%29.gif)

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

![pt02-quiz-q3-r2](https://user.oc-static.com/upload/2019/09/01/15673371075752_ezgif.com-optimize%20%2814%29.gif)

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

![pt02-quiz-q3-r3](https://user.oc-static.com/upload/2019/09/01/15673371255855_ezgif.com-video-to-gif%20%2816%29.gif)

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

![pt02-quiz-q3-r4](https://user.oc-static.com/upload/2019/09/01/15673371381181_ezgif.com-optimize%20%2815%29.gif)

*Il s'agit de l'animation numÃ©ro 2 !*

*En effet, l'animation numÃ©ro 1 ne grandit pas assez pour correspondre Ã  ce snippet : ici elle effectue une transformation de translate(1.2).*

*L'animation numÃ©ro 3, quant Ã  elle, ne peut pas correspondre : elle s'Ã©tend sur la droite alors que la propriÃ©tÃ© transform-origin n'a pas Ã©tÃ©
manipulÃ©e. Et enfin, l'animation 4 ne disparaÃ®t pas totalement Ã  la fin, et sa duration est bien trop lente.*

-----

#### Question 4 : Je veux crÃ©er une animation oÃ¹ la carte disparaÃ®t tout en se dÃ©calant de 300 pixels sur la droite, et en rÃ©duisant son Ã©chelle. Dans mon sÃ©lecteur `.principal-4`, je pensais avoir ce qu'il me fallait, mais Ã§a ne marche pas. Qu'est-ce qui pose problÃ¨me ici ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Ma transition est trop rapide : je n'ai pas le temps de voir l'effet.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Il n'est pas possible de prÃ©ciser plusieurs fois <code>transform</code>Â au sein d'un mÃªme sÃ©lecteur, ou les effets prÃ©cÃ©dents seront Ã©crasÃ©s par la derniÃ¨re dÃ©claration.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Ce n'est pas possible de crÃ©er une animation sur 3 propriÃ©tÃ©s diffÃ©rentes.<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Il n'est pas possible d'animer les propriÃ©tÃ©sÂ <code>transform</code> et <code>opacity</code> dans une mÃªmeÂ animation.<br />
<br />

*Avec une durÃ©e de 300ms, aucun souci de durÃ©e de transition ici : c'est largement suffisant pour voir un effet. Par ailleurs, il est Ã©galement
possible de crÃ©er une animation sur autant de propriÃ©tÃ©s que l'on souhaite, pas de limite Ã  ce niveau-lÃ . De la mÃªme maniÃ¨re, il est tout Ã  fait
possible d'animer `opacity`Â ET `transform`. C'est donc bien la dÃ©claration de `transform`Â qui pose problÃ¨me. ğŸ™ˆ*

-----

#### Question 5 : Je veux reproduire cette animation.

![pt02-quiz-q5](https://user.oc-static.com/upload/2019/09/01/15673376246868_ezgif.com-optimize%20%2816%29.gif)

**Quel snippet de code me permet d'y parvenir ?**

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.btn:active + .card > .card__front {
    transform: rotate(180deg);
    opacity: 0;
    transition: transform ease-in-out 0.5s, opacity ease-in-out 0.2s 0.2s;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.card > .card__front {
    transform-origin: top right;
}
.btn:active + .card > .card__front {
    transform-origin: top right;
    transform: rotate(180deg);
    opacity: 0;
    transition: transform ease-in-out 0.5s, opacity ease-in-out 0.2s 0.2s;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>

```scss
.card > .card__front {
    transform-origin: 20px 20px;
}
.btn:active + .card > .card__front {
    transform: rotate(180deg);
    opacity: 0;
    transition: all ease-in-out 1s;
}
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg>

```scss
.btn:active + .card > .card__front {
    transform-origin: top right;
    transform: rotate(180deg);
    opacity: 0;
    transition: all ease-in-out 0.2s 0.2s;
}
```

*Ici, la propriÃ©tÃ© `transform-origin`Â est essentielle. Or, elle n'est pas prÃ©sente dans le premier snippet. Ce n'est pas la bonne solution.*

*Le deuxiÃ¨me choix, quant Ã  lui, part d'un `transform-origin`Â du mauvais cÃ´tÃ© : alors que sur mon animation le carrÃ© bascule vers la gauche, la
propriÃ©tÃ© est dÃ©finie Ã  right ici.*

*Le quatriÃ¨me extrait de code prÃ©cise bien `transform-origin: top right;`, mais il le fait directement dans la pseudoclasse `:active`, ce qui ne
donne pas l'effet souhaitÃ©.*

*C'est bien le troisiÃ¨me snippet qui permet d'obtenir cette animation.*

-----

#### Question 6 : Dans le repository, une animation a Ã©tÃ© crÃ©Ã©e pour le 6e principe, Slow in and Slow out. Comme nous l'avons vu dans le chapitre "Analysez la performance de vos animations avec Chrome DevTools", ouvrez l'outil Performance des DevTools pour creuser un peu cette animation. Zoomez au maximum pour voir les Ã©tapes qui ont Ã©tÃ© dÃ©clenchÃ©es pour le calcul de notre animation. Quelles sont ces Ã©tapes ?

*Attention, plusieurs rÃ©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Paint<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Layout<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg> Composition (Composite)<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg> Flex<br />
<br />

*Cette animation modifie les propriÃ©tÃ©s de transform, opacity, mais Ã©galement background-color et width/height. Elle dÃ©clenche donc des opÃ©rations
de Layout, Paint et Composition. Mon animation n'est donc pas vraiment performante ici : si je veux au maximum limiter les calculs de mon
navigateur, je dois m'en tenir aux propriÃ©tÃ©s qui dÃ©clenchent des calculs de Composition. Pour cela, je dois privilÃ©gier transform et opacity.
Pour ce qui est de flex, rien Ã  voir : il s'agit d'une valeur de display qui permet de faire des mises en page CSS.*

-----

#### Question 7 : Quel est le FPS optimal Ã  respecter pour obtenir des animations CSS aussi fluides que possible ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> 60 FPS<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 16 FPS<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> 100Â FPS<br />
<br />

*Pour crÃ©er des animations aussi fluides que possible, le FPS optimal est de 60 FPS. En effet, la plupart des Ã©crans modernes ont une vitesse de
rafraÃ®chissement des images Ã  60 hz, ou 60 fois par seconde. Si notre animation a un FPS de 100, l'utilisateur verra malgrÃ© tout une animation Ã 
60 FPS car il sera limitÃ© par les capacitÃ©s de son Ã©cran. Ã€ l'inverse, 16 FPS est beaucoup trop faible et donne vraiment une impression saccadÃ©e.
Pourtant, si le nombre 16 vous semble familier, c'est aussi parce qu'il s'agit de la durÃ©e maximale pour calculer une image d'une animation si
l'on veut respecter le FPS optimal de 60 FPS. N'hÃ©sitez pas Ã  jeter un Å“il au chapitre _Optimisez les performances de votre navigateur_ pour vos
animations CSS, si vous avez un doute ğŸ˜‰*

-----

#### Question 8 : Quels snippets de code permettent d'obtenir une animation sur l'opacitÃ© et sur transform, avec une transition de 300 millisecondes, une courbe d'accÃ©lÃ©ration ease et un dÃ©lai 200 millisecondes ?

*Attention, plusieurs rÃ©ponses sont possibles.*

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
transition: all 0.3s 0.2s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
transition: all 0.3s ease 0.2s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>

```scss
transition: all 0.2s ease 0.3s;
```

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-checkbox" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="9 11 12 14 20 6" />
  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />
</svg>

```scss
transition-duration: 0.3s;
transition-delay: 0.2s
transition-property: all;
transition-timing-function: ease;
```

*Souvenez-vous : la propriÃ©tÃ© transition est une propriÃ©tÃ© raccourcie pour les propriÃ©tÃ©s [transition-property](https://developer.mozilla.org/fr/docs/Web/CSS/transition-property),
[transition-duration](https://developer.mozilla.org/fr/docs/Web/CSS/transition-duration), [transition-timing-function](https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function)
et [transition-delay](https://developer.mozilla.org/fr/docs/Web/CSS/transition-delay), dans cet ordre prÃ©cis.*

*Le choix 1 ne prÃ©cise pas la valeur ease comme fonction de timing, mais comme il s'agit de la valeur par dÃ©faut, le premier snippet convient
bien. Le choix numÃ©ro 2 Ã©galement.*

*Le choix numÃ©ro 3 inverse durÃ©e et dÃ©lai de transition, il ne respecte donc pas les critÃ¨res recherchÃ©s. Et le choix numÃ©ro 4 correspond Ã  la
version dÃ©taillÃ©e de nos propriÃ©tÃ©s. Vous avez le choix de prÃ©ciser des valeurs pour vos propriÃ©tÃ©s CSS une par une comme dans le choix 4, ou
avec la propriÃ©tÃ© transition. Mais vous verrez le plus souvent la propriÃ©tÃ© raccourcie ; je vous conseille donc de l'utiliser pour vous y
habituer.*

-----

#### Question 9 : Qu'est-ce qu'il ne faut surtout pas oublier pour afficher un pseudo-Ã©lÃ©ment `:before`Â ou `:after`Â ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> PrÃ©ciser une width<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> display: block;<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> PrÃ©ciser un content<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> z-index: 1<br />
<br />

*Les pseudoÃ©lÃ©ments sont un peu particuliers. Contrairement Ã  un Ã©lÃ©mentÂ HTML traditionnel, il n'est pas nÃ©cessaire qu'il ait une width ou une
height pour qu'il s'affiche. En revanche, il est indispensable de prÃ©ciser la propriÃ©tÃ© content, mÃªme s'il s'agit d'une chaÃ®ne de caractÃ¨res vide.
Souvenez-vous-en bien, car cette petite particularitÃ© risque de vous rendre fou en cas d'oubli ğŸ™ƒ.*

-----

#### Question 10 : Le navigateur suit plusieurs Ã©tapes pour rendre une page web. Selon la propriÃ©tÃ© appliquÃ©e, une animation dÃ©clenche diffÃ©rentes Ã©tapes de rendu par le navigateur. Quelle est la derniÃ¨re Ã©tape qui est la moins gourmande en puissance de calcul, et doit donc Ãªtre privilÃ©giÃ©e pour vos animations CSS ?

<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Paint<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Layout<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
</svg> Styles<br />
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="22" height="22" viewBox="0 0 24 24" stroke-width="1.5" stroke="#7bc62d" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg> Composition<br />
<br />

*Dans l'ordre, les Ã©tapes que le navigateur suit sont les suivantes :*
1. _**Style** : le navigateur va crÃ©er la structureÂ HTML qui s'affichera._
2. _**Layout** (mise en page) : maintenant que le navigateur connaÃ®t les styles et les Ã©lÃ©ments Ã  afficher, il dÃ©termine la taille des Ã©lÃ©ments
et oÃ¹ les placer._
3. _**Paint** (peinture) : le navigateur transforme les Ã©lÃ©ments en pixels en utilisant les styles de lâ€™Ã©tape 1, et les positions et dimensions
dÃ©duites de lâ€™Ã©tape 2._
4. _**Composition** : le navigateur combine tous les Ã©lÃ©ments pour composer la page qui sâ€™affiche dans le navigateur._

*C'est la derniÃ¨re Ã©tape qui est la moins gourmande en puissance de calcul, donc Composition, Ã  privilÃ©gier pour vos animations. Vous pouvez
retrouver Ã  quelle Ã©tape correspond la propriÃ©tÃ© que vous animez sur le site [**csstriggers.com**](http://csstriggers.com/) (en anglais).*
