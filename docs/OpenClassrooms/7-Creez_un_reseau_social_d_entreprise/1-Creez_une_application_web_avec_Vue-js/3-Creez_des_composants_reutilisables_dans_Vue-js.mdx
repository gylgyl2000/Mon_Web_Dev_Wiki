---
sidebar_position: 4
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# CrÃ©ez des composants rÃ©utilisables dans Vue.js

## GÃ©rez les styles de votre application

[GÃ©rez les styles de votre application - CrÃ©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6864346-gerez-les-styles-de-votre-application)

![](https://user.oc-static.com/upload/2020/05/20/15899592715233_Bannee-dimension-720-798-03.png)

Nous l'avons vu prÃ©cÃ©demment, Vue est facile d'utilisation. Et c'est notamment dÃ» Ã  l'amÃ©lioration continue. Si vous ne souhaitez pas travailler
avec un outil, pas de problÃ¨me ; en revanche, le jour oÃ¹ vous en aurez besoin, sa configuration sera trÃ¨s simple ! Et c'est encore plus pratique
si vous souhaitez ajouter du style Ã  votre application, c'est-Ã -dire gÃ©rer le CSS de votre application.

### Configurez un prÃ©processeur

Actuellement,Â lorsqu'il s'agit d'Ã©crire du CSS, la plupart des codebases frontend utilisent un **prÃ©processeur** (comme Sass, LESS, etc.).

:::info
Les prÃ©processeursÂ permettent d'Ã©tendre les fonctionnalitÃ©s CSS comme les opÃ©rateurs, les fonctions, les mixins, et bien d'autres choses.
:::

Et pour utiliser des prÃ©processeurs, les styles sont gÃ©nÃ©ralement Ã©crits dans un format de fichier spÃ©cifique :
- Sass â‡’ *.sass ou *.scss
- LESS â‡’ *.less

Pour tirer parti de la puissance des prÃ©processeurs, tout en les maintenant couplÃ©s Ã  votre composant, vous pouvez utiliser la prop **lang**.

AprÃ¨s avoirÂ configurÃ© votre application Vue CLI avec le bon prÃ©processeur (comme nous l'avions fait dans la partie prÃ©cÃ©dente), ilÂ suffit de
passer la prop **lang** au bloc de style. Assurez-vous de bien mettre le prÃ©processeur souhaitÃ©, iciÂ `scss`.

```html
<template>
...
</template>
<script>
...
</script>
<style lang="scss">
.button {
    &.is-small { ... }
    &.is-large { ... }
}
</style>
```

Maintenant, vous avez le pouvoir des prÃ©processeurs CSS entre vos mains. âš¡ï¸ğŸ’ª

### GÃ©rez le CSS

Un grand pouvoir implique de grandes responsabilitÃ©s. Pour comprendre comment gÃ©rer votre CSS, il faut comprendre de quelle faÃ§onÂ `style`Â est
compilÃ© en production.

#### GÃ©rez le style global par dÃ©faut

Lorsque `style`Â ne comporte aucune configuration additionnelle, les styles sont appliquÃ©s de maniÃ¨re gÃ©nÃ©rale, Ã  chaque fois que le composant
est rendu.

Donc, si notre composant ressemble Ã  ce qui suit :

```html
<template>
    <main>
        <h1>Bonjour</h1>
        <button>Cliquez ici!</button>
    </main>
</template>
<script>
export default {
    name: 'HomePage'
}
</script>
<style>
button {
    background-color: blue;
}
</style>
```

...l'HTMLÂ correspondantÂ devrait ressembler Ã  cela :

```html
<html>
    <head>
        <style>
            button {
                background-color: blue;
            }
        </style>
    </head>
<body>
    <main>
        <h1>Bonjour</h1>
        <button> Cliquez ici !</button>
    </main>
</body>
</html>
```

:::info
Cela peut sembler Ã©trange puisque la plupart des modÃ¨les traditionnels intÃ¨grent un fichier .css au lieu d'incruster le bloc de style, mais
c'est en fait trÃ¨s efficace. Cela garantit en effet que les utilisateurs ne reÃ§oivent que la CSS dont ils ont besoin, au lieu de tÃ©lÃ©charger du
code superflu, qui ne sera jamais utilisÃ©.
:::

#### Utilisez des styles dÃ©limitÃ©s

La technique des styles dÃ©limitÃ©s (_scopedÂ styles_) est devenue populaire rÃ©cemment. Elle permet de fournir un attribut `scoped` au bloc de
style, afin que le CSS ne s'applique qu'aux Ã©lÃ©ments du composant courant. Pour ce faire, un attribut `data`Â personnalisÃ© est ajoutÃ© Ã  la
classe CSS et Ã  l'Ã©lÃ©ment HTML, afin que les styles restent Â« scopÃ©s Â», donc dÃ©limitÃ©s. GrÃ¢ce Ã  cela, les effets de cascade sont minimisÃ©s en
limitant leur pÃ©rimÃ¨tre d'action.

Cependant, cela n'empÃªchera pas les styles plus spÃ©cifiques de prendre le dessus si quelqu'un Ã©crit des sÃ©lecteurs gÃ©nÃ©riques plus spÃ©cifiques.
Il est donc trÃ¨s important d'utiliser de bonnes techniques d'architecture CSS !

##### Avant le build

```html
<style scoped>
.example {
    color: red;
}
</style>
<template>
    <div class="exemple">hello !</div>
</template>
```

##### AprÃ¨s le build

```html
<style>
.example[data-v-f3f3eg9] {
    color: red;
}
</style>
<template>
    <div class="exemple" data-v-f3f3eg9>hello !</div>
</template>
```

#### Ajoutez des modules CSS

Bien que la technique desÂ **scopedÂ styles**Â puisse Ãªtre efficaceÂ pour certains cas, l'un de ses principaux inconvÃ©nientsÂ vientÂ duÂ fait qu'elle
peutÂ Ãªtre affectÃ©e par des styles prÃ©sentant une plus grande spÃ©cificitÃ©. Ce n'est gÃ©nÃ©ralement pas un problÃ¨me important pour la plupart des
styles, mais cela peut devenir problÃ©matique lorsque des CSS tierces s'ajoutent et que des Ã©lÃ©ments comme `.button`Â sont courants.

Les modules CSS sont apprÃ©ciÃ©s pour les possibilitÃ©s deÂ modularitÃ© et de composition de CSS offertes, comme illustrÃ© ci-dessous :

```html
<style module>
.red {
    color: red;
}
.bold {
    font-weight: bold;
}
</style>
```

Comme pour lesÂ **styles dÃ©limitÃ©s**, vous n'avez qu'Ã  ajouter un attribut `module`Â Ã Â `<style>`Â et il ajoutera vos styles avec un hash alÃ©atoire
par dÃ©faut.

```html
<style>
.red-vj29193 {
    color: red;
}
.bold-vj2914 {
    font-weight: bold;
}
</style>
```

Cependant, l'utilisation des modules CSS nÃ©cessite d'ajouter la classe CSS avec le style `$`Â dans une classe `v-bind:class`.

```html
<template>
    <h1 :class="$style.red">Mon titre en rouge</h1>
</template>
<style module>
.red {
    color: red;
}
</style>
```

MÃªme s'il faut s'habituer Ã  la syntaxe, les avantages des modules CSS l'emportent souvent sur le temps nÃ©cessaire Ã  l'intÃ©gration de la nouvelle
faÃ§on d'Ã©crire les classes. Cependant, si vous ou votre Ã©quipe n'avez pas besoin de modules CSS, vous n'avez pas Ã  vous soucier du tout de
cette nouvelle syntaxe.

### DÃ©couvrez des stratÃ©gies pour gÃ©rer les styles de votre application

#### Maintenez vos styles couplÃ©s Ã  votre composant

En gardantÂ vos styles au bas niveau, vous vous assurezÂ que les futurs dÃ©veloppeursÂ connaÃ®tront le contexte dans lequel le style a Ã©tÃ© crÃ©Ã©.
Cela vous Ã©viteÂ de passer un tempsÂ considÃ©rable Ã  essayer de crÃ©er un design system ultra perfectionnÃ©. L'avantage, c'est que cela permet
d'amÃ©liorer la maintenabilitÃ© Ã  long terme de votre application, tout en tirant parti du dÃ©coupage du code fourni par Vue.

Par exemple, en langage CSS traditionnel, vous pourriez Ã©crire les styles de votre bouton comme suit :

##### style.css

```css
.button {
    background-color: blue;
    color: white;
    border-radius: 10px;
}
```

Cependant, mÃªme s'il ne s'agit que d'une seule classe CSS, imaginez ce qui se passerait s'il y avait encore plus de styles. Cela signifie que
les utilisateurs tÃ©lÃ©chargeraient toutes ces donnÃ©es, qu'ils utilisent les styles ou non. De plus, cela ne simplifie pas les choses lorsque
l'on travaille avec du code existant, car il est difficile de refactoriser sans connaÃ®tre les effetsÂ de bord possibles.

En revanche, si nous gÃ©rions nos styles avec Vue...

**src/components/CustomButton.vue**

```javascript
<template>
    <button class="button">{{ text }}</button>
</template>
<script>
export default {
    name: 'CustomButton',
    props: ['text']
}
</script>
<style>
.button {
    background-color: blue;
    color: white;
    border-radius: 10px;
}
</style>
```

N'importe quel dÃ©veloppeur peut comprendre avec facilitÃ© la faÃ§on dont le code est liÃ©, les effetsÂ de bord ne constituent plus vraiment un
sujet de prÃ©occupation.Â C'est pratique, n'est-ce pas ?

#### Ne gÃ©nÃ©ralisez les styles que lorsque vous avez un cas de rÃ©utilisation

IlÂ peut Ãªtre tentant de tester et de s'en tenir aux mÃ©thodes traditionnelles de CSS, en mettant tous les styles dans un fichier CSS partagÃ©.
Mais ce n'est pas forcÃ©ment une bonne idÃ©e. ğŸ˜‘ En effet, ce fichier ne peut pas Ãªtre parsÃ© de maniÃ¨re intelligente lorsque l'utilisateur visite
une page. Donc, Ã  moins que vous ne voyiez un grand nombre de rÃ©utilisations de styles Ã  traversÂ diffÃ©rents composants, ma recommandation
gÃ©nÃ©rale est de ne pas les extraire dans un fichier CSS gÃ©nÃ©rique, mais de s'en tenir au style composant par composant.

### EntraÃ®nez-vous

Vous trouverez le code source des exercices dans [le repo GitHub du cours](https://github.com/amandinelemoult2109/Vue-fr) dans le dossier
`cafe-with-a-view`. Pour commencer, consultez la branche `P3C1-Begin`.

#### Instructions

1. Migrez tous les styles des sites statiques `styles.css` dans les fichiers des composants respectifs.
2. Utilisez votre prÃ©processeur prÃ©fÃ©rÃ© si vous le souhaitez !

```css title="public/styles.css"
.description {
  max-width: 960px;
  font-size: 1.2rem;
  margin: 0 auto;
}

.footer {
  text-align: center;
  font-style: italic;
}

.menu {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.menu-item {
  display: flex;
  width: 500px;
  justify-content: space-between;
  margin-bottom: 30px;
}

.menu-item__image {
  max-width: 300px;
}

.shopping-cart {
  position: absolute;
  right: 30px;
  top: 0;
}
```

```html title="views/Home.vue"
...
<style lang="scss">
.description {
	max-width: 960px;
	font-size: 1.2rem;
	margin: 0 auto;
}

.footer {
	font-style: italic;
	text-align: center;
}

.menu {
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
}

.shopping-cart {
	position: absolute;
	right: 30px;
	top: 0;
}
</style>
```

```html title="components/MenuItem.vue"
...
<style lang="scss">
.menu-item {
	display: flex;
	width: 500px;
	justify-content: space-between;
	margin-bottom: 30px;

	&__image {
		max-width: 300px;
	}
}
</style>
```

### En rÃ©sumÃ©

Dans ce chapitre, vous avez dÃ©couvert :
- l'utilisation de prÃ©processeurs dans un composant monofichier ;
- les stratÃ©gies de gestion des styles avec les scoped styles ;
- les stratÃ©gies de gestion des styles avec les CSS Modules ;
- les stratÃ©gies de gestion des styles au fur et Ã  mesure que vous crÃ©ez des composants.

_Dans le chapitre suivant, nous nous pencherons encore davantage sur la faÃ§on dont les composants peuvent communiquer entre eux._

-----

## Passez des datas entre les composants

[Passez des datas entre les composants - CrÃ©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6864701-passez-des-datas-entre-les-composants)

![](https://user.oc-static.com/upload/2020/05/20/15899595489163_Bannee-dimension-720-798-03.png)

Dans les chapitres prÃ©cÃ©dents,Â vousÂ avez appris Ã  utiliser les props pour passer des donnÃ©es vers un composant. Cependant, cela n'Ã©tait qu'une
utilisation basique des props. Que se passerait-il si nous voulions Ãªtre plus explicites sur le type de donnÃ©es qui doivent Ãªtre passÃ©es ? Et
si nous voulions nous assurer que la prop est passÃ©e en continu pour que notre composant bÃ©nÃ©ficie des propriÃ©tÃ©s dont il a besoin ?Â Jetons un
Å“il Ã  tout Ã§a. ğŸ‘€

<Vimeo vimeoId="413529792" />

<br />

### DÃ©finissez des props en tant qu'objets

DÃ©finir les props comme un simple tableau de chaÃ®nes de caractÃ¨resÂ a l'avantage d'ÃªtreÂ facile Ã  lire et Ã  comprendre. Mais Ã§a manque justement
de complexitÃ©. Or, nous avons besoin de complexitÃ© pour nous assurer que nos props fonctionnent comme nous le souhaitons, peu importe qui
utilise la prop.

Par exemple, dans le code ci-dessous, vous remarquerez que le composant prend trois props diffÃ©rentes :
- list ;
- title ;
- count.

```html
<template>
    <div>
        <h1>{{ title }} #{{ count }}</h1>
        <ul>
            <li v-for="item in list" :key="item">{{ item }}</li>
        </ul>
    </div>
</template>
<script>
export default {
    props: ['list', 'title', 'count']
}
</script>
```

Cependant, ces props ont des exigences spÃ©cifiques, ce qui pose problÃ¨me. Par exemple, `title`Â devrait Ãªtre une `string`Â maisÂ `list`Â devrait
possÃ©der un comportementÂ itÃ©ratif, comme un `array` ou un `object`. PlutÃ´t que d'espÃ©rer que ce soient bien les bonnes donnÃ©es qui sont passÃ©es,
en croisant les doigts, ce serait quand mÃªme bien mieux de pouvoir empÃªcher le mauvais type de donnÃ©es de passer. Eh bien, c'est possible en
dÃ©finissant les props Ã  l'aide d'un objet au lieu d'un tableau de chaÃ®nes de caractÃ¨res.

```html
<template>
    <div>
        <h1>{{ title }} #{{ count }}</h1>
        <ul>
            <li v-for="item in list" :key="item">{{ item }}</li>
        </ul>
    </div>
</template>
<script>
export default {
    props: {
        list: {},
        title: {},
        count: {}
    }
}
</script>
```

Ici,Â la valeur deÂ `props`Â estÂ un objet. Les propriÃ©tÃ©s de cet objet correspondent Ã  chacune des props que vous souhaitez utiliser. Pour cela,
Ã  chaque fois, une clÃ© correspondant au nom de la prop (par exemple, `list`) Ã  laquelle est associÃ©e un objet servira Ã  dÃ©finir la configuration
de l'objet.

Comme je vous l'ai dit, nous voulons Ã©viter de recevoir le mauvais type de donnÃ©es dans chaque prop. Il faut donc commencer par configurer le
type de prop attendu avec la clÃ© `type`Â qui prend comme valeur un type de donnÃ©es JavaScript.

```html
<template>
    <div>
        <h1>{{ title }} #{{ count }}</h1>
        <ul>
            <li v-for="item in list" :key="item">{{ item }}</li>
        </ul>
    </div>
</template>
<script>
export default {
    props: {
        list: {
            type: Array
        },
        title: {
            type: String
        },
        count: {
            type: Number
        }
    }
}
</script>
```

:::info
Pour avoir une liste complÃ¨te des diffÃ©rents types de props, consultez [la documentation officielle](https://fr.vuejs.org/v2/guide/components-props.html).
:::

Par ailleurs, si notre composant a besoin de certaines props pour fonctionner ou avoir l'apparence souhaitÃ©e, ce seraitÂ gÃ©nialÂ de pouvoir le
configurer. Vous vous en doutez, si je vous dis Ã§a, c'est que Vue rend cela possible. ğŸ˜ Il suffit d'ajouterÂ la clÃ©Â `required`Â qui prend un
boolÃ©en en valeur dans notre objet de configuration.

```html
<template>
    <div>
        <h1>{{ title }} #{{ count }}</h1>
        <ul>
            <li v-for="item in list" :key="item">{{ item }}</li>
        </ul>
    </div>
</template>
<script>
export default {
    props: {
        list: {
            type: Array
        },
        title: {
            type: String,
            required: true
        },
        count: {
            type: Number
        }
    }
}
</script>
```

:::info
Par dÃ©faut, la valeur deÂ `required`Â est `false`.
:::

Cet objet nous permet mÃªmeÂ deÂ dÃ©finir une valeur par dÃ©faut sur les propriÃ©tÃ©s afin de fournir un contenu par dÃ©faut, dans le cas oÃ¹ la prop
n'est jamais dÃ©finie. Pour cela, il vous suffit de prÃ©ciser la clÃ©Â `default`Â et de lui associer la valeur souhaitÃ©e selon vos besoins. Dans
notre exemple, cela pourrait ressembler Ã  ce qui suit :

```html
<template>
    <div>
        <h1>{{ title }} #{{ count }}</h1>
        <ul>
            <li v-for="item in list" :key="item">{{ item }}</li>
        </ul>
    </div>
</template>
<script>
export default {
    props: {
        list: {
            type: Array,
            default: () => []
        },
        title: {
            type: String,
            required: true
        },
        count: {
            type: Number,
            default: 1
        }
    }
}
</script>
```

:::info
Vous avez peut-Ãªtre remarquÃ© que `Array`Â a une valeur par dÃ©faut qui utilise une fonction anonyme pour retourner un tableau vide. Nous ne
l'aborderons pas dans ce cours, mais sachez que les valeurs par dÃ©faut des `Arrays`Â et des `Objects` doivent Ãªtre retournÃ©es par une fonction
pour que cela fonctionne correctement.
:::

### EntraÃ®nez-vous

Vous trouverez le code source des exercices dans [le repo GitHub du cours](https://github.com/amandinelemoult2109/Vue-fr) dans le dossier
`cafe-with-a-view`. Pour commencer, consultez la branche `P3C2-Begin`.

#### Instructions

Utilisez la syntaxe en objet pour dÃ©finir les propriÃ©tÃ©s associÃ©es Ã Â `props`Â dans `MenuItem.vue`.

```html title="components/MenuItem.vue"
<script>
export default {
	name: "MenuItem",
	props: ["addToShoppingCart", "image", "inStock", "name", "price", "quantity"],
...
</script>
```

```html title="components/MenuItem.vue"
<script>
export default {
	name: "MenuItem",
	props: {
		addToShoppingCart: {
			type: Function,
			required: true
		},
		image: {
			type: Object,
			required: true
		},
		inStock: {
			type: Boolean,
			required: true
		},
		name: {
			type: String,
			required: true
		},
		price: {
			type: Number,
			required: true
		},
		quantity: {
			type: Number,
			defaut: 1
		}
	},
...
</script>
```

### En rÃ©sumÃ©

Dans ce chapitre, vous avez acquis les connaissances pour :
- dÃ©finir des props Ã  l'aide d'un objet ;
- dÃ©finir des types de prop pour minimiser les bugs potentiels ;
- utiliser la propÂ `required` ;
- dÃ©finir une valeur par dÃ©faut sur une prop.

_Cependant, bien que les props soient parfaites pour passer des informations du composant parent Ã  l'enfant, elles ne fonctionnent pas dans
l'autre sens. En d'autres termes, comment communiquer l'information du composant enfant au composant parent ? Nous allons Ã©tudier une faÃ§on de
rÃ©aliser cette opÃ©ration dans le prochain chapitre !_

-----

## Ã‰mettez des Ã©vÃ©nements vers des composants parents

[Ã‰mettez des Ã©vÃ©nements vers des composants parents - CrÃ©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6864936-emettez-des-evenements-vers-des-composants-parents)

![](https://user.oc-static.com/upload/2020/05/20/15899595857555_Bannee-dimension-720-798-03.png)

Nous avons beaucoup appris sur la faÃ§on de communiquer depuis les composants parents vers les composants enfants, mais qu'en est-il de la
communication vers les parents ? ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ La maniÃ¨re la plus courante est d'Ã©mettre des Ã©vÃ©nements personnalisÃ©s.

### RÃ©visezÂ lesÂ Ã©vÃ©nements

En dÃ©veloppement web, les [Ã©vÃ©nements](https://developer.mozilla.org/fr/docs/Apprendre/JavaScript/Building_blocks/Ev%C3%A8nements) sont des
actions ou des occurrences qui se produisent pendant l'utilisation d'un site web. Voici des exemples courants d'Ã©vÃ©nements :
- lorsqu'un utilisateur clique sur un Ã©lÃ©ment ;
- lorsqu'un utilisateur appuie sur une touche du clavier ;
- lorsqu'un formulaire est soumis ;
- lorsque laÂ fenÃªtre d'un navigateur est redimensionnÃ©e.

Lorsque ces actions se produisent, des Ã©vÃ©nements sont **Ã©mis** afin que nous puissions y rÃ©pondre en utilisant des techniques comme les
gestionnaires d'Ã©vÃ©nements. UnÂ **objet Ã©vÃ©nement**Â (_event-object_) est alors automatiquement passÃ© aux Ã©vÃ©nements. Il contiendraÂ des
fonctionnalitÃ©s supplÃ©mentaires ou des informations sur l'Ã©vÃ©nement.Â Par exemple, lorsqu'un utilisateur appuie sur une touche du clavier,
l'objet Ã©vÃ©nement peut nous indiquer quelle touche a Ã©tÃ© actionnÃ©e.

### CrÃ©ez un Ã©vÃ©nement personnalisÃ©

Dans le monde du frontend, la gestion des Ã©vÃ©nements estÂ rÃ©pandue. Comme nous l'avons vu prÃ©cÃ©demment avec la directive `v-on`, nous pouvons
facilement Ã©couter des Ã©vÃ©nements courants et dÃ©clencher des fonctions Ã  volontÃ©. Cependant, ce serait bien pratique de pouvoir dÃ©finir nos
propres Ã©vÃ©nements personnalisÃ©s faisant l'objet d'une Ã©mission, non ? Heureusement, c'est trÃ¨s facile Ã  rÃ©aliser avec la fonctionnalitÃ©
intÃ©grÃ©e `$emit`Â de Vue. Voyons cela en action ! ğŸ”

<Vimeo vimeoId="413529920" />

<br />

#### Utilisez $emit

La fonction `$emit`Â prend deux paramÃ¨tres :
- le nom de l'Ã©vÃ©nement (qui doit Ãªtre dÃ©fini en _kebab-case_) ;
- un payload optionnel que vous pouvez utiliser pour passer des donnÃ©es Ã  l'Ã©couteur de l'Ã©vÃ©nement.

##### src/ChildComponent.vue

```html
<template>
    <button @click="emitCustomEvent">Emit Event</button>
</template>
<script>
export default {
    methods: {
        emitCustomEvent() {
            this.$emit('custom-event-name', { message: 'Mon message personnalisÃ©' })
        }
    }
}
</script>
```

:::info
Le payload est gÃ©nÃ©ralement dÃ©fini comme un objet. Cela permet de passer autant de propriÃ©tÃ©s que souhaitÃ© Ã  travers un seul Ã©vÃ©nement.
:::

#### Ã‰coutez et rÃ©pondez Ã  un Ã©vÃ©nement Ã©mis

Une fois qu'un Ã©vÃ©nement est Ã©mis, le composant parent qui utilise le composant enfant est capable d'Ã©couter l'Ã©vÃ©nement via la directive
`v-on`.Â Pour cela, vous devez :
1. Ajouter un Ã©couteur d'Ã©vÃ©nement (_listener_)Â `v-on` avec le nom de l'Ã©vÃ©nement personnalisÃ© sur le composant Ã©mettant l'Ã©vÃ©nement.
2. Lui assigner une mÃ©thode recevant le payload comme premier argument s'il existe.

##### src/ParentComponent.vue

```html
<template>
    <div>
        <p>{{ message }}</p>
        <!-- Ã‰coute les Ã©vÃ©nements personnalisÃ©s et y assigne une mÃ©thode -->
        <ChildComponent @custom-event-name="setMessage" />
    </div>
</template>
<script>
import ChildComponent from './ChildComponent'
export default {
    components: { ChildComponent },
    data () {
        return {
            message: 'Hello'
        }
    },
    methods: {
        // DÃ©finit la mÃ©thode utilisÃ©e par le payload pour mettre Ã  jour la propriÃ©tÃ© data
        setMessage(payload) {
            this.message = payload.message
        }
    }
}
</script>
```

:::caution
Attention cependant : cette technique ne fonctionne que lorsqu'on communique directement depuis un composant enfant vers un composant parent.
En d'autres termes, ne vous attendez pas Ã  ce que votre Ã©vÃ©nement soit Ã©mis dans l'ensemble de l'application.
:::

### EntraÃ®nez-vous

Vous trouverez le code source des exercices dans [le repo GitHub du cours](https://github.com/amandinelemoult2109/Vue-fr) dans le dossier
`cafe-with-a-view`. Pour commencer, consultez la branche `P3C3-Begin`.

#### Instructions

1. Supprimez la propÂ `addToShoppingCart`Â du `MenuItem`.
2. CrÃ©ez une nouvelle mÃ©thode appelÃ©e `updateShoppingCart`Â dans `MenuItem`Â qui Ã©met un Ã©vÃ©nement appelÃ© `add-items-to-cart`Â Ã  `Home.vue`Â pour
mettre Ã  jour le panier.

```html {5-8} title="components/MenuItem.vue"
<script>
export default {
	name: "MenuItem",
	props: {
		addToShoppingCart: {
			type: Function,
			required: true
		},
		image: {
			type: Object,
			required: true
		},
		inStock: {
			type: Boolean,
			required: true
		},
		name: {
			type: String,
			required: true
		},
		price: {
			type: Number,
			required: true
		},
		quantity: {
			type: Number,
			defaut: 1
		}
	},
	data() {
		return {
			onSale: false
		}
	},
	computed: {
		generatedPrice() {
			if (this.onSale) {
				return (this.price * 0.9).toFixed(2)
			} else {
				return this.price
			}
		}
	},
	beforeMount() {
		const today = new Date().getDate()

		if (today % 2 === 0) {
			this.onSale = true
		}
	}
}
</script>
```

```html {40-44} title="components/MenuItem.vue"
<script>
export default {
	name: "MenuItem",
	props: {
		image: {
			type: Object,
			required: true
		},
		inStock: {
			type: Boolean,
			required: true
		},
		name: {
			type: String,
			required: true
		},
		price: {
			type: Number,
			required: true
		},
		quantity: {
			type: Number,
			defaut: 1
		}
	},
	data() {
		return {
			onSale: false
		}
	},
	computed: {
		generatedPrice() {
			if (this.onSale) {
				return (this.price * 0.9).toFixed(2)
			} else {
				return this.price
			}
		}
	},
	methods: {
		updateShoppingCart(quantity) {
			this.$emit("add-items-to-cart", quantity)
		}
	},
	beforeMount() {
		const today = new Date().getDate()

		if (today % 2 === 0) {
			this.onSale = true
		}
	}
}
</script>
```

### En rÃ©sumÃ©

Dans ce chapitre, vous avez appris Ã  :
- dÃ©finir des Ã©vÃ©nements personnalisÃ©s dans les composants ;
- Ã©mettre des Ã©vÃ©nements personnalisÃ©s Ã  partir de composants enfants ;
- Ã©couter des Ã©vÃ©nements personnalisÃ©s Ã  partir de composants enfants ;
- utiliser le payload des Ã©vÃ©nements personnalisÃ©s pour effectuer des actions supplÃ©mentaires.

_Dans la leÃ§on suivante, nous Ã©tudierons une nouvelle technique pour passer des donnÃ©es aux composants : les slots. Alors, on se retrouve au
prochain chapitre. ğŸ‘‹_

-----

## CrÃ©ez des composants flexibles en utilisant les slots

[CrÃ©ez des composants flexibles en utilisant les slots - CrÃ©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6865121-creez-des-composants-flexibles-en-utilisant-les-slots)

![](https://user.oc-static.com/upload/2020/05/20/15899597714554_Bannee-dimension-720-798-03.png)

MÃªme si les props sontÂ trÃ¨s puissantes, elles ajoutent un niveau de complexitÃ© dans l'interaction avec un composant, puisqu'elles demandent
un certain niveau de connaissance afin d'utiliser le composant de maniÃ¨re adÃ©quate. De plus, on peut facilement se retrouver au milieu d'un
Â«Â bazar de props Â» lorsqu'un composant a besoin de plusieurs props pour fonctionner correctement.

```html
<custom-banner size="small" left-icon="info" text="Hello" />
```

Dans le cas oÃ¹ votre composant nÃ©cessiterait une solution plus flexible, Vue peut vous aider avec la technique des `slots`.

<Vimeo vimeoId="413530010" />

<br />

### DÃ©couvrez les slots

L'Ã©lÃ©ment `<slot>`Â sert d'emplacement pour du contenu que le dÃ©veloppeur peut dÃ©finir dynamiquement sans props prÃ©dÃ©terminÃ©es.Â 

Prenons un exemple. Ã€ l'aide du composant `custom-banner`, nous voulons que les utilisateurs puissent dÃ©finir diffÃ©rentes banniÃ¨res
personnalisÃ©es. L'idÃ©e ici est justement d'Ã©viter notre bazar de props. Par exemple, imaginons que nous voulions que notre composant
`CustomBanners`Â rende le rÃ©sultat suivantÂ  :

```html
<div class="small">
    <p><icon name="info" /> BanniÃ¨re d'information</p>
</div>
<div class="small">
    <p><icon name="warning" />BanniÃ¨re de warning<icon name="warning" /></p>
</div>
```

Si cela avait Ã©tÃ© rÃ©alisÃ© uniquement avec des props, le rÃ©sultat pourrait ressembler Ã  ceci :

```html
<custom-banner
    size="small"
    left-icon="info"
    text="BanniÃ¨re information"
/>
<custom-banner
    size="small"
    left-icon="warning"
    text="BanniÃ¨re attention"
    right-icon="warning"
/>
```

Plus important encore, le bloc Template du composant `CustomBanner`Â ressemblerait Ã  ceci :

##### src/components/CustomBanner.vue

```html
<template>
    <div :class="size">
        <p><icon v-if="leftIcon" :name="leftIcon" /> {{ text }} <icon v-if="rightIcon" :name="rightIcon" /></p>
    </div>
</template>
```

MÃªme dans cet exemple simple, le bloc Template semble dÃ©jÃ  assez difficile Ã  lire. Alors que si on avait utilisÃ© des slots...

##### src/components/CustomBanner.vue

```html
<template>
    <div :class="size">
        <slot></slot>
    </div>
</template>
```

Et voilÃ  ! Comme vous pouvez le voir, le slot devient un espace ouvert oÃ¹ le dÃ©veloppeur peut passer n'importe quel contenu personnalisÃ©,
sans avoir besoin d'utiliser un grand nombre de conditions pour gÃ©rer diffÃ©rents scÃ©narios de props.

#### DÃ©finissez le contenu par dÃ©faut d'un slot

De la mÃªme faÃ§on qu'il est possible de dÃ©finir une valeur par dÃ©faut pour les props, vous pouvez Ã©galement dÃ©finir le contenu par dÃ©faut d'un
slot. C'est particuliÃ¨rement utile lorsque vous souhaitez afficher un contenu standard, Ã  moins que le dÃ©veloppeur ne dÃ©finisse un contenu
personnalisÃ©.

Pour donner un contenu par dÃ©faut Ã  notre `CustomBanner`, tout ce que nous avons Ã  faire est de placer le contenu par dÃ©faut Ã  l'intÃ©rieur des
balises `slot`Â dans le bloc Template.

```html
<template>
    <div :class="size">
        <slot>Bonjour !</slot>
    </div>
</template>
```

### DÃ©couvrez comment utiliser plusieurs slots

Vous vous demandez peut-Ãªtre aussi : Â« Et si je veux utiliser plusieurs slots dans un composantÂ ?Â Â» Et ce serait une excellente question ! ğŸ•µï¸â€â™€ï¸ğŸ•µï¸â€â™‚ï¸
Prenons l'exemple d'un simple composant `Card`Â :

```html
<template>
    <div class="card">
        <h2>Titre de la carte</h2>
        <p>Texte de la carte</p>
        <button>Action</button>
    </div>
</template>
```

Dans ce composant, nous utilisons des props pour effectuer la configuration, mais nous savons que ce sera un cauchemar Ã  gÃ©rer s'il s'agrandit.
Ici, trois slots diffÃ©rentsÂ pourraient Ãªtre dÃ©finis par un dÃ©veloppeur. Pour rÃ©soudre ce problÃ¨me, nous avons besoin de **slots nommÃ©s**.

Les slots nommÃ©s permettent d'attribuer des noms aux slots afin que les dÃ©veloppeurs puissent s'y rÃ©fÃ©rer plus tard. Ainsi, dans l'instance de
notre composant `Card`, nous donnons simplement une prop `name`Â Ã  chaque slot.

```html
<template>
    <div class="card">
        <slot name="title">Titre de la carte</slot>
        <slot name="text">Texte de la carte</slot>
        <slot name="action">Action</slot>
    </div>
</template>
```

Lorsque nous voulons invoquer notre composant (Ã  partir de la v2.6 de Vue.js et plus), il suffit d'utiliser la directive `v-slot`Â sur un
Ã©lÃ©ment `template` comme ici :

```html
<template>
    <Card>
        <template v-slot:title>
            <h3>Donner des noms aux slots est utile</h3>
        </template>
        <template v-slot:text>
            <p>Maintenant, on peut ajouter ce que l'on veut ici en donnant le nom du slot !</p>
        </template>
        <template v-slot:action>
            <a href="#">En savoir plus</a>
        </template>
    </Card>
</template>
```

### EntraÃ®nez-vous

Vous trouverez le code source des exercices dans [le repo GitHub du cours](https://github.com/amandinelemoult2109/Vue-fr) dans le dossier
`cafe-with-a-view`. Pour commencer, consultez la branche `P3C4-Begin`.

#### Instructions

Refactorez le composant `BaseButton`Â en utilisant des slots plutÃ´t que les props qui sont dÃ©finies pour le moment.

```html {4,10} title="components/BaseButton.vue"
<script>
export default {
    name: 'BaseButton',
    props: ['text']
}
</script>

<template>
    <button v-on="$listeners">
        {{ text }}
    </button>
</template>
```

```html {9} title="components/BaseButton.vue"
<script>
export default {
    name: 'BaseButton'
}
</script>

<template>
    <button v-on="$listeners">
        <slot></slot>
    </button>
</template>
```

```html {15-18} title="components/MenuItem.vue"
<template>
	<div class="menu-item">
		<img class="menu-item__image" :src="image.source" :alt="image.alt" />
		<div>
			<h3>{{ name }}</h3>
			<p>
				Prix : {{ generatedPrice }}
				<span v-if="onSale">(10% de rÃ©duction !)</span>
			</p>
			<p v-if="inStock">En stock</p>
			<p v-else>En rupture de stock</p>
			<div>
				<label for="add-item-quantity">QuantitÃ© : {{ quantity }}</label>
				<input v-model.number="quantity" id="add-item-quantity" type="number" />
				<BaseButton
					@click="updateShoppingCart(quantity)"
					text="Ajouter au panier"
				/>
			</div>
		</div>
	</div>
</template>
```

```html {15-17} title="components/MenuItem.vue"
<template>
	<div class="menu-item">
		<img class="menu-item__image" :src="image.source" :alt="image.alt" />
		<div>
			<h3>{{ name }}</h3>
			<p>
				Prix : {{ generatedPrice }}
				<span v-if="onSale">(10% de rÃ©duction !)</span>
			</p>
			<p v-if="inStock">En stock</p>
			<p v-else>En rupture de stock</p>
			<div>
				<label for="add-item-quantity">QuantitÃ© : {{ quantity }}</label>
				<input v-model.number="quantity" id="add-item-quantity" type="number" />
				<BaseButton @click="updateShoppingCart(quantity)">
					Ajouter au panier
				</BaseButton>
			</div>
		</div>
	</div>
</template>
```

### En rÃ©sumÃ©

Dans ce chapitre, vous avez dÃ©couvert :
- les difficultÃ©sÂ induite par le bazar de props ;
- la dÃ©finition de slots sur des composants ;
- la dÃ©finition de contenu par dÃ©faut dans les slots ;
- l'utilisation de slots nommÃ©s pour gÃ©rer plusieurs slots.

_Rendez-vous dans le prochain chapitre pour passer en revue ce que nous avons appris dans cette partie du cours ! ğŸš€_

-----

## RÃ©sumÃ© de la partie 3

[RÃ©sumÃ© de la partie 3 - CrÃ©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6865311-resume-de-la-partie-3)

![](https://user.oc-static.com/upload/2020/05/20/15899597875573_Bannee-dimension-720-798-03.png)

Nous avons abordÃ© de nombreux concepts essentiels, fÃ©licitations Ã  vous ! ğŸ’ª

Vous Ãªtes maintenant plus que capable de crÃ©er des applications robustes avec Vue.jsÂ !Â Ensemble, nous avons appris Ã  :
- tirer parti des diffÃ©rentes **stratÃ©gies CSS pour gÃ©rer les styles** ;
- concevoir des composants rÃ©utilisables avec une **architecture basÃ©e sur les composants** ;
- utiliser des techniques comme les **props** et les **slots** pour communiquer des donnÃ©es aux composants enfantsÂ ;
- **Ã©mettre des Ã©vÃ©nements** Ã  partir de composants enfants pour communiquer avec les composants parents.

La prochaine partie du cours aborde un concept intermÃ©diaire, recommandÃ© si vous souhaitez en savoir plus sur la maniÃ¨re de gÃ©rer les donnÃ©es
pour une application plus consÃ©quente, comme pourrait l'Ãªtre une application en prod d'une entreprise. Cependant, et j'insiste sur ce point,
vous avez dÃ©jÃ  Ã  ce stade tout ce qu'il vous faut pour Ãªtre un dÃ©veloppeur Vue.js productif et crÃ©er de superbes applications Web !
FÃ©licitations pour tout le travail accompli !

-----

## Quiz : CrÃ©ez des composants rÃ©utilisables avec Vue.js

[CrÃ©ez des composants rÃ©utilisables avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/exercises/3849)

#### CompÃ©tences Ã©valuÃ©es

<i class="bi bi-check2-circle"></i> CrÃ©er des composants rÃ©utilisables dans Vue.js

-----

#### Question 1 : Si vous souhaitez passer des donnÃ©es Ã  un composant enfant, quelle technique devez-vous utiliser ?

<i class="bi bi-circle"></i> PropriÃ©tÃ©s calculÃ©es<br />
<i class="bi bi-circle"></i> Methods<br />
<i class="bi bi-record-circle"></i> Props<br />
<i class="bi bi-circle"></i> Data store<br />
<br />

_Les props sont des attributs personnalisÃ©s que vous pouvez enregistrer dans un composant afin qu'il puisse accÃ©der Ã  ces donnÃ©es. Pour plus
d'informations, vous pouvez consulter [la documentation sur les props](https://fr.vuejs.org/v2/guide/components.html)._

-----

#### Question 2 : Il y a actuellement un bug dans notre application. Comme vous le voyez ci-dessous, un composant affiche diffÃ©rents types de donnÃ©es dans le message, tels que des arrays et des objets.

```html
<template>
    <p>{{ message }}</p>
</template>
<script>
export default {
    props: ['message']
}
</script>
```

**Quel est le meilleur moyen d'Ã©viter ce genre de problÃ¨me ?**

<i class="bi bi-circle"></i> DÃ©finir la propriÃ©tÃ© <code>required</code> dans la prop.<br />
<i class="bi bi-record-circle"></i> DÃ©finir le type de propriÃ©tÃ© avec une valeur <code>String</code>.<br />
<i class="bi bi-circle"></i> DÃ©finir une propriÃ©tÃ© <code>default</code> dans la prop.<br />
<i class="bi bi-circle"></i> DÃ©finir un nom de prop personnalisÃ© qui indique aux autres dÃ©veloppeurs de n'utiliser que des chaÃ®nes de
caractÃ¨res.<br />
<br />

_En dÃ©finissant leÂ `type`Â Ã Â `String`Â pourÂ la prop, cela permettra Ã  Vue de protÃ©ger la prop contre la rÃ©ception d'autres types de donnÃ©es, ce
qui empÃªchera le bug de se produire._

-----

#### Question 3 : Un dÃ©veloppeur essaie d'utiliser les techniques SCSS dans le bloc de code ci-dessous.

```html
<template>
    <div class="form-wrapper">
        <label class="form-label">Nom du formulaire</label>
        <input class="form-input" type="text" />
    </div>
</template>
<style>
.form {
    &-wrapper { margin: 25px 0; }
    &-label { font-size: 1.2rem; }
    &-input { padding: 10px 5px; }
}
</style>
```

**Quâ€™a-t-il mal fait ?**

<i class="bi bi-circle"></i> Il doit ajouter l'attribut <code>scss</code> au bloc <code>&#60;style></code>.<br />
<i class="bi bi-record-circle"></i> Il doit ajouter l'attribut <code>lang="scss"</code> au bloc <code>&#60;style></code>.<br />
<i class="bi bi-circle"></i> Il doit envelopper les styles dans un bloc <code>&#60;scss></code>.<br />
<i class="bi bi-circle"></i> Il doit ajouter l'attribut <code>preprocessor="scss"</code> au bloc <code>&#60;style></code>.<br />
<br />

_Les prÃ©processeurs peuvent Ãªtre activÃ©s en ajoutant l'attribut `lang`Â avec le prÃ©processeur souhaitÃ©._

-----

#### Question 4 : Quelle mÃ©thode a permis deÂ gÃ©nÃ©rer le CSS suivant ?

```css
.nav-item[data-12vr93] { ... }
```

<i class="bi bi-circle"></i> Global CSS<br />
<i class="bi bi-record-circle"></i> Scoped CSS<br />
<i class="bi bi-circle"></i> CSS Modules<br />
<br />

_Le Scoped CSS est une technique qui a Ã©tÃ© crÃ©Ã©e pour Ã©viter la collision des sÃ©lecteurs CSS grÃ¢ce Ã  l'utilisation d'attributsÂ data gÃ©nÃ©rÃ©s de
maniÃ¨re dynamique._

-----

#### Question 5 : Lorsqu'un composant enfant doit transmettre des donnÃ©es Ã  son parent, quelle techniqueÂ est-il possible d'utiliser ?

<i class="bi bi-circle"></i> Les props<br />
<i class="bi bi-record-circle"></i> Les Ã©vÃ©nements personnalisÃ©s<br />
<i class="bi bi-circle"></i> Les slots<br />
<i class="bi bi-circle"></i> Les propriÃ©tÃ©s calculÃ©es<br />
<br />

_Les Ã©vÃ©nements personnalisÃ©s vous permettent de dÃ©finir un Ã©vÃ©nement Ã  Ã©couter pour le composant parent._

-----

#### Question 6 : Quelle mÃ©thodologie a Ã©tÃ© utilisÃ©e pour gÃ©nÃ©rer le CSS suivant ?

```css
.nav-item-vje2901e { ... }
```

<i class="bi bi-circle"></i> Global CSS<br />
<i class="bi bi-circle"></i> Scoped CSS<br />
<i class="bi bi-record-circle"></i> Modules CSS<br />
<br />

_Les modules CSS sont une technique qui ajoute un hachage unique gÃ©nÃ©rÃ© dynamiquement pour minimiser les collisions CSS et les effets
secondaires._

-----

#### Question 7 : Lorsque vous dÃ©finissez un Ã©vÃ©nement personnalisÃ©, outre le nom de l'Ã©vÃ©nement, quel autre paramÃ¨tre pouvez-vous Ã©galement dÃ©finir ?

<i class="bi bi-circle"></i> Le type<br />
<i class="bi bi-record-circle"></i> Un payload<br />
<i class="bi bi-circle"></i> Required<br />
<i class="bi bi-circle"></i> Des variations de noms<br />
<br />

_En plus de pouvoir faire Ã©couter un Ã©vÃ©nement aux Ã©lÃ©ments parents, les composants enfants peuvent transmettre des donnÃ©es avec l'Ã©vÃ©nement
par le biais d'un payload._

-----

#### Question 8 : Quels sont les avantages des slots ?

*Attention, plusieurs rÃ©ponses sont possibles.*

<i class="bi bi-check-square-fill"></i> Ã‡a donne accÃ¨s Ã  une API flexibleÂ permettant aux dÃ©veloppeursÂ de placerÂ du contenu.<br />
<i class="bi bi-check-square-fill"></i> Ils permettent de crÃ©er diffÃ©rentes configurations sans avoir Ã  fournir plusieurs props.<br />
<i class="bi bi-check-square-fill"></i> Ã‡a permet aux dÃ©veloppeurs de dÃ©signer l'endroit oÃ¹ leur contenu apparaÃ®tra de maniÃ¨re intuitive avec
des emplacements nommÃ©s.<br />
<i class="bi bi-square"></i> Les slots garantissent que tout le contenu fourni entre les balises d'ouverture et de fermeture d'un modÃ¨le est
supprimÃ©.<br />
<br />

_Les slots sont une technique puissante qui vous permet de dÃ©finir des zones dans votre composant qui peuvent accepter du contenu de maniÃ¨re
flexible._
