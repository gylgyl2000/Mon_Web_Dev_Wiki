---
sidebar_position: 5
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Vimeo } from 'mdx-embed';

# G√©rez les donn√©es de votre application

## D√©couvrez le principe de state management

[D√©couvrez le principe de state management - Cr√©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6865336-decouvrez-le-principe-de-state-management)

![](https://user.oc-static.com/upload/2020/05/20/1589959826441_Bannee-dimension-720-798-04.png)

Lorsque l'on travaille avec des applications monopages (SPA), le concept de _state management_ (gestion d'√©tat)¬†est un sujet couramment abord√©.

Et m√™me si ce sujet peut souvent mener √† des discussions tr√®s complexes, le principal objectif recherch√© par tous est le suivant :

> s'assurer que l'application utilise les bonnes donn√©es √† tout moment.

Sur cette base, nous pouvons d√©finir le **state** (ou _√©tat_, en fran√ßais)¬†comme un instantan√© du data store √† un moment donn√©. De multiples
states sont utilis√©s √† travers une application, ce qui explique la complexit√© inh√©rente √† la gestion de ces √©l√©ments. Apr√®s tout, chaque
composant utilis√© contient sa propre propri√©t√© `data`, ce qui signifie qu'il g√®re son propre state. Une fois que l'on ajoute la complexit√© du
passage de donn√©es entre composants, cela devient effectivement tr√®s compliqu√©.

Pour illustrer cela, combien y a-t-il d'instances de state repr√©sent√©es dans l'exemple suivant ?

##### src/components/GroceryList.vue

```html
<template>
    <div>
        <h1>{{ pageTitle }}</h1>
        <ul>
            <ListItem
                v-for="item in list"
                :key="item"
                :item="item"
            />
        </ul>
    </div>
</template>
<script>
import ListItem from './components/ListItem.vue'
export default {
    name: 'GroceryList',
    components: {
        ListItem
    },
    data() {
        return {
            list: ['pommes', 'bananes', 'cerises'],
            pageTitle: 'Ma liste de courses'
        }
    }
}
</script>
```

√Ä premi√®re vue, il semblerait qu'il y ait deux instances d'√©tat : le composant parent `<GroceryList>`¬†et le composant enfant `<ListItem>`.
Pourtant, il s'av√®re que nous sommes en r√©alit√© en pr√©sence de 4 instances de state au total :
1. GroceryList.
2. ListItem item="pommes".
3. ListItem item="bananes".
4. ListItem item="cerises".

Pour comprendre cela, imaginez que le composant `<ListItem>` ait √©t√© d√©fini comme suit :

```html
<template>
    <div>
        <input type="checkbox" v-model="isPurchased" />
        <label>{{ item }}</label>
    </div>
</template>
<script>
export default {
    name: 'ListItem',
    props: {
        item: String
    },
    data() {
        return {
            isPurchased: false
        }
    }
}
</script>
```

Comme vous pouvez l'imaginer, chaque article de `<GroceryList>`¬†doit pouvoir g√©rer le fait qu'il a √©t√© achet√© ou non. Si les composants enfants
partageaient un¬†state¬†unique, alors le fait de cocher un seul article mettrait automatiquement √† jour les autres composants üò±.

### R√©cup√©rez vos datas √† la source unique de v√©rit√©

Dans les discussions autour de la gestion¬†du state, et parmi les termes couramment cit√©s, appara√Æt l'id√©e d'une ¬´ source unique de v√©rit√© ¬ª
(qui est aussi parfois abr√©g√©e en ¬´ SSoT ¬ª pour _Single Source of Truth_). Le concept fondamental derri√®re une source unique de v√©rit√© est
d'√©viter la duplication inutile de donn√©es dans l'application.

Bien que cela puisse para√Ætre anodin √† premi√®re vue, le fait de stocker plusieurs copies des m√™mes donn√©es dans une application est souvent la
principale cause de¬†bugs dans un syst√®me, car cela permet l'existence de diff√©rents jeux des ¬´ m√™mes ¬ª donn√©es en m√™me temps. Au lieu de
n'avoir √† mettre √† jour qu'un seul jeu de donn√©es, l'application devra g√©rer plusieurs jeux de donn√©es, ce qui est probl√©matique, car :
- du point de vue du code, cela s'av√®re bien plus difficile √† g√©rer, car il existe une d√©pendance qu'il est facile d'oublier √† mesure que le
syst√®me se complexifie ;
- des bugs apparaissent en plus grand nombre √† la suite de cette fragmentation.

C'est¬†pour cette raison que¬†le concept de source unique de v√©rit√© est essentiel au succ√®s de tout syst√®me de gestion du state.

### Entra√Ænez-vous

Vous trouverez le code source des exercices dans [le repo GitHub du cours](https://github.com/amandinelemoult2109/Vue-fr), dans le dossier
`cafe-with-a-view`. Pour commencer, consultez la branche `P4C1-Begin`.

#### Instructions

1. √âvaluez le state actuel de l'application et d√©terminez o√π se trouvent les diff√©rentes propri√©t√©s des donn√©es.
2. Cr√©ez un plan ou un document visuel repr√©sentant la structure du state de l'application.

:::info Analyse du state de Cafe with a Vue

**Donn√©es Globales**

Voici les donn√©es qui ont le plus besoin d'√™tre partag√©es entre plusieurs composants au fur et √† mesure o√π l'application grossit :
- Restaurant Name
- Menu Items
- Shopping Cart

**Donn√©es Locales**

Les informations ci-dessous sont typiquement contenues dans une seule page donc n'ont pas besoin d'√™tre partag√©es entre plusieurs composants :
- Contact

**Note** : Il s'agit ici d'une interpr√©tation possible de comment les donn√©es sont organis√©es. Il y a plusieurs moyens de le faire, et sentez
vous libre de tester diff√©rentes id√©es quand vous construisez des applications.
:::

### En r√©sum√©

Dans notre vision du syst√®me de¬†gestionnaire de state id√©al, ce dernier devrait √™tre capable de :
- cr√©er un espace de stockage de donn√©es unique qui servira de source unique de v√©rit√© pour toutes les donn√©es partag√©es ;
- permettre √† n'importe quel composant¬†de r√©cup√©rer des donn√©es directement ;
- permettre √† n'importe quel composant de modifier le data store unique directement.

_Par chance, l'√©cosyst√®me Vue.js dispose d'un syst√®me de¬†state management¬†capable de faire cela √† notre place : Vuex. H√¢te d'en savoir plus ?
Rendez-vous au prochain chapitre ! üöÄ_

-----

## Cr√©ez un data store centralis√© avec Vuex

[Cr√©ez un data store centralis√© avec Vuex - Cr√©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6869761-creez-un-data-store-centralise-avec-vuex)

![](https://user.oc-static.com/upload/2020/05/20/15899598448174_Bannee-dimension-720-798-04.png)

**Vuex** est un gestionnaire d'√©tat et une biblioth√®que pour les applications Vue.js. En d'autres termes, le but unique de Vuex est de nous
aider √† cr√©er un store centralis√© qui nous permettra d'avoir cette "source unique de v√©rit√©" pour r√©cup√©rer nos datas.

### Installez Vuex

Gr√¢ce √† Vue CLI, il suffit d'ex√©cuter la commande suivante dans notre terminal pour ajouter Vuex √† notre projet :

```shell
vue add vuex
```

Une fois Vuex ajout√© √† votre application par Vue CLI, vous devriez voir un r√©sultat similaire dans votre terminal :

<figure>
    <img src="https://user.oc-static.com/upload/2020/04/03/15859090743929_15694861994517_vuex-install.png"
         alt="Output de l'installation de Vuex dans le terminal" />
    <figcaption>Ce que vous devriez voir dans votre terminal</figcaption>
</figure>

Cela signifie que Vuex est bien install√© dans votre application. Tout √ßa en un clic, on s'en sort bien, non üòé ? Maintenant, voyons voir quels
changements ont √©t√© apport√©s √† notre application.

#### src/main.js

```javascript
import Vue from 'vue'
import App from './App.vue'
import store from './store'

Vue.config.productionTip \= false

new Vue({
    store,
    render: h => h(App)
}).$mount('#app')
```

En regardant le fichier `main.js` de plus pr√®s, vous remarquerez que le plugin a introduit le `store`¬†en tant que nouvelle configuration sur
notre instance de Vue. De la m√™me mani√®re que nous configurerions une propri√©t√© `data`¬†pour mettre en place un nouveau data store, vous pouvez
consid√©rer cette propri√©t√© `store`¬†comme¬†le data store¬†global que nous allons configurer avec Vuex.

Jetons un ≈ìil au fichier dans lequel toute la magie Vuex a lieu : `src/store.js`.

### Rencontrez¬†store/index.js

```javascript
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
    state: {

    },
    mutations: {

    },
    actions: {

    }
})
```

En parcourant `store/index.js`, vous remarquerez une nouvelle ligne de code que nous n'avions pas encore rencontr√©e :

```javascript
Vue.use(Vuex)
```

Cette syntaxe est utilis√©e pour le [syst√®me de plugins Vue](https://fr.vuejs.org/v2/guide/plugins.html). Cette m√©thode permet d'ajouter une
fonctionnalit√© globale √† notre instance de Vue. Et comme notre but est d'ajouter un data store global dans notre application, le syst√®me de
plugin est parfait pour ajouter Vuex √† notre application.

Ensuite, comme pour la mise en place d'une nouvelle instance de Vue avec `new Vue()`, Vuex est install√© de la m√™me mani√®re avec¬†`new Vuex.Store()`.
Et vous pouvez √©galement lui passer des options de configuration, exactement comme pour une nouvelle instance de Vue.

### Configurez Vuex

Comme nous le voyons dans `store/index.js`, l'initialisation d'un nouveau store Vuex ne n√©cessite qu'une seule configuration. Cela se fait par
un objet contenant trois cl√©s : (1) state, (2) mutations et (3) actions.

```javascript
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
    state: {

    },
    mutations: {

    },
    actions: {

    }
})
```

### Entra√Ænez-vous

Vous trouverez le code source des exercices dans [le repo GitHub du cours](https://github.com/amandinelemoult2109/Vue-fr), dans le dossier
`cafe-with-a-view`. Pour commencer, consultez la branche `P4C2-Begin`.

#### Instructions

1. Ajoutez Vuex √† l'application.
2. V√©rifiez que¬†la boilerplate pour le store est bien pr√©sente dans un fichier comme `store/index.js`.

```javascript title="store/index.js"
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
    state: {
    },
    mutations: {
    },
    actions: {
    },
    modules: {
    }
})
```

### En r√©sum√©

Dans ce chapitre, nous avons appris :
- ce qu'est Vuex : une biblioth√®que de gestion d'√©tat permettant de cr√©er un store centralis√© qui deviendra la seule source de v√©rit√© de notre
app ;
- comment installer Vuex sur notre application ;
- le fonctionnement de la structure de Vuex.

_Maintenant que nous avons ajout√© Vuex √† notre projet avec succ√®s, il est temps de d√©couvrir son fonctionnement ! C'est parti dans le chapitre
suivant ! üöÄ_

-----

## R√©cup√©rez des donn√©es depuis Vuex

[R√©cup√©rez des donn√©es depuis Vuex - Cr√©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6870051-recuperez-des-donnees-depuis-vuex)

![](https://user.oc-static.com/upload/2020/05/20/15899602015333_Bannee-dimension-720-798-04.png)

Maintenant que nous avons install√© Vuex¬†dans¬†notre application, il est temps pour nous de comprendre son fonctionnement. Et comme Vuex nous
sert de store global, nous devrions commencer par apprendre d√®s maintenant comment stocker et r√©cup√©rer les donn√©es qui s'y trouvent.
Commen√ßons tout de suite ! üöÄ

### Stockez des donn√©es dans Vuex

Dans Vuex, notre data store¬†est d√©fini en tant que¬†`state`¬†dans l'objet de configuration `store/index.js`.¬†Il s'agit d'un nouveau¬†terme √†
apprendre, mais vous pouvez comparer cela √† la propri√©t√© `data`¬†que nous utilisons depuis le d√©but.

<Vimeo vimeoId="413530181" />

<br />

<figure>
    <img src="https://user.oc-static.com/upload/2020/04/27/15879920195864_15694885347961_Screen_Shot_2019-08-12_at_7.57.01_PM.png"
         alt="Une comparaison entre le state¬†du store Vuex et le data store d'un objet de config standard Vue" />
    <figcaption>Une comparaison entre le state¬†du store Vuex et le data store d'un objet de config standard Vue</figcaption>
</figure>

Lorsqu'il s'agit de stocker des donn√©es dans Vuex, c'est aussi simple que d'ajouter des paires cl√©-valeur, comme vous le feriez dans tout autre
objet JavaScript normal.

```javascript
export default new Vuex.Store({
    state: {
        month: 8,
        day: 12,
        year: 2008
    }
})
```

:::note ?
Du coup, cela veut dire que je devrais tout mettre dans le state Vuex plut√¥t que dans le data store des composants ?
:::

Il peut para√Ætre tentant de tout mettre dans le store global ; mais ce n'est pas ce qu'il faut faire, car une partie de ce qui rend
l'architecture par composants aussi puissante est sa capacit√© √†¬†d√©couper un certain nombre de sujets. L'id√©e est de remonter les donn√©es √† un
niveau global¬†uniquement¬†lorsque vous constaterez qu'il est n√©cessaire d'acc√©der aux donn√©es √† partir de plusieurs composants.

### R√©cup√©rez des donn√©es dans Vuex

Maintenant que nous savons comment d√©finir les donn√©es dans Vuex, l'√©tape suivante consiste naturellement √† d√©terminer comment acc√©der √† nos
donn√©es depuis nos composants. Il existe deux fa√ßons de faire.

#### Utilisez `$store`

Au fur et √† mesure que vous allez approfondir des techniques plus avanc√©es de Vue et que vous d√©velopperez vos connaissances, vous d√©couvrirez
des propri√©t√©s qui sont pr√©c√©d√©es du symbole dollar. En voici quelques exemples :
- `this.$options`¬†;
- `this.$parent`¬†;
- `this.$children`¬†;
- etc.

Il s'agit de propri√©t√©s sp√©cifiques √† l'instance de Vue sur laquelle vous travaillez ; elles sont pr√©c√©d√©es du signe dollar afin de garantir
que ces m√©thodes sont bien utilis√©es comme pr√©vu.

Comme notre `store`¬†Vuex est inject√© √† un niveau global √† travers tous nos composants, cela signifie que nous avons acc√®s √† une propri√©t√©
`$store`¬†qui nous permettra d'acc√©der directement √† Vuex dans sa totalit√©.

Si on reprend notre exemple situ√© plus haut, nous pourrions acc√©der √† notre `state`¬†via `$store`¬†par ce qui suit :

```html
<template>
    <p>La date stock√©e dans Vuex est le {{ $store.state.day }}-{{ $store.state.month }}-{{ $store.state.year }}.</p>
</template>
```

Cependant, notre template commence √† √™tre un peu encombr√©. Il serait pratique d'avoir un moyen plus simple de¬†faire r√©f√©rence au¬†store,
n'est-ce pas ? Eh bien, heureusement pour nous, il y a : `mapState`¬†!

#### Utilisez `mapState`

Vuex nous fournit un moyen d'associer¬†le state √† des variables que nous pouvons appeler dans nos composants, √©vitant ainsi de devoir appeler
`$store`¬†√† chaque fois : `mapState`. Cette m√©thode nous permet de demander √† Vuex les propri√©t√©s de state¬†de notre choix, et il les ajoutera √†
nos propri√©t√©s calcul√©es.

```javascript
export default new Vuex.Store({
    state: {
        month: 8,
        day: 12,
        year: 2008
    }
}
```

```html
<template>
    <p>La date stock√©e dans Vuex est le {{ day }}-{{ month }}-{{ year }}.</p>
</template>

<script>
import { mapState } from 'vuex'

export default {
    computed: {
        ...mapState(['year', 'month', 'day'])
    }
}
</script>
```

::üíÅ 
Vous pouvez remarquer que j'utilise ici la [syntaxe¬†de d√©composition](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/Syntaxe_d%C3%A9composition)
(_spread operator_) "..." avant mapState. Cela n'est pas obligatoire, mais il est courant d'utiliser cette syntaxe¬†de d√©composition pour
d√©finir d'autres propri√©t√©s calcul√©es.
:::

En cas de conflit sur les noms, vous aurez peut-√™tre besoin de donner un nom diff√©rent √† vos variables¬†du state Vuex dans votre composant, ce
qui est facilement r√©alisable en¬†switchant l'argument depuis un tableau vers un objet, comme ici :

```html
<template>
    <p>La date stock√©e dans Vuex est le {{ day }}-{{ uniqueMonth }}-{{ customYear }}.</p>
</template>

<script>
import { mapState } from 'vuex'

export default {
    computed: {
        ...mapState({
            customYear: 'year',
            uniqueMonth: 'month',
            day: 'day'
        })
    }
}
</script>
```

Dans cet objet, la cl√© repr√©sente le nouveau nom que vous voulez utiliser pour r√©f√©rencer votre valeur, tandis que la valeur correspond √† la
propri√©t√© de state que Vuex doit r√©f√©rencer.

:::info
Pour plus d'informations sur¬†le state dans Vuex,¬†vous pouvez consulter [la documentation officielle sur state](https://vuex.vuejs.org/fr/guide/state.html).
:::

Ceci √©tant dit, vous remarquerez probablement que nous sommes en train d'assembler notre date manuellement. Si cette date √©tait r√©f√©renc√©e √†
plusieurs endroits dans l'application, cela serait tr√®s difficile √† maintenir. Si seulement il existait un moyen de d√©finir des propri√©t√©s
calcul√©es dans un store Vuex...

### D√©couvrez¬†les getters

Lorsque `store.js`¬†est¬†g√©n√©r√© √† la base, il laisse de c√¥t√© une des propri√©t√©s qui est tr√®s utile dans de nombreux sc√©narios : les **¬´ getters ¬ª,
ou _accesseurs_**. Les **accesseurs**¬†peuvent √™tre vus comme¬†l'√©quivalent de la propri√©t√© calcul√©e (_computed_) dans Vue.

<Vimeo vimeoId="413530280" />

<br />

<figure>
    <img src="https://user.oc-static.com/upload/2020/05/04/15885823079235_15694889633907_Screen_Shot_2019-08-12_at_7.56.52_PM.png"
         alt="Une comparaison entre le getters du store Vuex et la propri√©t√© computed dans une configuration Vue classique" />
    <figcaption>Une comparaison entre le getters du store Vuex et la propri√©t√© computed dans une configuration Vue classique</figcaption>
</figure>

Cette comparaison montre la mani√®re dont les accesseurs dans un store Vuex correspondent th√©oriquement √† la propri√©t√© calcul√©e dans un objet de
configuration Vue standard.

Ainsi, dans notre exemple de date, voil√† la mani√®re avec laquelle nous d√©finirions notre date format√©e :

```javascript
export default new Vuex.Store({
    state: {
        month: 7,
        day: 23,
        year: 2010
    },
    getters: {
        formattedDate: state => {
            return `${state.day}-${state.month}-${state.year}`
        }
    }
}
```

Comme vous pouvez le voir dans l'exemple, chaque **accesseur** est une fonction qui re√ßoit le **state**¬†comme argument et retourne une valeur √†
laquelle nous pourrons acc√©der plus tard.

Ensuite, nous pouvons simplifier notre code encore davantage dans le composant, gr√¢ce √† `mapGetters`, qui fonctionne comme `mapState`.

```html
<template>
    <p>La date stock√©e dans Vuex est le {{ formattedDate }}.</p>
</template>

<script>
import { mapGetters } from 'vuex'

export default {
    computed: {
        ...mapGetters(['formattedDate'])
    }
}
</script>
```

Et tout comme `mapState`, `mapGetters`¬†peut √©galement prendre un objet qui vous permet de d√©finir des noms personnalis√©s pour les accesseurs
que vous r√©f√©rencez.

:::info
Pour plus d'informations sur les accesseurs, vous pouvez consulter [la documentation officielle sur les accesseurs](https://vuex.vuejs.org/fr/guide/getters.html).
:::

### Entra√Ænez-vous

Vous trouverez le code source des exercices dans [le repo GitHub du cours](https://github.com/amandinelemoult2109/Vue-fr), dans le dossier
`cafe-with-a-view`. Pour commencer, consultez la branche `P4C3-Begin`.

#### Instructions

1. Migrez les donn√©es du `shoppingCart`¬†vers Vuex.
2. Migrez les donn√©es relatives √† `restaurantName`¬†vers Vuex.
3. Migrez les donn√©es de `simpleMenu`¬†vers Vuex.
4. Migrez `copyright` vers les accesseurs (_getters_).

```html title="views/Home.vue"
...
<script>
import MenuItem from "../components/MenuItem"

export default {
	name: "Home",
	components: {
		MenuItem
	},
	data() {
		return {
			restaurantName: "La belle vue",
			shoppingCart: 0,
			simpleMenu: [
				{
					name: "Croissant",
					image: {
						source: "/images/crossiant.jpg",
						alt: "Un croissant"
					},
					inStock: true,
					quantity: 1,
					price: 2.99
				},
				{
					name: "Baguette de pain",
					image: {
						source: "/images/french-baguette.jpeg",
						alt: "Quatre baguettes de pain"
					},
					inStock: true,
					quantity: 1,
					price: 3.99
				},
				{
					name: "√âclair",
					image: {
						source: "/images/eclair.jpg",
						alt: "√âclair au chocolat"
					},
					inStock: false,
					quantity: 1,
					price: 4.99
				}
			]
		}
	},
	computed: {
		copyright() {
			const currentYear = new Date().getFullYear()

			return `Copyright ${this.restaurantName} ${currentYear}`
		}
	},
	methods: {
		addToShoppingCart(amount) {
			this.shoppingCart += amount
		}
	}
}
</script>
```

```html title="views/Home.vue"
...
<script>
import MenuItem from "../components/MenuItem"
import { mapGetters, mapState } from "vuex"

export default {
	name: "Home",
	components: {
		MenuItem
	},
	computed: {
		...mapGetters({
			copyright: "copyright"
		}),
		...mapState({
			restaurantName: "restaurantName",
			shoppingCart: "shoppingCart",
			simpleMenu: "simpleMenu"
		})
	},
	methods: {
		addToShoppingCart(amount) {
			this.shoppingCart += amount
		}
	}
}
</script>
```

```javascript title="store/index.js"
import Vue from "vue"
import Vuex from "vuex"

Vue.use(Vuex)

export default new Vuex.Store({
	state: {
		restaurantName: "La belle vue",
		shoppingCart: 0,
		simpleMenu: [
			{
				name: "Croissant",
				image: {
					source: "/images/crossiant.jpg",
					alt: "Un croissant"
				},
				inStock: true,
				quantity: 1,
				price: 2.99
			},
			{
				name: "Baguette de pain",
				image: {
					source: "/images/french-baguette.jpeg",
					alt: "Quatre baguettes de pain"
				},
				inStock: true,
				quantity: 1,
				price: 3.99
			},
			{
				name: "√âclair",
				image: {
					source: "/images/eclair.jpg",
					alt: "√âclair au chocolat"
				},
				inStock: false,
				quantity: 1,
				price: 4.99
			}
		]
	},
	getters: {
		copyright: (state) => {
			const currentYear = new Date().getFullYear()

			return `Copyright ${state.restaurantName} ${currentYear}`
		}
	},
	mutations: {},
	actions: {},
	modules: {}
})
```

### En r√©sum√©

Dans ce chapitre, vous avez appris √† :
- d√©finir le data store¬†dans Vuex avec **state** ;
- r√©cup√©rer des propri√©t√©s depuis Vuex dans vos composants avec `$store`¬†;
- d√©finir des propri√©t√©s calcul√©es √† l'aide d'**accesseurs** dans Vuex ;
- r√©cup√©rer le **state** depuis Vuex avec mapState ;
- r√©cup√©rer des accesseurs depuis Vuex avec mapGetters.

_Dans le chapitre suivant, nous verrons comment mettre √† jour et modifier notre store dans Vuex avec les mutations et les actions. Alors,
rendez-vous au chapitre suivant !_

-----

## Modifiez vos donn√©es dans Vuex

[Modifiez vos donn√©es dans Vuex - Cr√©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6870776-modifiez-vos-donnees-dans-vuex)

![](https://user.oc-static.com/upload/2020/05/20/15899602304117_Bannee-dimension-720-798-04.png)

### D√©couvrez les mutations

Dans le chapitre pr√©c√©dent, nous avons appris √† d√©finir notre espace de stockage de donn√©es dans Vuex avec `state`¬†et des accesseurs, mais
√©galement √† r√©cup√©rer nos donn√©es avec des m√©thodes comme `mapState`¬†et `mapGetters`. Dans ce chapitre, nous allons passer √† l'√©tape suivante
dans la gestion de notre data store¬†: mettre √† jour et modifier nos donn√©es dans Vuex avec les **mutations**.

<Vimeo vimeoId="413530387" />

<br />

Comme nous l'avons vu dans la structure initiale de store.js :

```javascript
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
	state: {
	},
	mutations: {
	},
	actions: {
	}
})
```

La deuxi√®me cl√© d√©finie dans le store est appel√©e **_mutation_**. Comme son nom l'indique, elle contiendra un objet de toutes les propri√©t√©s
responsables¬†de modifications du `state`.

#### D√©finissez¬†une mutation

Si nous prenons l'exemple traditionnel du compteur, nous pouvons d√©finir une mutation comme suit :

```javascript
export default new Vuex.Store({
	state: {
		count: 0
	},
	mutations: {
		INCREASE_COUNT(state) {
			state.count += 1
		}
	},
	actions: {
	}
})
```

:::info
La convention de nommage pour les mutations consiste √† utiliser uniquement des majuscules avec des underscores pour s√©parer les mots. Cela
fait partie des bonnes pratiques et permet d'indiquer clairement qu'il ne s'agit pas de fonctions normales √† appeler par hasard.
:::

Par d√©faut, la mutation re√ßoit le `state`¬†en premier argument. Ce dernier peut ensuite √™tre utilis√© pour effectuer les modifications
n√©cessaires. Dans l'exemple ci-dessus, nous ne faisons qu'incr√©menter¬†`state.count`¬†de 1.

Cependant,¬† cette technique a ses limites car nous pourrions envisager de rendre la valeur incr√©ment√©e dynamique. Heureusement, les mutations
peuvent prendre un deuxi√®me argument : le param√®tre **payload**.

```javascript
export default new Vuex.Store({
	state: {
		count: 0
	},
	mutations: {
		INCREASE_COUNT(state, payload) {
			state.count += Number(payload)
		}
	},
	actions: {
	}
})
```

Dans l'exemple r√©vis√©, nous autorisons maintenant l'utilisateur √† :
- transmettre¬†de combien nous voulons que `state.count`¬†soit incr√©ment√©e ;
- fixer une valeur par d√©faut de 1, au cas o√π l'utilisateur oublie de transmettre une valeur ;
- convertir la valeur en nombre pour qu'elle ne s'ajoute pas comme cha√Æne de caract√®res par accident.

#### Actez une mutation

Lorsqu'il s'agit de modifier le state d'une application, il est **essentiel** que cela soit fait au bon moment. En d'autres termes, une
attention et un soin particuliers sont accord√©s √† ces √©v√©nements, afin de s'assurer que toute erreur soit facilement identifi√©e. Par
cons√©quent, plut√¥t que d'invoquer la mutation comme une fonction normale, nous utilisons une action sp√©ciale : **commit**.

Lorsqu'une mutation est act√©e, l'action commit prend deux param√®tres :
- nom de la mutation ;
- payload (facultatif).

```javascript
this.$store.commit('INCREMENT_COUNT', 2)
```

:::caution
En revanche, m√™me s'il est techniquement possible d'appeler des mutations directement √† partir des composants, je ne vais pas vous le montrer,
car ce n'est pas consid√©r√© comme une bonne pratique dans les applications Vue.js.
:::

Lorsqu'une mutation est act√©e, la modification est faite imm√©diatement. En d'autres termes, les mutations Vuex sont **synchrones**, ce qui
signifie qu'il n'est par exemple pas possible de r√©cup√©rer des donn√©es d'une API dans une mutation.

:::info
L'avantage, c'est que votre¬†state se transforme en timeline historique, dans laquelle vous pouvez retracer les modifications apport√©es √† ce
state, chaque mutation se produisant √©tape par √©tape.
:::

Bien s√ªr, vous vous demandez probablement de quelle mani√®re il faudrait acter les mutations.¬†Pour r√©pondre √† cette question, nous allons¬†devoir
parler des **actions**.

### D√©couvrez les actions

Jusqu'√† pr√©sent, nous avons appris que :
- `State`¬†contient notre¬†data store global ;
- les accesseurs (_getters_) servent de propri√©t√©s calcul√©es √† nos espaces de stockage de donn√©es ;
- les mutations nous permettent de mettre √† jour/modifier le state.

La derni√®re pi√®ce du puzzle est les **actions**. Elles nous servent √†¬†coordonner la logique derri√®re les mutations. En d'autres termes, elles
sont similaires √† la propri√©t√© `methods`¬†dans une instance de Vue.

<Vimeo vimeoId="413530448" />

<br />

<figure>
    <img src="https://user.oc-static.com/upload/2020/04/27/1587999992018_15694897862639_Screen_Shot_2019-08-12_at_7.55.31_PM.png"
         alt="Les actions dans le store Vuex sont similaires √† la propri√©t√©¬†methods¬†dans une instance Vue" />
    <figcaption>Les actions dans le store Vuex sont similaires √† la propri√©t√©¬†methods¬†dans une instance Vue</figcaption>
</figure>

### D√©finissez une action

Pour continuer avec notre exemple de compteur, nous pourrions d√©finir notre action de la fa√ßon suivante :

```javascript
export default new Vuex.Store({
	state: {
		count: 0
	},
	mutations: {
		INCREASE_COUNT(state, amount = 1) {
			state.count += Number(amount)
		}
	},
	actions: {
		incrementCount(context, amount) {
			context.commit('INCREMENT_COUNT', amount)
		}
	}
})
```

Une action est compos√©e d'un nom, du param√®tre `context`¬†et d'un **payload** optionnel (comme¬†pour les mutations). Dans l'exemple ci-dessus :
- `incrementCount` est le nom de l'action ;
- le param√®tre `context`¬†nous donne acc√®s aux m√™mes m√©thodes et propri√©t√©s dans l'instance du store Vuex (par exemple, commit, state, getters,
etc.) ;
- `amount`¬†est le payload que nous devons transmettre √† la mutation, afin qu'elle augmente de la bonne valeur.

:::info
Comme je l'ai fait dans cet exemple, vous pouvez renommer le payload comme vous le souhaitez. Cependant, sachez simplement qu'il est d√©sign√©
comme le _payload_ lorsque l'on parle d'une impl√©mentation.
:::

### D√©couvrez l'utilit√© des actions

Sur la base de l'exemple ci-dessus, vous vous demandez peut-√™tre pourquoi ne pas simplement appeler la mutation directement. Mais que se
passerait-il lorsqu'il faut diminuer le `count` d'une certaine valeur ?

```javascript
export default new Vuex.Store({
	state: {
		count: 0
	},
	mutations: {
		INCREASE_COUNT(state, amount = 1) {
			state.count += Number(amount)
		},
		DECREASE_COUNT(state, amount = 1) {
			state.count -= Number(amount)
		}
	},
	actions: {
		incrementCount(context, amount) {
			context.commit('INCREMENT_COUNT', amount)
		}
	}
})
```

Une certaine logique est n√©cessaire pour d√©terminer quand d√©clencher chaque mutation. Pour tenir compte de cela,¬†rendons¬†notre action
g√©n√©rique de la mani√®re suivante :

```javascript
export default new Vuex.Store({
	state: {
		count: 0
	},
	mutations: {
		INCREASE_COUNT(state, amount = 1) {
			state.count += Number(amount)
		},
		DECREASE_COUNT(state, amount = 1) {
			state.count -= Number(amount)
		}
	},
	actions: {
		updateCount(context, amount) {
			if (amount >= 0) {
				context.commit('INCREASE_COUNT', amount)
			} else {
				context.commit('DECREASE_COUNT', amount)
			}
		}
	}
})
```

:::note ?
Pourquoi ne pas simplement r√©unir les mutations en une seule ?
:::

Nous pourrions¬†rendre la mutation g√©n√©rique √† quelque chose comme `CHANGE_COUNT`, mais en regardant l'historique, cela¬†nous fournirait moins
de d√©tails, ce qui rend les choses plus difficiles √† d√©bugger. Par cons√©quent, il est pr√©f√©rable que les mutations gardent un seul usage.
Laissez la logique aux actions.

De plus, comme le param√®tre `context`¬†peut √™tre utilis√© pour acc√©der √† de nombreuses propri√©t√©s diff√©rentes du store Vuex, vous allez
d√©couvrir une technique de codage courante qui est l'[affectation par d√©composition](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/Affecter_par_d%C3%A9composition)
(_desctructuring_, en anglais). Elle est faite pour simplifier le code et le rendre plus facile √† lire. Avec notre exemple, cela ressemblerait
√† ce qui suit :

```javascript
export default new Vuex.Store({
	state: {
		count: 0
	},
	mutations: {
		INCREASE_COUNT(state, amount = 1) {
			state.count += Number(amount)
		},
		DECREASE_COUNT(state, amount = 1) {
			state.count -= Number(amount)
		}
	},
	actions: {
		updateCount({ commit }, amount) {
			if (amount >= 0) {
				commit('INCREASE_COUNT', amount)
			} else {
				commit('DECREASE_COUNT', amount)
			}
		}
	}
})
```

En plus de nous donner la libert√© de d√©terminer la logique du moment o√π les mutations sont d√©clench√©es, les `actions` sont **asynchrones**.
Cela signifie que vous ne pouvez appeler des API et acter des mutations qu'en cas de r√©ussite. Ou en fonction de ce que vous souhaitez r√©aliser.

Maintenant que nous savons comment d√©finir les actions, la question suivante se pose : comment les utiliser dans nos composants ?

#### Utilisez les actions dans les composants

Tout comme il existe un terme sp√©cial pour invoquer les mutations (c'est-√†-dire acter ou ¬´¬†commit ¬ª), il existe aussi un terme sp√©cial pour
les actions : **propager (_dispatch_)**. En d'autres termes, vous envoyez l'action pour ex√©cuter une t√¢che. Donc, si vous vouliez propager une
action depuis votre composant, cela ressemblerait √† ce qui suit :

```html
<template>
	<div>
		<p>{{ count }}</p>
		<button @click="sendUpdateCountAction">Increment</button>
	</div>
</template>

<script>
import { mapState } from 'vuex'

export default {
	computed: {
		...mapState(['count'])
	},
	methods: {
		sendUpdateCountAction() {
			this.$store.dispatch('updateCount')
		}
	}
}
</script>
```

Cependant, comme pour `mapState`¬†et `mapGetters`, il existe un √©quivalent pour les actions : `mapActions`.

```html
<template>
	<div>
		<p>{{ count }}</p>
		<button @click="updateCount">Increment</button>
	</div>
</template>

<script>
import { mapState, mapActions } from 'vuex'

export default {
	computed: {
		...mapState(['count'])
	},
	methods: {
		...mapActions(['updateCount'])
	}
}
</script>
```

Vous connaissez maintenant les principaux √©l√©ments de Vuex !

### Entra√Ænez-vous

Vous trouverez le code source des exercices dans [le repo GitHub du cours](https://github.com/amandinelemoult2109/Vue-fr), dans le dossier
`cafe-with-a-view`. Pour commencer, consultez la branche `P4C4-Begin`.

#### Instructions

1. Migrez l'√©v√©nement d'ajout au panier de `Home.vue`¬†et `MenuItem.vue`¬†vers Vuex.
2. Cr√©ez une mutation qui¬†met √† jour le `state`¬†du shoppingCart.
3. Cr√©ez une action qui peut √™tre d√©clench√©e depuis `MenuItem.vue`¬†qui met √† jour le panier d'achat dans `Home.vue`.


```html {8,47-51} title="views/Home.vue"
<template>
	<div>
		...
		<section class="menu">
			<h2>Menu</h2>
			<MenuItem
				v-for="item in simpleMenu"
				@add-items-to-cart="addToShoppingCart" <!--  supprimer -->
				:name="item.name"
				:image="item.image"
				:price="item.price"
				:quantity="item.quantity"
				:inStock="item.inStock"
				:key="item.name"
			/>
		</section>

		<div class="shopping-cart">
			<h2>Panier: {{ shoppingCart }} articles</h2>
		</div>

		<footer class="footer">
			<p>{{ copyright }}</p>
		</footer>
	</div>
</template>

<script>
import MenuItem from "../components/MenuItem"
import { mapGetters, mapState } from "vuex"

export default {
	name: "Home",
	components: {
		MenuItem
	},
	computed: {
		...mapGetters({
			copyright: "copyright"
		}),
		...mapState({
			restaurantName: "restaurantName",
			shoppingCart: "shoppingCart",
			simpleMenu: "simpleMenu"
		})
	},
	methods: {									<!-- Supprimer -->
		addToShoppingCart(amount) {
			this.shoppingCart += amount
		}
	}
}
</script>
```

```html {8-11} title="components/MenuItem.vue"
<script>
import { mapActions } from "vuex" <!-- Ajouter -->
import BaseButton from "./BaseButton.vue"

export default {
	...
	methods: {
		<!-- updateShoppingCart(quantity) {				<!-- Modifier -->
			this.$emit("add-items-to-cart", quantity)
		} -->
		...mapActions(["updateShoppingCart"])
	},
	...
}
</script>
```

```javascript {17-26} title="storee/index.js"
import Vue from "vue"
import Vuex from "vuex"

Vue.use(Vuex)

export default new Vuex.Store({
	state: {
		...
	},
	getters: {
		copyright: (state) => {
			const currentYear = new Date().getFullYear()

			return `Copyright ${state.restaurantName} ${currentYear}`
		}
	},
	mutations: {
		ADD_ITEMS_TO_SHOPPING_CART(state, amount) {
			state.shoppingCart += amount
		}
	},
	actions: {
		updateShoppingCart({ commit }, amount) {
			commit("ADD_ITEMS_TO_SHOPPING_CART", amount)
		}
	},
	modules: {}
})
```

### En r√©sum√©

Dans ce chapitre, vous avez d√©couvert :
- ce que sont les mutations et les actions ;
- comment utiliser les mutations pour mettre √† jour le state ;
- comment utiliser les actions pour g√©rer vos mutations ;
- comment d√©clarer et utiliser des actions dans vos composants.

_C'est maintenant le moment de passer en revue nos acquis de la partie. Rendez-vous au prochain chapitre !_

-----

## R√©sum√© de la partie 4

[R√©sum√© de la partie 4 - Cr√©ez une application web avec Vue.js - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/6871196-resume-de-la-partie-4)

![](https://user.oc-static.com/upload/2020/05/20/15899603266314_Bannee-dimension-720-798-04.png)

Dans cette partie du cours, nous avons appris comment **g√©rer le state global d'une application avec Vuex**.
- Configurer une application Vue pour utiliser **Vuex** avec Vue CLI.
- D√©finir et r√©cup√©rer des donn√©es depuis le **state** (√©tat) de Vuex.
- D√©finir et r√©cup√©rer des donn√©es calcul√©es depuis les **accesseurs** (getters) de Vuex.
- D√©finir et acter des modifications du state¬†de Vuex avec les **mutations**.
- D√©finir et propager des mutations avec les **actions** Vuex.

F√©licitations ! Vous avez maintenant acquis une comp√©tence essentielle pour construire une application qui scale √† grande √©chelle.¬†C'est
maintenant le bon moment pour tester vos connaissances avec un quiz pr√©par√© juste pour vous. Bonne chance ! üçÄ

-----

## Quiz : G√©rez les donn√©es de votre application

[G√©rez les donn√©es de votre application - OpenClassrooms](https://openclassrooms.com/fr/courses/6390311-creez-une-application-web-avec-vue-js/exercises/3851)

#### Comp√©tences √©valu√©es

<i class="bi bi-check2-circle"></i> G√©rer les donn√©es d'une application

-----

#### Question 1 : Pourquoi la gestion d'√©tat (_state management_) est-elle importante ?

*Attention, plusieurs r√©ponses sont possibles.*

<i class="bi bi-check-square-fill"></i> La synchronisation des donn√©es d'une application peut devenir trop complexe √† mesure qu'une
application se d√©veloppe et s'√©tend.<br />
<i class="bi bi-check-square-fill"></i> Cela nous permet de cr√©er une source unique de v√©rit√© pour les donn√©es de notre application.<br />
<i class="bi bi-square"></i> Elle garantit que toutes les copies de donn√©es sont ind√©pendantes les unes des autres.<br />
<i class="bi bi-check-square-fill"></i> Les composants de notre application doivent pouvoir acc√©der aux donn√©es et les mettre √† jour, quel que
soit leur emplacement dans la codebase.<br />
<br />

_Il est difficile de synchroniser les donn√©es √† mesure qu'une application se d√©veloppe¬†et prend de l'ampleur. Les mod√®les de gestion d'√©tat
tels que Vuex sont essentiels pour r√©ussir √† construire une application √† plus grande √©chelle. La r√©ussite de la gestion d'un state est tr√®s
souvent li√©e au respect du principe de source unique de v√©rit√©._

-----

#### Question 2 : Quelle partie de Vuex est charg√©e d'apporter directement des modifications au data store ?

<i class="bi bi-circle"></i> Le state<br />
<i class="bi bi-circle"></i> Les getters<br />
<i class="bi bi-circle"></i> Les actions<br />
<i class="bi bi-record-circle"></i> Les mutations<br />
<br />

_Les mutations sont la seule fa√ßon d'apporter des changements au store Vuex._

-----

#### Question 3 : Quelle partie de Vuex est responsable de la gestion des donn√©es dans le store ?

<i class="bi bi-record-circle"></i> Le state<br />
<i class="bi bi-circle"></i> Les getters<br />
<i class="bi bi-circle"></i> Les actions<br />
<i class="bi bi-circle"></i> Les mutations<br />
<br />

_Vuex utilise le state comme data store, ce qui est analogue √† la propri√©t√© `data`¬†que nous utilisons dans les instances de Vue._

-----

#### Question 4 : Quelle partie de Vuex est responsable de la gestion de la logique qui peut d√©clencher des changements dans le data store ?

<i class="bi bi-circle"></i> Le state<br />
<i class="bi bi-circle"></i> Les getters<br />
<i class="bi bi-record-circle"></i> Les actions<br />
<i class="bi bi-circle"></i> Les mutations<br />
<br />

_Comme la seule responsabilit√© d'une mutation est la mise √† jour du store, la responsabilit√© des actions est de g√©rer la logique et de
d√©clencher¬†les appels asynchrones, ce qui peut d√©clencher autant de mutations que n√©cessaire._

-----

#### Question 5 : Quel est le mot cl√© pour d√©clencher une mutation ?

<i class="bi bi-circle"></i> <code>trigger</code><br />
<i class="bi bi-record-circle"></i> <code>commit</code><br />
<i class="bi bi-circle"></i> initiate<br />
<i class="bi bi-circle"></i> call<br />
<br />

_Le mot cl√© `commit`¬†permet d'appeler des mutations.

-----

#### Question 6 : Actuellement, un d√©veloppeur utilise les getters de la mani√®re suivante :

```javascript
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
	state: {
		price: 40
	},
	getters: {
		getPrice: state => state.price
	}
})
```

**Qu‚Äôest-ce qui est incorrect ?**

<i class="bi bi-circle"></i> Les getters ne doivent √™tre utilis√©s que pour les fonctions asynchrones.<br />
<i class="bi bi-record-circle"></i> Les getters sont destin√©s √† √™tre utilis√©s comme des propri√©t√©s calcul√©es plut√¥t que de simplement
r√©cup√©rer un √©tat, puisque l'on peut y acc√©der directement par des m√©thodes comme mapState.<br />
<i class="bi bi-circle"></i> Les getters doivent √™tre utilis√©s pour faire muter l'√©tat.<br />
<i class="bi bi-circle"></i> Il n'y a pas de probl√®me avec ce code.<br />
<br />

_Les getters sont utilis√©s pour calculer l'√©tat d√©riv√© sur la base de l'√©tat actuel du store. Les exemples comprennent le filtrage d'une liste
d'articles ou le renvoi de la longueur de la liste. SI vous voulez en apprendre plus, vous pouvez jeter un ≈ìil √† la [documentation officielle des getters (ou accesseurs, en fran√ßais).](https://vuex.vuejs.org/fr/guide/getters.html)._

-----

#### Question 7 : Un d√©veloppeur essaie de d√©bugger le code suivant :

```javascript
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
	state: {
		price: 40
	},
	mutations: {
		fetchPrice (state) {
			const response = fetch('/api/price')
			state = response
		}
	}
})
```

*Attention, plusieurs r√©ponses sont possibles.*

<i class="bi bi-check-square-fill"></i> Les mutations sont des transactions synchrones.<br />
<i class="bi bi-check-square-fill"></i> Les mutations ne peuvent pas contenir de code asynchrone comme la r√©cup√©ration de donn√©es √† partir
d'une API.<br />
<i class="bi bi-check-square-fill"></i> Elles doivent utiliser une <code>action</code> pour r√©cup√©rer les donn√©es et ensuite¬†acter une
mutation avec <code>commit</code> qui met √† jour l'√©tat.<br />
<i class="bi bi-square"></i> Elles doivent utiliser des getters √† la place des mutations.<br />
<br />

_Les mutations sont uniquement destin√©es √† la mise √† jour de l'√©tat, alors que les actions asynchrones n√©cessitent l'utilisateur d'actions._

-----

#### Question 8 : Quelle est la syntaxe la plus courante pour acc√©der aux actions d'un store Vuex dans un composant ?

<i class="bi bi-circle"></i> <code>...generateActions()</code><br />
<i class="bi bi-circle"></i> <code>...listActions()</code><br />
<i class="bi bi-record-circle"></i> <code>...mapActions()</code><br />
<i class="bi bi-circle"></i> <code>...getActions()</code><br />
<br />

_Bien que vous puissiez acc√©der aux actions de Vuex via `this.$store.dispatch`, il est plus courant d'utiliser `map` pour d√©finir les
propri√©t√©s que vous souhaitez voir disponibles dans Vue._

